{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { smartFormatter as _format, formatRange } from \"./smart_formatter\";\nimport { patchFontOptions, getVizRangeObject, getLogExt as getLog, raiseToExt as raiseTo, valueOf, rotateBBox, getCategoriesInfo, adjustVisualRange, getAddFunction, convertVisualRangeObject } from \"../core/utils\";\nimport { isDefined, isFunction, isPlainObject, type } from \"../../core/utils/type\";\nimport constants from \"./axes_constants\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport formatHelper from \"../../format_helper\";\nimport { getParser } from \"../components/parse_utils\";\nimport { tickGenerator } from \"./tick_generator\";\nimport { Translator2D } from \"../translators/translator2d\";\nimport { Range } from \"../translators/range\";\nimport { tick } from \"./tick\";\nimport { adjust } from \"../../core/utils/math\";\nimport dateUtils from \"../../core/utils/date\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport xyMethods from \"./xy_axes\";\nimport * as polarMethods from \"./polar_axes\";\nimport createConstantLine from \"./constant_line\";\nimport createStrip from \"./strip\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\nimport { calculateCanvasMargins, measureLabels } from \"./axes_utils\";\nvar convertTicksToValues = constants.convertTicksToValues;\nvar _math = Math;\nvar _abs = _math.abs;\nvar _max = _math.max;\nvar _min = _math.min;\nvar _isArray = Array.isArray;\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\nvar MAX_GRID_BORDER_ADHENSION = 4;\nvar TOP = constants.top;\nvar BOTTOM = constants.bottom;\nvar LEFT = constants.left;\nvar RIGHT = constants.right;\nvar CENTER = constants.center;\nvar KEEP = \"keep\";\nvar SHIFT = \"shift\";\nvar RESET = \"reset\";\nvar ROTATE = \"rotate\";\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\nvar SCROLL_THRESHOLD = 5;\nvar MIN_BAR_MARGIN = 5;\nvar MAX_MARGIN_VALUE = .8;\nvar dateIntervals = {\n  day: 864e5,\n  week: 6048e5\n};\n\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\n  var _options$workWeek;\n\n  var {\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold\n  } = _ref;\n  return tickGenerator({\n    axisType: options.type,\n    dataType: options.dataType,\n    logBase: options.logarithmBase,\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold,\n    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\n    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\n    numberMultipliers: options.numberMultipliers,\n    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\n    allowDecimals: options.allowDecimals,\n    endOnTick: options.endOnTick,\n    incidentOccurred: incidentOccurred,\n    firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\n    skipTickGeneration: skipTickGeneration,\n    skipCalculationLimits: options.skipCalculationLimits,\n    generateExtraTick: options.generateExtraTick,\n    minTickInterval: options.minTickInterval,\n    rangeIsEmpty: rangeIsEmpty\n  });\n}\n\nfunction createMajorTick(axis, renderer, skippedCategory) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.tick, options.grid, skippedCategory, false);\n}\n\nfunction createMinorTick(axis, renderer) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.minorTick, options.minorGrid);\n}\n\nfunction createBoundaryTick(axis, renderer, isFirst) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, extend({}, options.tick, {\n    visible: options.showCustomBoundaryTicks\n  }), options.grid, void 0, false, isFirst ? -1 : 1);\n}\n\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\n  (elements || []).forEach(e => e[action](actionArgument1, actionArgument2));\n}\n\nfunction initTickCoords(ticks) {\n  callAction(ticks, \"initCoords\");\n}\n\nfunction drawTickMarks(ticks, options) {\n  callAction(ticks, \"drawMark\", options);\n}\n\nfunction drawGrids(ticks, drawLine) {\n  callAction(ticks, \"drawGrid\", drawLine);\n}\n\nfunction updateTicksPosition(ticks, options, animate) {\n  callAction(ticks, \"updateTickPosition\", options, animate);\n}\n\nfunction updateGridsPosition(ticks, animate) {\n  callAction(ticks, \"updateGridPosition\", animate);\n}\n\nfunction cleanUpInvalidTicks(ticks) {\n  var i = ticks.length - 1;\n\n  for (i; i >= 0; i--) {\n    if (!removeInvalidTick(ticks, i)) {\n      break;\n    }\n  }\n\n  for (i = 0; i < ticks.length; i++) {\n    if (removeInvalidTick(ticks, i)) {\n      i--;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction removeInvalidTick(ticks, i) {\n  if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\n    ticks.splice(i, 1);\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateAxisOptions(options) {\n  var _labelOptions$minSpac;\n\n  var labelOptions = options.label;\n  var position = options.position;\n  var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\n  var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\n  var labelPosition = labelOptions.position;\n\n  if (position !== defaultPosition && position !== secondaryPosition) {\n    position = defaultPosition;\n  }\n\n  if (!labelPosition || \"outside\" === labelPosition) {\n    labelPosition = position;\n  } else if (\"inside\" === labelPosition) {\n    labelPosition = {\n      [TOP]: BOTTOM,\n      [BOTTOM]: TOP,\n      [LEFT]: RIGHT,\n      [RIGHT]: LEFT\n    }[position];\n  }\n\n  if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\n    labelPosition = position;\n  }\n\n  if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\n    labelOptions.alignment = {\n      [TOP]: CENTER,\n      [BOTTOM]: CENTER,\n      [LEFT]: RIGHT,\n      [RIGHT]: LEFT\n    }[labelPosition];\n  }\n\n  options.position = position;\n  labelOptions.position = labelPosition;\n  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\n  labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\n  options.type && (options.type = options.type.toLowerCase());\n  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\n  options.valueType && (options.valueType = options.valueType.toLowerCase());\n}\n\nfunction getOptimalAngle(boxes, labelOpt) {\n  var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\n\n  return angle < 45 ? -45 : -90;\n}\n\nfunction updateLabels(ticks, step, func) {\n  ticks.forEach(function (tick, index) {\n    if (tick.getContentContainer()) {\n      if (index % step !== 0) {\n        tick.removeLabel();\n      } else if (func) {\n        func(tick, index);\n      }\n    }\n  });\n}\n\nfunction getZoomBoundValue(optionValue, dataValue) {\n  if (void 0 === optionValue) {\n    return dataValue;\n  } else if (null === optionValue) {\n    return;\n  } else {\n    return optionValue;\n  }\n}\n\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\n  var tickGeneratorOptions = extend({}, options, {\n    endOnTick: true,\n    axisDivisionFactor: axisDivisionFactor,\n    skipCalculationLimits: true,\n    generateExtraTick: true,\n    minTickInterval: minTickInterval\n  });\n  return function (tickInterval, skipTickGeneration, min, max, breaks) {\n    return getTickGenerator(tickGeneratorOptions, _noop, skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({\n      min: min,\n      max: max,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, screenDelta, tickInterval, isDefined(tickInterval), void 0, void 0, void 0, breaks);\n  };\n}\n\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\n  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;\n}\n\nexport var Axis = function (renderSettings) {\n  this._renderer = renderSettings.renderer;\n  this._incidentOccurred = renderSettings.incidentOccurred;\n  this._eventTrigger = renderSettings.eventTrigger;\n  this._stripsGroup = renderSettings.stripsGroup;\n  this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\n  this._labelsAxesGroup = renderSettings.labelsAxesGroup;\n  this._constantLinesGroup = renderSettings.constantLinesGroup;\n  this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\n  this._axesContainerGroup = renderSettings.axesContainerGroup;\n  this._gridContainerGroup = renderSettings.gridGroup;\n  this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\n\n  this._setType(renderSettings.axisType, renderSettings.drawingType);\n\n  this._createAxisGroups();\n\n  this._translator = this._createTranslator();\n  this.isArgumentAxis = renderSettings.isArgumentAxis;\n  this._viewport = {};\n  this._firstDrawing = true;\n  this._initRange = {};\n  this._getTemplate = renderSettings.getTemplate;\n};\nAxis.prototype = {\n  constructor: Axis,\n\n  _drawAxis() {\n    var options = this._options;\n\n    if (!options.visible) {\n      return;\n    }\n\n    this._axisElement = this._createAxisElement();\n\n    this._updateAxisElementPosition();\n\n    this._axisElement.attr({\n      \"stroke-width\": options.width,\n      stroke: options.color,\n      \"stroke-opacity\": options.opacity\n    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);\n  },\n\n  _createPathElement(points, attr, sharpDirection) {\n    return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection);\n  },\n\n  sharp(svgElement) {\n    var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n    return svgElement.sharp(this._getSharpParam(), sharpDirection);\n  },\n\n  customPositionIsAvailable: () => false,\n  getOrthogonalAxis: _noop,\n  getCustomPosition: _noop,\n  getCustomBoundaryPosition: _noop,\n  resolveOverlappingForCustomPositioning: _noop,\n  hasNonBoundaryPosition: () => false,\n  customPositionIsBoundaryOrthogonalAxis: () => false,\n\n  getResolvedBoundaryPosition() {\n    return this.getOptions().position;\n  },\n\n  getAxisSharpDirection() {\n    var position = this.getResolvedBoundaryPosition();\n    return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1;\n  },\n\n  getSharpDirectionByCoords(coords) {\n    var canvas = this._getCanvasStartEnd();\n\n    var maxCoord = Math.max(canvas.start, canvas.end);\n    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1;\n  },\n\n  _getGridLineDrawer: function () {\n    var that = this;\n    return function (tick, gridStyle) {\n      var grid = that._getGridPoints(tick.coords);\n\n      if (grid.points) {\n        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));\n      }\n\n      return null;\n    };\n  },\n  _getGridPoints: function (coords) {\n    var isHorizontal = this._isHorizontal;\n    var tickPositionField = isHorizontal ? \"x\" : \"y\";\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n    var borderOptions = this.borderOptions;\n    var canvasStart = isHorizontal ? LEFT : TOP;\n    var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\n    var axisCanvas = this.getCanvas();\n    var canvas = {\n      left: axisCanvas.left,\n      right: axisCanvas.width - axisCanvas.right,\n      top: axisCanvas.top,\n      bottom: axisCanvas.height - axisCanvas.bottom\n    };\n    var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\n    var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\n    var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\n    var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\n\n    if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\n      return {\n        points: null\n      };\n    }\n\n    return {\n      points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\n    };\n  },\n  _getConstantLinePos: function (parsedValue, canvasStart, canvasEnd) {\n    var value = this._getTranslatedCoord(parsedValue);\n\n    if (!isDefined(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\n      return;\n    }\n\n    return value;\n  },\n  _getConstantLineGraphicAttributes: function (value) {\n    var positionFrom = this._orthogonalPositions.start;\n    var positionTo = this._orthogonalPositions.end;\n    return {\n      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\n    };\n  },\n  _createConstantLine: function (value, attr) {\n    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));\n  },\n  _drawConstantLineLabelText: function (text, x, y, _ref2, group) {\n    var {\n      font: font,\n      cssClass: cssClass\n    } = _ref2;\n    return this._renderer.text(text, x, y).css(patchFontOptions(extend({}, this._options.label.font, font))).attr({\n      align: \"center\",\n      class: cssClass\n    }).append(group);\n  },\n  _drawConstantLineLabels: function (parsedValue, lineLabelOptions, value, group) {\n    var _text;\n\n    var text = lineLabelOptions.text;\n    var options = this._options;\n    var labelOptions = options.label;\n\n    this._checkAlignmentConstantLineLabels(lineLabelOptions);\n\n    text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\n\n    var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\n\n    return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);\n  },\n  _getStripPos: function (startValue, endValue, canvasStart, canvasEnd, range) {\n    var isContinuous = !!(range.minVisible || range.maxVisible);\n    var categories = (range.categories || []).reduce(function (result, cat) {\n      result.push(cat.valueOf());\n      return result;\n    }, []);\n    var start;\n    var end;\n    var swap;\n    var startCategoryIndex;\n    var endCategoryIndex;\n\n    if (!isContinuous) {\n      if (isDefined(startValue) && isDefined(endValue)) {\n        var parsedStartValue = this.parser(startValue);\n        var parsedEndValue = this.parser(endValue);\n        startCategoryIndex = inArray(isDefined(parsedStartValue) ? parsedStartValue.valueOf() : void 0, categories);\n        endCategoryIndex = inArray(isDefined(parsedEndValue) ? parsedEndValue.valueOf() : void 0, categories);\n\n        if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\n          return {\n            from: 0,\n            to: 0,\n            outOfCanvas: true\n          };\n        }\n\n        if (startCategoryIndex > endCategoryIndex) {\n          swap = endValue;\n          endValue = startValue;\n          startValue = swap;\n        }\n      }\n    }\n\n    if (isDefined(startValue)) {\n      startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\n      start = this._getTranslatedCoord(startValue, -1);\n    } else {\n      start = canvasStart;\n    }\n\n    if (isDefined(endValue)) {\n      endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\n      end = this._getTranslatedCoord(endValue, 1);\n    } else {\n      end = canvasEnd;\n    }\n\n    var stripPosition = start < end ? {\n      from: start,\n      to: end\n    } : {\n      from: end,\n      to: start\n    };\n    var visibleArea = this.getVisibleArea();\n\n    if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\n      stripPosition.outOfCanvas = true;\n    }\n\n    return stripPosition;\n  },\n  _getStripGraphicAttributes: function (fromPoint, toPoint) {\n    var x;\n    var y;\n    var width;\n    var height;\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n\n    if (this._isHorizontal) {\n      x = fromPoint;\n      y = _min(positionFrom, positionTo);\n      width = toPoint - fromPoint;\n      height = _abs(positionFrom - positionTo);\n    } else {\n      x = _min(positionFrom, positionTo);\n      y = fromPoint;\n      width = _abs(positionFrom - positionTo);\n      height = _abs(fromPoint - toPoint);\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  _createStrip: function (attrs) {\n    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);\n  },\n  _adjustStripLabels: function () {\n    var that = this;\n\n    this._strips.forEach(function (strip) {\n      if (strip.label) {\n        strip.label.attr(that._getAdjustedStripLabelCoords(strip));\n      }\n    });\n  },\n\n  _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\n    var getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\n\n    this._majorTicks.forEach(function (tick) {\n      if (tick.label) {\n        tick.updateMultilineTextAlignment();\n        tick.label.attr(getContainerAttrs(tick));\n      } else {\n        tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick));\n      }\n    });\n  },\n\n  _adjustLabels: function (offset) {\n    var options = this.getOptions();\n    var positionsAreConsistent = options.position === options.label.position;\n\n    var maxSize = this._majorTicks.reduce(function (size, tick) {\n      if (!tick.getContentContainer()) {\n        return size;\n      }\n\n      var bBox = tick.labelRotationAngle ? rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\n      return {\n        width: _max(size.width || 0, bBox.width),\n        height: _max(size.height || 0, bBox.height),\n        offset: _max(size.offset || 0, tick.labelOffset || 0)\n      };\n    }, {});\n\n    var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\n\n    this._adjustLabelsCoord(offset, maxSize.width);\n\n    return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0);\n  },\n  _getLabelAdjustedCoord: function (tick, offset, maxWidth) {\n    offset = offset || 0;\n    var options = this._options;\n    var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\n    var box = templateBox || rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\n    var textAlign = tick.labelAlignment || options.label.alignment;\n    var isDiscrete = \"discrete\" === this._options.type;\n    var isFlatLabel = tick.labelRotationAngle % 90 === 0;\n    var indentFromAxis = options.label.indentFromAxis;\n    var labelPosition = options.label.position;\n    var axisPosition = this._axisPosition;\n    var labelCoords = tick.labelCoords;\n    var labelX = labelCoords.x;\n    var translateX;\n    var translateY;\n\n    if (this._isHorizontal) {\n      if (labelPosition === BOTTOM) {\n        translateY = axisPosition + indentFromAxis - box.y + offset;\n      } else {\n        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;\n      }\n\n      if (textAlign === RIGHT) {\n        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;\n      } else if (textAlign === LEFT) {\n        translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;\n      } else {\n        translateX = labelX - box.x - box.width / 2;\n      }\n    } else {\n      translateY = labelCoords.y - box.y - box.height / 2;\n\n      if (labelPosition === LEFT) {\n        if (textAlign === LEFT) {\n          translateX = axisPosition - indentFromAxis - maxWidth - box.x;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition - indentFromAxis - box.x - box.width;\n        }\n\n        translateX -= offset;\n      } else {\n        if (textAlign === RIGHT) {\n          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition + indentFromAxis - box.x;\n        }\n\n        translateX += offset;\n      }\n    }\n\n    return {\n      translateX: translateX,\n      translateY: translateY\n    };\n  },\n  _createAxisConstantLineGroups: function () {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    var constantLinesClass = classSelector + \"constant-lines\";\n    var insideGroup = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup1 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup2 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    return {\n      inside: insideGroup,\n      outside1: outsideGroup1,\n      left: outsideGroup1,\n      top: outsideGroup1,\n      outside2: outsideGroup2,\n      right: outsideGroup2,\n      bottom: outsideGroup2,\n      remove: function () {\n        this.inside.remove();\n        this.outside1.remove();\n        this.outside2.remove();\n      },\n      clear: function () {\n        this.inside.clear();\n        this.outside1.clear();\n        this.outside2.clear();\n      }\n    };\n  },\n  _createAxisGroups: function () {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    this._axisGroup = renderer.g().attr({\n      class: classSelector + \"axis\"\n    }).enableLinks();\n    this._axisStripGroup = renderer.g().attr({\n      class: classSelector + \"strips\"\n    });\n    this._axisGridGroup = renderer.g().attr({\n      class: classSelector + \"grid\"\n    });\n    this._axisElementsGroup = renderer.g().attr({\n      class: classSelector + \"elements\"\n    });\n    this._axisLineGroup = renderer.g().attr({\n      class: classSelector + \"line\"\n    }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\n    this._axisTitleGroup = renderer.g().attr({\n      class: classSelector + \"title\"\n    }).append(this._axisGroup);\n    this._axisConstantLineGroups = {\n      above: this._createAxisConstantLineGroups(),\n      under: this._createAxisConstantLineGroups()\n    };\n    this._axisStripLabelGroup = renderer.g().attr({\n      class: classSelector + \"axis-labels\"\n    });\n  },\n  _clearAxisGroups: function () {\n    this._axisGroup.remove();\n\n    this._axisStripGroup.remove();\n\n    this._axisStripLabelGroup.remove();\n\n    this._axisConstantLineGroups.above.remove();\n\n    this._axisConstantLineGroups.under.remove();\n\n    this._axisGridGroup.remove();\n\n    this._axisTitleGroup.clear();\n\n    if (!this._options.label.template || !this.isRendered()) {\n      this._axisElementsGroup.remove();\n\n      this._axisElementsGroup.clear();\n    }\n\n    this._axisLineGroup && this._axisLineGroup.clear();\n    this._axisStripGroup && this._axisStripGroup.clear();\n    this._axisGridGroup && this._axisGridGroup.clear();\n\n    this._axisConstantLineGroups.above.clear();\n\n    this._axisConstantLineGroups.under.clear();\n\n    this._axisStripLabelGroup && this._axisStripLabelGroup.clear();\n  },\n  _getLabelFormatObject: function (value, labelOptions, range, point, tickInterval, ticks) {\n    range = range || this._getViewportRange();\n    var formatObject = {\n      value: value,\n      valueText: _format(value, {\n        labelOptions: labelOptions,\n        ticks: ticks || convertTicksToValues(this._majorTicks),\n        tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\n        dataType: this._options.dataType,\n        logarithmBase: this._options.logarithmBase,\n        type: this._options.type,\n        showTransition: !this._options.marker.visible,\n        point: point\n      }) || \"\",\n      min: range.minVisible,\n      max: range.maxVisible\n    };\n\n    if (point) {\n      formatObject.point = point;\n    }\n\n    return formatObject;\n  },\n  formatLabel: function (value, labelOptions, range, point, tickInterval, ticks) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\n\n    return isFunction(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;\n  },\n  formatHint: function (value, labelOptions, range) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range);\n\n    return isFunction(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0;\n  },\n\n  formatRange(startValue, endValue, interval) {\n    return formatRange(startValue, endValue, interval, this.getOptions());\n  },\n\n  _setTickOffset: function () {\n    var options = this._options;\n    var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\n    this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode);\n  },\n  resetApplyingAnimation: function (isFirstDrawing) {\n    this._resetApplyingAnimation = true;\n\n    if (isFirstDrawing) {\n      this._firstDrawing = true;\n    }\n  },\n\n  isFirstDrawing() {\n    return this._firstDrawing;\n  },\n\n  getMargins: function () {\n    var that = this;\n    var {\n      position: position,\n      offset: offset,\n      customPosition: customPosition,\n      placeholderSize: placeholderSize,\n      grid: grid,\n      tick: tick,\n      crosshairMargin: crosshairMargin\n    } = that._options;\n    var isDefinedCustomPositionOption = isDefined(customPosition);\n    var boundaryPosition = that.getResolvedBoundaryPosition();\n    var canvas = that.getCanvas();\n    var cLeft = canvas.left;\n    var cTop = canvas.top;\n    var cRight = canvas.width - canvas.right;\n    var cBottom = canvas.height - canvas.bottom;\n\n    var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\n\n    var constantLineAboveSeries = that._axisConstantLineGroups.above;\n    var constantLineUnderSeries = that._axisConstantLineGroups.under;\n    var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function (group) {\n      var box = group && group.getBBox();\n\n      if (!box || box.isEmpty) {\n        return box;\n      }\n\n      if (that._isHorizontal) {\n        box.x = cLeft;\n        box.width = cRight - cLeft;\n      } else {\n        box.y = cTop;\n        box.height = cBottom - cTop;\n      }\n\n      return box;\n    }(that._axisTitleGroup));\n    var margins = calculateCanvasMargins(boxes, canvas);\n    margins[position] += crosshairMargin;\n\n    if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\n      margins[boundaryPosition] = 0;\n    }\n\n    if (placeholderSize) {\n      margins[position] = placeholderSize;\n    }\n\n    if (edgeMarginCorrection) {\n      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\n        margins.right = edgeMarginCorrection;\n      }\n\n      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\n        margins.bottom = edgeMarginCorrection;\n      }\n    }\n\n    if (!isDefinedCustomPositionOption && isDefined(offset)) {\n      var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\n      margins[boundaryPosition] -= moveByOffset ? offset : 0;\n    }\n\n    return margins;\n  },\n  validateUnit: function (unit, idError, parameters) {\n    unit = this.parser(unit);\n\n    if (void 0 === unit && idError) {\n      this._incidentOccurred(idError, [parameters]);\n    }\n\n    return unit;\n  },\n  _setType: function (axisType, drawingType) {\n    var axisTypeMethods;\n\n    switch (axisType) {\n      case \"xyAxes\":\n        axisTypeMethods = xyMethods;\n        break;\n\n      case \"polarAxes\":\n        axisTypeMethods = polarMethods;\n    }\n\n    extend(this, axisTypeMethods[drawingType]);\n  },\n  _getSharpParam: function () {\n    return true;\n  },\n  _disposeBreaksGroup: _noop,\n  dispose: function () {\n    [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach(function (g) {\n      g.dispose();\n    });\n    this._strips = this._title = null;\n    this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\n    this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\n    this._axisGroup = this._axisTitleGroup = null;\n    this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\n    this._renderer = this._options = this._textOptions = this._textFontStyles = null;\n    this._translator = null;\n    this._majorTicks = this._minorTicks = null;\n\n    this._disposeBreaksGroup();\n\n    this._templatesRendered && this._templatesRendered.reject();\n  },\n  getOptions: function () {\n    return this._options;\n  },\n  setPane: function (pane) {\n    this.pane = pane;\n    this._options.pane = pane;\n  },\n  setTypes: function (type, axisType, typeSelector) {\n    this._options.type = type || this._options.type;\n    this._options[typeSelector] = axisType || this._options[typeSelector];\n\n    this._updateTranslator();\n  },\n  resetTypes: function (typeSelector) {\n    this._options.type = this._initTypes.type;\n    this._options[typeSelector] = this._initTypes[typeSelector];\n  },\n  getTranslator: function () {\n    return this._translator;\n  },\n  updateOptions: function (options) {\n    var that = this;\n    var labelOpt = options.label;\n    validateAxisOptions(options);\n    that._options = options;\n    options.tick = options.tick || {};\n    options.minorTick = options.minorTick || {};\n    options.grid = options.grid || {};\n    options.minorGrid = options.minorGrid || {};\n    options.title = options.title || {};\n    options.marker = options.marker || {};\n    that._initTypes = {\n      type: options.type,\n      argumentType: options.argumentType,\n      valueType: options.valueType\n    };\n\n    that._setTickOffset();\n\n    that._isHorizontal = options.isHorizontal;\n    that.pane = options.pane;\n    that.name = options.name;\n    that.priority = options.priority;\n    that._hasLabelFormat = \"\" !== labelOpt.format && isDefined(labelOpt.format);\n    that._textOptions = {\n      opacity: labelOpt.opacity,\n      align: \"center\",\n      class: labelOpt.cssClass\n    };\n    that._textFontStyles = patchFontOptions(labelOpt.font);\n\n    if (options.type === constants.logarithmic) {\n      if (options.logarithmBaseError) {\n        that._incidentOccurred(\"E2104\");\n\n        delete options.logarithmBaseError;\n      }\n    }\n\n    that._updateTranslator();\n\n    that._createConstantLines();\n\n    that._strips = (options.strips || []).map(o => createStrip(that, o));\n    that._majorTicks = that._minorTicks = null;\n    that._firstDrawing = true;\n  },\n  calculateInterval: function (value, prevValue) {\n    var options = this._options;\n\n    if (!options || options.type !== constants.logarithmic) {\n      return _abs(value - prevValue);\n    }\n\n    var {\n      allowNegatives: allowNegatives,\n      linearThreshold: linearThreshold\n    } = new Range(this.getTranslator().getBusinessRange());\n    return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold));\n  },\n\n  getCanvasRange() {\n    var translator = this._translator;\n    return {\n      startValue: translator.from(translator.translate(\"canvas_position_start\")),\n      endValue: translator.from(translator.translate(\"canvas_position_end\"))\n    };\n  },\n\n  _processCanvas: function (canvas) {\n    return canvas;\n  },\n  updateCanvas: function (canvas, canvasRedesign) {\n    if (!canvasRedesign) {\n      var positions = this._orthogonalPositions = {\n        start: !this._isHorizontal ? canvas.left : canvas.top,\n        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\n      };\n      positions.center = positions.start + (positions.end - positions.start) / 2;\n    } else {\n      this._orthogonalPositions = null;\n    }\n\n    this._canvas = canvas;\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    this._initAxisPositions();\n  },\n  getCanvas: function () {\n    return this._canvas;\n  },\n\n  getAxisShift() {\n    return this._axisShift || 0;\n  },\n\n  hideTitle: function () {\n    if (this._options.title.text) {\n      this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisTitleGroup.clear();\n    }\n  },\n  getTitle: function () {\n    return this._title;\n  },\n  hideOuterElements: function () {\n    var options = this._options;\n\n    if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\n      this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisElementsGroup.clear();\n\n      callAction(this._outsideConstantLines, \"removeLabel\");\n    }\n  },\n\n  _resolveLogarithmicOptionsForRange(range) {\n    var options = this._options;\n\n    if (options.type === constants.logarithmic) {\n      range.addRange({\n        allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\n      });\n\n      if (!isNaN(options.linearThreshold)) {\n        range.linearThreshold = options.linearThreshold;\n      }\n    }\n  },\n\n  adjustViewport(businessRange) {\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n    var categories = this._seriesData && this._seriesData.categories || [];\n    var wholeRange = this.adjustRange(getVizRangeObject(options.wholeRange));\n    var visualRange = this.getViewport() || {};\n    var result = new Range(businessRange);\n\n    this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\n\n    var minDefined = isDefined(visualRange.startValue);\n    var maxDefined = isDefined(visualRange.endValue);\n\n    if (!isDiscrete) {\n      minDefined = minDefined && (!isDefined(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\n      maxDefined = maxDefined && (!isDefined(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);\n    }\n\n    var minVisible = minDefined ? visualRange.startValue : result.minVisible;\n    var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\n\n    if (!isDiscrete) {\n      var _wholeRange$startValu, _wholeRange$endValue;\n\n      result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\n      result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max;\n    } else {\n      var categoriesInfo = getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\n      categories = categoriesInfo.categories;\n      result.categories = categories;\n    }\n\n    var adjustedVisualRange = adjustVisualRange({\n      axisType: options.type,\n      dataType: options.dataType,\n      base: options.logarithmBase\n    }, {\n      startValue: minDefined ? visualRange.startValue : void 0,\n      endValue: maxDefined ? visualRange.endValue : void 0,\n      length: visualRange.length\n    }, {\n      categories: categories,\n      min: wholeRange.startValue,\n      max: wholeRange.endValue\n    }, {\n      categories: categories,\n      min: minVisible,\n      max: maxVisible\n    });\n    result.minVisible = adjustedVisualRange.startValue;\n    result.maxVisible = adjustedVisualRange.endValue;\n    !isDefined(result.min) && (result.min = result.minVisible);\n    !isDefined(result.max) && (result.max = result.maxVisible);\n    result.addRange({});\n\n    this._resolveLogarithmicOptionsForRange(result);\n\n    return result;\n  },\n\n  adjustRange(range) {\n    range = range || {};\n    var isDiscrete = this._options.type === constants.discrete;\n    var isLogarithmic = this._options.type === constants.logarithmic;\n    var disabledNegatives = false === this._options.allowNegatives;\n\n    if (isLogarithmic) {\n      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\n      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;\n    }\n\n    if (!isDiscrete && isDefined(range.startValue) && isDefined(range.endValue) && range.startValue > range.endValue) {\n      var tmp = range.endValue;\n      range.endValue = range.startValue;\n      range.startValue = tmp;\n    }\n\n    return range;\n  },\n\n  _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\n    var value = this._options.visualRangeUpdateMode;\n    var translator = this._translator;\n    var range = this._seriesData;\n\n    if (this.isArgumentAxis) {\n      if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\n        if (range.axisType === constants.discrete) {\n          var categories = range.categories;\n          var newCategories = newRange.categories;\n          var visualRange = this.visualRange();\n\n          if (categories && newCategories && categories.length && -1 !== newCategories.map(c => c.valueOf()).join(\",\").indexOf(categories.map(c => c.valueOf()).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\n            value = KEEP;\n          } else {\n            value = RESET;\n          }\n        } else {\n          var minPoint = translator.translate(range.min);\n          var minVisiblePoint = translator.translate(viewport.startValue);\n          var maxPoint = translator.translate(range.max);\n          var maxVisiblePoint = translator.translate(viewport.endValue);\n\n          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = RESET;\n          } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = SHIFT;\n          } else {\n            value = KEEP;\n          }\n        }\n      }\n    } else if (-1 === [KEEP, RESET].indexOf(value)) {\n      if (oppositeValue === KEEP) {\n        value = KEEP;\n      } else {\n        value = RESET;\n      }\n    }\n\n    return value;\n  },\n\n  _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\n    var visualRange = this.visualRange();\n\n    if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\n      return;\n    }\n\n    var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\n\n    var viewport = this.getViewport();\n\n    if (!isDefined(viewport.startValue) && !isDefined(viewport.endValue) && !isDefined(viewport.length)) {\n      visualRangeUpdateMode = RESET;\n    } else {\n      this._prevDataWasEmpty && (visualRangeUpdateMode = KEEP);\n    }\n\n    if (visualRangeUpdateMode === KEEP) {\n      this._setVisualRange([visualRange.startValue, visualRange.endValue]);\n    }\n\n    if (visualRangeUpdateMode === RESET) {\n      this._setVisualRange([null, null]);\n    }\n\n    if (visualRangeUpdateMode === SHIFT) {\n      this._setVisualRange({\n        length: this.getVisualRangeLength()\n      });\n    }\n  },\n\n  getVisualRangeLength(range) {\n    var currentBusinessRange = range || this._translator.getBusinessRange();\n\n    var {\n      type: type\n    } = this._options;\n    var length;\n\n    if (type === constants.logarithmic) {\n      length = adjust(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      length = categoriesInfo.categories.length;\n    } else {\n      length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;\n    }\n\n    return length;\n  },\n\n  getVisualRangeCenter(range, useMerge) {\n    var translator = this.getTranslator();\n    var businessRange = translator.getBusinessRange();\n    var currentBusinessRange = useMerge ? extend(true, {}, businessRange, range || {}) : range || businessRange;\n    var {\n      type: type,\n      logarithmBase: logarithmBase\n    } = this._options;\n    var center;\n\n    if (!isDefined(currentBusinessRange.minVisible) || !isDefined(currentBusinessRange.maxVisible)) {\n      return;\n    }\n\n    if (type === constants.logarithmic) {\n      var {\n        allowNegatives: allowNegatives,\n        linearThreshold: linearThreshold,\n        minVisible: minVisible,\n        maxVisible: maxVisible\n      } = currentBusinessRange;\n      center = raiseTo(adjust(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\n      center = businessRange.categories.indexOf(categoriesInfo.categories[index]);\n    } else {\n      center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2);\n    }\n\n    return center;\n  },\n\n  setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\n    var _that$_seriesData$min, _that$_seriesData$max;\n\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n\n    this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\n\n    this._seriesData = new Range(range);\n\n    var dataIsEmpty = this._seriesData.isEmpty();\n\n    this._prevDataWasEmpty = dataIsEmpty;\n\n    this._seriesData.addRange({\n      categories: options.categories,\n      dataType: options.dataType,\n      axisType: options.type,\n      base: options.logarithmBase,\n      invert: options.inverted\n    });\n\n    this._resolveLogarithmicOptionsForRange(this._seriesData);\n\n    if (!isDiscrete) {\n      if (!isDefined(this._seriesData.min) && !isDefined(this._seriesData.max)) {\n        var visualRange = this.getViewport();\n        visualRange && this._seriesData.addRange({\n          min: visualRange.startValue,\n          max: visualRange.endValue\n        });\n      }\n\n      var synchronizedValue = options.synchronizedValue;\n\n      if (isDefined(synchronizedValue)) {\n        this._seriesData.addRange({\n          min: synchronizedValue,\n          max: synchronizedValue\n        });\n      }\n    }\n\n    this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\n    this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\n\n    if (!this.isArgumentAxis && options.showZero) {\n      this._seriesData.correctValueZeroLevel();\n    }\n\n    this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\n\n    this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n\n  _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {\n      if (cl.options.extendAxis) {\n        var value = cl.getParsedValue();\n        dataRange.addRange({\n          [minValueField]: value,\n          [maxValueField]: value\n        });\n      }\n    });\n  },\n\n  setGroupSeries: function (series) {\n    this._series = series;\n  },\n  getLabelsPosition: function () {\n    var options = this._options;\n    var position = options.position;\n    var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\n    var axisPosition = this._axisPosition;\n    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;\n  },\n  getFormattedValue: function (value, options, point) {\n    var labelOptions = this._options.label;\n    return isDefined(value) ? this.formatLabel(value, extend(true, {}, labelOptions, options), void 0, point) : null;\n  },\n  _getBoundaryTicks: function (majors, viewPort) {\n    var length = majors.length;\n    var options = this._options;\n    var customBounds = options.customBoundTicks;\n    var min = viewPort.minVisible;\n    var max = viewPort.maxVisible;\n    var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\n    var boundaryTicks = [];\n\n    if (options.type === constants.discrete) {\n      if (this._tickOffset && 0 !== majors.length) {\n        boundaryTicks = [majors[0], majors[majors.length - 1]];\n      }\n    } else if (customBounds) {\n      if (addMinMax.min && isDefined(customBounds[0])) {\n        boundaryTicks.push(customBounds[0]);\n      }\n\n      if (addMinMax.max && isDefined(customBounds[1])) {\n        boundaryTicks.push(customBounds[1]);\n      }\n    } else {\n      if (addMinMax.min && (0 === length || majors[0] > min)) {\n        boundaryTicks.push(min);\n      }\n\n      if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\n        boundaryTicks.push(max);\n      }\n    }\n\n    return boundaryTicks;\n  },\n  setPercentLabelFormat: function () {\n    if (!this._hasLabelFormat) {\n      this._options.label.format = \"percent\";\n    }\n  },\n  resetAutoLabelFormat: function () {\n    if (!this._hasLabelFormat) {\n      delete this._options.label.format;\n    }\n  },\n  getMultipleAxesSpacing: function () {\n    return this._options.multipleAxesSpacing || 0;\n  },\n  getTicksValues: function () {\n    return {\n      majorTicksValues: convertTicksToValues(this._majorTicks),\n      minorTicksValues: convertTicksToValues(this._minorTicks)\n    };\n  },\n  estimateTickInterval: function (canvas) {\n    this.updateCanvas(canvas);\n    return this._tickInterval !== this._getTicks(this._getViewportRange(), _noop, true).tickInterval;\n  },\n  setTicks: function (ticks) {\n    var majors = ticks.majorTicks || [];\n    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\n    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\n    this._isSynchronized = true;\n  },\n  _adjustDivisionFactor: function (val) {\n    return val;\n  },\n  _getTicks: function (viewPort, incidentOccurred, skipTickGeneration) {\n    var options = this._options;\n    var customTicks = options.customTicks;\n    var customMinorTicks = options.customMinorTicks;\n    return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\n      min: viewPort.minVisible,\n      max: viewPort.maxVisible,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\n      majors: customTicks,\n      minors: customMinorTicks\n    }, options.minorTickInterval, options.minorTickCount, this._initialBreaks);\n  },\n  _createTicksAndLabelFormat: function (range, incidentOccurred) {\n    var options = this._options;\n\n    var ticks = this._getTicks(range, incidentOccurred, false);\n\n    if (!range.isEmpty() && options.type === constants.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\n      options.label.format = formatHelper.getDateFormatByTicks(ticks.ticks);\n    }\n\n    return ticks;\n  },\n\n  getAggregationInfo(useAllAggregatedPoints, range) {\n    var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\n\n    var options = this._options;\n    var marginOptions = this._marginOptions;\n    var businessRange = new Range(this.getTranslator().getBusinessRange()).addRange(range);\n    var visualRange = this.getViewport();\n    var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\n    var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\n    var ticks = [];\n\n    if (options.type === constants.discrete && options.aggregateByCategory) {\n      return {\n        aggregateByCategory: true\n      };\n    }\n\n    var aggregationInterval = options.aggregationInterval;\n    var aggregationGroupWidth = options.aggregationGroupWidth;\n\n    if (!aggregationGroupWidth && marginOptions) {\n      if (marginOptions.checkInterval) {\n        aggregationGroupWidth = options.axisDivisionFactor;\n      }\n\n      if (marginOptions.sizePointNormalState) {\n        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);\n      }\n    }\n\n    var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\n    var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\n    var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\n\n    if (options.type !== constants.discrete) {\n      var min = useAllAggregatedPoints ? businessRange.min : minVisible;\n      var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\n\n      if (isDefined(min) && isDefined(max)) {\n        var add = getAddFunction({\n          base: options.logarithmBase,\n          axisType: options.type,\n          dataType: options.dataType\n        }, false);\n        var start = min;\n        var end = max;\n\n        if (!useAllAggregatedPoints) {\n          var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n          start = add(min, maxMinDistance, -1);\n          end = add(max, maxMinDistance);\n        }\n\n        start = start < businessRange.min ? businessRange.min : start;\n        end = end > businessRange.max ? businessRange.max : end;\n\n        var breaks = this._getScaleBreaks(options, {\n          minVisible: start,\n          maxVisible: end\n        }, this._series, this.isArgumentAxis);\n\n        var filteredBreaks = this._filterBreaks(breaks, {\n          minVisible: start,\n          maxVisible: end\n        }, options.breakStyle);\n\n        ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks;\n      }\n    }\n\n    this._aggregationInterval = tickInterval;\n    return {\n      interval: tickInterval,\n      ticks: ticks\n    };\n  },\n\n  getTickInterval() {\n    return this._tickInterval;\n  },\n\n  getAggregationInterval() {\n    return this._aggregationInterval;\n  },\n\n  createTicks: function (canvas) {\n    var that = this;\n    var renderer = that._renderer;\n    var options = that._options;\n\n    if (!canvas) {\n      return;\n    }\n\n    that._isSynchronized = false;\n    that.updateCanvas(canvas);\n\n    var range = that._getViewportRange();\n\n    that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\n    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _noop, true).tickInterval;\n\n    var margins = this._calculateValueMargins();\n\n    range.addRange({\n      minVisible: margins.minValue,\n      maxVisible: margins.maxValue,\n      isSpacedMargin: margins.isSpacedMargin\n    });\n\n    var ticks = that._createTicksAndLabelFormat(range);\n\n    var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\n\n    if (options.showCustomBoundaryTicks && boundaryTicks.length) {\n      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\n\n      if (boundaryTicks.length > 1) {\n        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));\n      }\n    } else {\n      that._boundaryTicks = [];\n    }\n\n    var minors = (ticks.minorTicks || []).filter(function (minor) {\n      return !boundaryTicks.some(function (boundary) {\n        return valueOf(boundary) === valueOf(minor);\n      });\n    });\n    that._tickInterval = ticks.tickInterval;\n    that._minorTickInterval = ticks.minorTickInterval;\n    var oldMajorTicks = that._majorTicks || [];\n    var majorTicksByValues = oldMajorTicks.reduce((r, t) => {\n      r[t.value.valueOf()] = t;\n      return r;\n    }, {});\n    var sameType = type(ticks.ticks[0]) === type(oldMajorTicks[0] && oldMajorTicks[0].value);\n\n    var skippedCategory = that._getSkippedCategory(ticks.ticks);\n\n    var majorTicks = ticks.ticks.map(v => {\n      var tick = majorTicksByValues[v.valueOf()];\n\n      if (tick && sameType) {\n        delete majorTicksByValues[v.valueOf()];\n        tick.setSkippedCategory(skippedCategory);\n        return tick;\n      } else {\n        return createMajorTick(that, renderer, skippedCategory)(v);\n      }\n    });\n    that._majorTicks = majorTicks;\n    var oldMinorTicks = that._minorTicks || [];\n    that._minorTicks = minors.map((v, i) => {\n      var minorTick = oldMinorTicks[i];\n\n      if (minorTick) {\n        minorTick.updateValue(v);\n        return minorTick;\n      }\n\n      return createMinorTick(that, renderer)(v);\n    });\n    that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\n\n    that._ticksToRemove.forEach(t => {\n      var _t$label;\n\n      return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle();\n    });\n\n    if (ticks.breaks) {\n      that._seriesData.breaks = ticks.breaks;\n    }\n\n    that._reinitTranslator(that._getViewportRange());\n  },\n  _reinitTranslator: function (range) {\n    var translator = this._translator;\n\n    if (this._isSynchronized) {\n      return;\n    }\n\n    translator.updateBusinessRange(range);\n  },\n\n  _getViewportRange() {\n    return this.adjustViewport(this._seriesData);\n  },\n\n  setMarginOptions: function (options) {\n    this._marginOptions = options;\n  },\n\n  getMarginOptions() {\n    var _this$_marginOptions;\n\n    return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {};\n  },\n\n  _calculateRangeInterval: function (interval) {\n    var isDateTime = \"datetime\" === this._options.dataType;\n    var minArgs = [];\n\n    var addToArgs = function (value) {\n      isDefined(value) && minArgs.push(isDateTime ? dateUtils.dateToMilliseconds(value) : value);\n    };\n\n    addToArgs(this._tickInterval);\n    addToArgs(this._estimatedTickInterval);\n    isDefined(interval) && minArgs.push(interval);\n    addToArgs(this._aggregationInterval);\n    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));\n  },\n\n  _calculateWorkWeekInterval(businessInterval) {\n    var options = this._options;\n\n    if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\n      var workWeek = options.workWeek.length * dateIntervals.day;\n      var weekend = dateIntervals.week - workWeek;\n\n      if (workWeek !== businessInterval && weekend < businessInterval) {\n        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\n        businessInterval -= weekend * weekendsCount;\n      } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\n        businessInterval = dateIntervals.day;\n      }\n    }\n\n    return businessInterval;\n  },\n\n  _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\n    var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\n\n    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));\n  },\n\n  _calculateValueMargins(ticks) {\n    this._resetMargins();\n\n    var margins = this.getMarginOptions();\n    var marginSize = (margins.size || 0) / 2;\n    var options = this._options;\n\n    var dataRange = this._getViewportRange();\n\n    var viewPort = this.getViewport();\n\n    var screenDelta = this._getScreenDelta();\n\n    var isDiscrete = -1 !== (options.type || \"\").indexOf(constants.discrete);\n    var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\n    var translator = this._translator;\n    var minValueMargin = options.minValueMargin;\n    var maxValueMargin = options.maxValueMargin;\n    var minPadding = 0;\n    var maxPadding = 0;\n    var interval = 0;\n    var rangeInterval;\n\n    if (dataRange.stubData || !screenDelta) {\n      return {\n        startPadding: 0,\n        endPadding: 0\n      };\n    }\n\n    if (this.isArgumentAxis && margins.checkInterval) {\n      rangeInterval = this._calculateRangeInterval(dataRange.interval);\n      var pxInterval = translator.getInterval(rangeInterval);\n\n      if (isFinite(pxInterval)) {\n        interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)));\n      } else {\n        rangeInterval = 0;\n      }\n    }\n\n    var minPercentPadding;\n    var maxPercentPadding;\n    var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\n\n    if (valueMarginsEnabled) {\n      if (isDefined(minValueMargin)) {\n        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {\n        minPadding = MIN_BAR_MARGIN;\n      } else {\n        minPadding = Math.max(marginSize, interval);\n        minPadding = Math.min(maxPaddingValue, minPadding);\n      }\n\n      if (isDefined(maxValueMargin)) {\n        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {\n        maxPadding = MIN_BAR_MARGIN;\n      } else {\n        maxPadding = Math.max(marginSize, interval);\n        maxPadding = Math.min(maxPaddingValue, maxPadding);\n      }\n    }\n\n    var percentStick = margins.percentStick && !this.isArgumentAxis;\n\n    if (percentStick) {\n      if (1 === _abs(dataRange.max)) {\n        maxPadding = 0;\n      }\n\n      if (1 === _abs(dataRange.min)) {\n        minPadding = 0;\n      }\n    }\n\n    var canvasStartEnd = this._getCanvasStartEnd();\n\n    var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\n    var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\n\n    if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\n      if (void 0 !== minPercentPadding) {\n        minPadding = screenDeltaWithMargins * minPercentPadding;\n      }\n\n      if (void 0 !== maxPercentPadding) {\n        maxPadding = screenDeltaWithMargins * maxPercentPadding;\n      }\n    }\n\n    var minValue;\n    var maxValue;\n\n    if (options.type !== constants.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\n      var length = ticks.length;\n      var firstTickPosition = translator.translate(ticks[0].value);\n      var lastTickPosition = translator.translate(ticks[length - 1].value);\n      var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\n\n      var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\n\n      var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\n\n      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\n        var commonPadding = maxTickPadding + minTickPadding;\n\n        var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\n\n        if (minTickPadding >= minPadding) {\n          minValue = ticks[0].value;\n        }\n\n        if (maxTickPadding >= maxPadding) {\n          maxValue = ticks[length - 1].value;\n        }\n\n        minPadding = _max(minTickPadding, minPadding) / coeff;\n        maxPadding = _max(maxTickPadding, maxPadding) / coeff;\n      }\n    }\n\n    minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\n    maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\n\n    if (!isDiscrete) {\n      if (this._translator.isInverted()) {\n        var _minValue, _maxValue;\n\n        minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);\n      } else {\n        var _minValue2, _maxValue2;\n\n        minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);\n      }\n    }\n\n    var {\n      correctedMin: correctedMin,\n      correctedMax: correctedMax,\n      start: start,\n      end: end\n    } = this.getCorrectedValuesToZero(minValue, maxValue);\n    minPadding = null !== start && void 0 !== start ? start : minPadding;\n    maxPadding = null !== end && void 0 !== end ? end : maxPadding;\n    return {\n      startPadding: translator.isInverted() ? maxPadding : minPadding,\n      endPadding: translator.isInverted() ? minPadding : maxPadding,\n      minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\n      maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\n      interval: rangeInterval,\n      isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\n    };\n  },\n\n  getCorrectedValuesToZero(minValue, maxValue) {\n    var that = this;\n    var translator = that._translator;\n\n    var canvasStartEnd = that._getCanvasStartEnd();\n\n    var dataRange = that._getViewportRange();\n\n    var screenDelta = that._getScreenDelta();\n\n    var options = that._options;\n    var start;\n    var end;\n    var correctedMin;\n    var correctedMax;\n\n    var correctZeroLevel = (minPoint, maxPoint) => {\n      var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\n\n      var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\n\n      var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\n\n      start = minExpectedPadding / coeff;\n      end = maxExpectedPadding / coeff;\n    };\n\n    if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\n      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\n        correctZeroLevel(translator.translate(0), translator.translate(maxValue));\n        correctedMin = 0;\n      }\n\n      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\n        correctZeroLevel(translator.translate(minValue), translator.translate(0));\n        correctedMax = 0;\n      }\n    }\n\n    return {\n      start: isFinite(start) ? start : null,\n      end: isFinite(end) ? end : null,\n      correctedMin: correctedMin,\n      correctedMax: correctedMax\n    };\n  },\n\n  applyMargins() {\n    if (this._isSynchronized) {\n      return;\n    }\n\n    var margins = this._calculateValueMargins(this._majorTicks);\n\n    var canvas = extend({}, this._canvas, {\n      startPadding: margins.startPadding,\n      endPadding: margins.endPadding\n    });\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    if (isFinite(margins.interval)) {\n      var br = this._translator.getBusinessRange();\n\n      br.addRange({\n        interval: margins.interval\n      });\n\n      this._translator.updateBusinessRange(br);\n    }\n  },\n\n  _resetMargins: function () {\n    this._reinitTranslator(this._getViewportRange());\n\n    if (this._canvas) {\n      this._translator.updateCanvas(this._processCanvas(this._canvas));\n    }\n  },\n\n  _createConstantLines() {\n    var constantLines = (this._options.constantLines || []).map(o => createConstantLine(this, o));\n    this._outsideConstantLines = constantLines.filter(l => \"outside\" === l.labelPosition);\n    this._insideConstantLines = constantLines.filter(l => \"inside\" === l.labelPosition);\n  },\n\n  draw: function (canvas, borderOptions) {\n    var that = this;\n    var options = this._options;\n    that.borderOptions = borderOptions || {\n      visible: false\n    };\n\n    that._resetMargins();\n\n    that.createTicks(canvas);\n    that.applyMargins();\n\n    that._clearAxisGroups();\n\n    initTickCoords(that._majorTicks);\n    initTickCoords(that._minorTicks);\n    initTickCoords(that._boundaryTicks);\n\n    that._axisGroup.append(that._axesContainerGroup);\n\n    that._drawAxis();\n\n    that._drawTitle();\n\n    drawTickMarks(that._majorTicks, options.tick);\n    drawTickMarks(that._minorTicks, options.minorTick);\n    drawTickMarks(that._boundaryTicks, options.tick);\n\n    var drawGridLine = that._getGridLineDrawer();\n\n    drawGrids(that._majorTicks, drawGridLine);\n    drawGrids(that._minorTicks, drawGridLine);\n    callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\n    that._templatesRendered && that._templatesRendered.reject();\n    that._templatesRendered = new Deferred();\n    when.apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {\n      that._templatesRendered.resolve();\n    });\n\n    that._majorTicks.forEach(function (tick) {\n      tick.labelRotationAngle = 0;\n      tick.labelAlignment = void 0;\n      tick.labelOffset = 0;\n    });\n\n    callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\n    callAction(that._strips, \"draw\");\n    that._dateMarkers = that._drawDateMarkers() || [];\n    that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\n    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\n    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\n    that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\n\n    if (that._constantLinesGroup) {\n      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);\n    }\n\n    that._measureTitle();\n\n    measureLabels(that._majorTicks);\n    !options.label.template && that._applyWordWrap();\n    measureLabels(that._outsideConstantLines);\n    measureLabels(that._insideConstantLines);\n    measureLabels(that._strips);\n    measureLabels(that._dateMarkers);\n\n    that._adjustConstantLineLabels(that._insideConstantLines);\n\n    that._adjustStripLabels();\n\n    var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\n\n    if (!that._translator.getBusinessRange().isEmpty()) {\n      that._setLabelsPlacement();\n\n      offset = that._adjustLabels(offset);\n    }\n\n    offset = that._adjustDateMarkers(offset);\n\n    that._adjustTitle(offset);\n  },\n\n  getTemplatesDef() {\n    return this._templatesRendered;\n  },\n\n  setRenderedState(state) {\n    this._drawn = state;\n  },\n\n  isRendered() {\n    return this._drawn;\n  },\n\n  _applyWordWrap() {\n    var convertedTickInterval;\n    var textWidth;\n    var textHeight;\n    var options = this._options;\n    var tickInterval = this._tickInterval;\n\n    if (isDefined(tickInterval)) {\n      convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n    }\n\n    var displayMode = this._validateDisplayMode(options.label.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\n\n    var wordWrapMode = options.label.wordWrap || \"none\";\n    var overflowMode = options.label.textOverflow || \"none\";\n\n    if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\n      var usefulSpace = isDefined(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\n\n      if (this._isHorizontal) {\n        textWidth = convertedTickInterval;\n        textHeight = usefulSpace;\n      } else {\n        textWidth = usefulSpace;\n        textHeight = convertedTickInterval;\n      }\n\n      var correctByWidth = false;\n      var correctByHeight = false;\n\n      if (textWidth) {\n        if (this._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {\n          correctByWidth = true;\n        }\n      }\n\n      if (textHeight) {\n        if (this._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {\n          correctByHeight = true;\n        }\n      }\n\n      if (correctByWidth || correctByHeight) {\n        this._majorTicks.forEach(tick => {\n          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);\n        });\n\n        measureLabels(this._majorTicks);\n      }\n    }\n  },\n\n  _measureTitle: _noop,\n\n  animate() {\n    callAction(this._majorTicks, \"animateLabels\");\n  },\n\n  updateSize(canvas, animate) {\n    var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\n    this.updateCanvas(canvas);\n\n    if (updateTitle) {\n      this._checkTitleOverflow();\n\n      this._measureTitle();\n\n      this._updateTitleCoords();\n    }\n\n    this._reinitTranslator(this._getViewportRange());\n\n    this.applyMargins();\n    var animationEnabled = !this._firstDrawing && animate;\n    var options = this._options;\n    initTickCoords(this._majorTicks);\n    initTickCoords(this._minorTicks);\n    initTickCoords(this._boundaryTicks);\n\n    if (this._resetApplyingAnimation && !this._firstDrawing) {\n      this._resetStartCoordinates();\n    }\n\n    cleanUpInvalidTicks(this._majorTicks);\n    cleanUpInvalidTicks(this._minorTicks);\n    cleanUpInvalidTicks(this._boundaryTicks);\n\n    if (this._axisElement) {\n      this._updateAxisElementPosition();\n    }\n\n    updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\n    updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\n    updateTicksPosition(this._boundaryTicks, options.tick);\n    callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\n\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));\n\n    callAction(this._strips, \"updatePosition\", animationEnabled);\n    updateGridsPosition(this._majorTicks, animationEnabled);\n    updateGridsPosition(this._minorTicks, animationEnabled);\n\n    if (animationEnabled) {\n      callAction(this._ticksToRemove || [], \"fadeOutElements\");\n    }\n\n    this.prepareAnimation();\n    this._ticksToRemove = null;\n\n    if (!this._translator.getBusinessRange().isEmpty()) {\n      this._firstDrawing = false;\n    }\n\n    this._resetApplyingAnimation = false;\n\n    this._updateLabelsPosition();\n  },\n\n  _updateLabelsPosition: _noop,\n\n  prepareAnimation() {\n    var action = \"saveCoords\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n\n  _resetStartCoordinates() {\n    var action = \"resetCoordinates\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n\n  applyClipRects: function (elementsClipID, canvasClipID) {\n    this._axisGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n\n    this._axisStripGroup.attr({\n      \"clip-path\": elementsClipID\n    });\n\n    this._axisElementsGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n  },\n\n  _validateVisualRange(optionValue) {\n    var range = getVizRangeObject(optionValue);\n\n    if (void 0 !== range.startValue) {\n      range.startValue = this.validateUnit(range.startValue);\n    }\n\n    if (void 0 !== range.endValue) {\n      range.endValue = this.validateUnit(range.endValue);\n    }\n\n    return convertVisualRangeObject(range, !_isArray(optionValue));\n  },\n\n  _validateOptions(options) {\n    options.wholeRange = this._validateVisualRange(options.wholeRange);\n    options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\n\n    this._setVisualRange(options._customVisualRange);\n  },\n\n  validate() {\n    var options = this._options;\n    var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\n    var parser = dataType ? getParser(dataType) : function (unit) {\n      return unit;\n    };\n    this.parser = parser;\n    options.dataType = dataType;\n\n    this._validateOptions(options);\n  },\n\n  resetVisualRange(isSilent) {\n    this._seriesData.minVisible = this._seriesData.min;\n    this._seriesData.maxVisible = this._seriesData.max;\n    this.handleZooming([null, null], {\n      start: !!isSilent,\n      end: !!isSilent\n    });\n  },\n\n  _setVisualRange(visualRange, allowPartialUpdate) {\n    var range = this.adjustRange(getVizRangeObject(visualRange));\n\n    if (allowPartialUpdate) {\n      isDefined(range.startValue) && (this._viewport.startValue = range.startValue);\n      isDefined(range.endValue) && (this._viewport.endValue = range.endValue);\n    } else {\n      this._viewport = range;\n    }\n  },\n\n  _applyZooming(visualRange, allowPartialUpdate) {\n    this._resetVisualRangeOption();\n\n    this._setVisualRange(visualRange, allowPartialUpdate);\n\n    var viewPort = this.getViewport();\n    this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\n      minVisible: viewPort.startValue,\n      maxVisible: viewPort.endValue\n    }, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n\n  getZoomStartEventArg(event, actionType) {\n    return {\n      axis: this,\n      range: this.visualRange(),\n      cancel: false,\n      event: event,\n      actionType: actionType\n    };\n  },\n\n  _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\n    var newRange = this.visualRange();\n    return {\n      axis: this,\n      previousRange: previousRange,\n      range: newRange,\n      cancel: false,\n      event: event,\n      actionType: actionType,\n      zoomFactor: zoomFactor,\n      shift: shift,\n      rangeStart: newRange.startValue,\n      rangeEnd: newRange.endValue\n    };\n  },\n\n  getZoomBounds() {\n    var wholeRange = getVizRangeObject(this._options.wholeRange);\n    var range = this.getTranslator().getBusinessRange();\n    var secondPriorityRange = {\n      startValue: getZoomBoundValue(this._initRange.startValue, range.min),\n      endValue: getZoomBoundValue(this._initRange.endValue, range.max)\n    };\n    return {\n      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\n      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\n    };\n  },\n\n  setInitRange() {\n    this._initRange = {};\n\n    if (0 === Object.keys(this._options.wholeRange || {}).length) {\n      this._initRange = this.getZoomBounds();\n    }\n  },\n\n  _resetVisualRangeOption() {\n    this._options._customVisualRange = {};\n  },\n\n  getTemplatesGroups() {\n    var ticks = this._majorTicks;\n\n    if (ticks) {\n      return this._majorTicks.map(tick => tick.templateContainer).filter(item => isDefined(item));\n    } else {\n      return [];\n    }\n  },\n\n  setCustomVisualRange(range) {\n    this._options._customVisualRange = range;\n  },\n\n  visualRange() {\n    var args = arguments;\n    var visualRange;\n\n    if (0 === args.length) {\n      var adjustedRange = this._getAdjustedBusinessRange();\n\n      var startValue = adjustedRange.minVisible;\n      var endValue = adjustedRange.maxVisible;\n\n      if (this._options.type === constants.discrete) {\n        var _startValue, _endValue;\n\n        startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\n        endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\n        return {\n          startValue: startValue,\n          endValue: endValue,\n          categories: getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\n        };\n      }\n\n      return {\n        startValue: startValue,\n        endValue: endValue\n      };\n    } else if (_isArray(args[0])) {\n      visualRange = args[0];\n    } else if (isPlainObject(args[0])) {\n      visualRange = extend({}, args[0]);\n    } else {\n      visualRange = [args[0], args[1]];\n    }\n\n    var zoomResults = this.handleZooming(visualRange, args[1]);\n\n    if (!zoomResults.isPrevented) {\n      this._visualRange(this, zoomResults);\n    }\n  },\n\n  handleZooming(visualRange, preventEvents, domEvent, action) {\n    preventEvents = preventEvents || {};\n\n    if (isDefined(visualRange)) {\n      visualRange = this._validateVisualRange(visualRange);\n      visualRange.action = action;\n    }\n\n    var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\n    var previousRange = zoomStartEvent.range;\n    !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\n    var zoomResults = {\n      isPrevented: zoomStartEvent.cancel,\n      skipEventRising: preventEvents.skipEventRising,\n      range: visualRange || zoomStartEvent.range\n    };\n\n    if (!zoomStartEvent.cancel) {\n      isDefined(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\n\n      if (!isDefined(this._storedZoomEndParams)) {\n        this._storedZoomEndParams = {\n          startRange: previousRange,\n          type: this.getOptions().type\n        };\n      }\n\n      this._storedZoomEndParams.event = domEvent;\n      this._storedZoomEndParams.action = action;\n      this._storedZoomEndParams.prevent = !!preventEvents.end;\n    }\n\n    return zoomResults;\n  },\n\n  handleZoomEnd() {\n    if (isDefined(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\n      var previousRange = this._storedZoomEndParams.startRange;\n      var domEvent = this._storedZoomEndParams.event;\n      var action = this._storedZoomEndParams.action;\n      var previousBusinessRange = {\n        minVisible: previousRange.startValue,\n        maxVisible: previousRange.endValue,\n        categories: previousRange.categories\n      };\n\n      var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\n\n      var shift = typeIsNotChanged ? adjust(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\n      var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\n\n      var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\n\n      zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\n\n      this._eventTrigger(\"zoomEnd\", zoomEndEvent);\n\n      if (zoomEndEvent.cancel) {\n        this._restorePreviousVisualRange(previousRange);\n      }\n\n      this._storedZoomEndParams = null;\n    }\n  },\n\n  _restorePreviousVisualRange(previousRange) {\n    this._storedZoomEndParams = null;\n\n    this._applyZooming(previousRange);\n\n    this._visualRange(this, previousRange);\n  },\n\n  checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\n    var options = this._options;\n    var translator = this._translator;\n    var minZoom = options.minVisualRangeLength;\n    var correctedRange = range;\n    var visualRange;\n    var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\n    var businessRange = translator.getBusinessRange();\n\n    if (range) {\n      visualRange = this.adjustRange(getVizRangeObject(range));\n      visualRange = {\n        minVisible: visualRange.startValue,\n        maxVisible: visualRange.endValue,\n        categories: businessRange.categories\n      };\n    }\n\n    var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\n    var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\n\n    if (isDefined(minZoom) || \"discrete\" === options.type) {\n      minZoom = translator.convert(minZoom);\n\n      if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\n        correctedRange = getVizRangeObject(translator.getRangeByMinZoomValue(minZoom, visualRange));\n        isOvercoming = false;\n      } else {\n        isOvercoming &= minZoom > afterVisualRangeLength;\n      }\n    } else {\n      var canvasLength = this._translator.canvasLength;\n      var fullRange = {\n        minVisible: businessRange.min,\n        maxVisible: businessRange.max,\n        categories: businessRange.categories\n      };\n      isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength;\n    }\n\n    return {\n      stopInteraction: !!isOvercoming,\n      correctedRange: correctedRange\n    };\n  },\n\n  isExtremePosition(isMax) {\n    var extremeDataValue;\n    var seriesData;\n\n    if (\"discrete\" === this._options.type) {\n      seriesData = this._translator.getBusinessRange();\n      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];\n    } else {\n      seriesData = this.getZoomBounds();\n      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;\n    }\n\n    var translator = this.getTranslator();\n    var extremePoint = translator.translate(extremeDataValue);\n    var visualRange = this.visualRange();\n    var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\n    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;\n  },\n\n  getViewport() {\n    return this._viewport;\n  },\n\n  getFullTicks: function () {\n    var majors = this._majorTicks || [];\n\n    if (this._options.type === constants.discrete) {\n      return convertTicksToValues(majors);\n    } else {\n      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {\n        return valueOf(a) - valueOf(b);\n      });\n    }\n  },\n  measureLabels: function (canvas, withIndents) {\n    var that = this;\n    var options = that._options;\n    var widthAxis = options.visible ? options.width : 0;\n    var ticks;\n    var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\n    var tickInterval;\n\n    var viewportRange = that._getViewportRange();\n\n    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\n      return {\n        height: widthAxis,\n        width: widthAxis,\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (that._majorTicks) {\n      ticks = convertTicksToValues(that._majorTicks);\n    } else {\n      that.updateCanvas(canvas);\n      ticks = that._createTicksAndLabelFormat(viewportRange, _noop);\n      tickInterval = ticks.tickInterval;\n      ticks = ticks.ticks;\n    }\n\n    var maxText = ticks.reduce(function (prevLabel, tick, index) {\n      var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\n\n      if (prevLabel.length < label.length) {\n        return label;\n      } else {\n        return prevLabel;\n      }\n    }, that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\n\n    var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\n\n    var box = text.getBBox();\n    text.remove();\n    return {\n      x: box.x,\n      y: box.y,\n      width: box.width + indent,\n      height: box.height + indent\n    };\n  },\n  _setLabelsPlacement: function () {\n    if (!this._options.label.visible) {\n      return;\n    }\n\n    var labelOpt = this._options.label;\n\n    var displayMode = this._validateDisplayMode(labelOpt.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\n\n    var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\n    var behavior = {\n      rotationAngle: labelOpt.rotationAngle,\n      staggeringSpacing: labelOpt.staggeringSpacing\n    };\n    var notRecastStep;\n\n    var boxes = this._majorTicks.map(function (tick) {\n      return tick.labelBBox;\n    });\n\n    var step = this._getStep(boxes);\n\n    switch (displayMode) {\n      case ROTATE:\n        if (ignoreOverlapping) {\n          notRecastStep = true;\n          step = 1;\n        }\n\n        this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\n\n        break;\n\n      case \"stagger\":\n        if (ignoreOverlapping) {\n          step = 2;\n        }\n\n        this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\n\n        break;\n\n      default:\n        this._applyLabelOverlapping(boxes, overlappingMode, step, behavior);\n\n    }\n  },\n  _applyLabelOverlapping: function (boxes, mode, step, behavior) {\n    var labelOpt = this._options.label;\n    var majorTicks = this._majorTicks;\n\n    if (\"none\" === mode || \"ignore\" === mode) {\n      return;\n    }\n\n    if (step > 1 && boxes.some(function (box, index, array) {\n      if (0 === index) {\n        return false;\n      }\n\n      return constants.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);\n    })) {\n      this._applyLabelMode(mode, step, boxes, behavior);\n    }\n\n    this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\n\n    this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment);\n  },\n  _applyLabelMode: function (mode, step, boxes, behavior, notRecastStep) {\n    var majorTicks = this._majorTicks;\n    var labelOpt = this._options.label;\n    var angle = behavior.rotationAngle;\n    var labelHeight;\n    var alignment;\n    var func;\n\n    switch (mode) {\n      case ROTATE:\n        if (!labelOpt.userAlignment) {\n          alignment = angle < 0 ? RIGHT : LEFT;\n\n          if (angle % 90 === 0) {\n            alignment = CENTER;\n          }\n        }\n\n        step = notRecastStep ? step : this._getStep(boxes, angle);\n\n        func = function (tick) {\n          var contentContainer = tick.getContentContainer();\n\n          if (!contentContainer) {\n            return;\n          }\n\n          contentContainer.rotate(angle);\n          tick.labelRotationAngle = angle;\n          alignment && (tick.labelAlignment = alignment);\n        };\n\n        updateLabels(majorTicks, step, func);\n        break;\n\n      case \"stagger\":\n        labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\n\n        func = function (tick, index) {\n          if (index / (step - 1) % 2 !== 0) {\n            tick.labelOffset = labelHeight;\n          }\n        };\n\n        updateLabels(majorTicks, step - 1, func);\n        break;\n\n      case \"auto\":\n      case \"_auto\":\n        if (2 === step) {\n          this._applyLabelMode(\"stagger\", step, boxes, behavior);\n        } else {\n          this._applyLabelMode(ROTATE, step, boxes, {\n            rotationAngle: getOptimalAngle(boxes, labelOpt)\n          });\n        }\n\n        break;\n\n      default:\n        updateLabels(majorTicks, step);\n    }\n  },\n  getMarkerTrackers: _noop,\n  _drawDateMarkers: _noop,\n  _adjustDateMarkers: _noop,\n  coordsIn: _noop,\n  areCoordsOutsideAxis: _noop,\n  _getSkippedCategory: _noop,\n  _initAxisPositions: _noop,\n  _drawTitle: _noop,\n  _updateTitleCoords: _noop,\n  _adjustConstantLineLabels: _noop,\n  _createTranslator: function () {\n    return new Translator2D({}, {}, {});\n  },\n  _updateTranslator: function () {\n    var translator = this._translator;\n    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());\n  },\n  _getTranslatorOptions: function () {\n    var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\n\n    var options = this._options;\n    return {\n      isHorizontal: this._isHorizontal,\n      shiftZeroValue: !this.isArgumentAxis,\n      interval: options.semiDiscreteInterval,\n      firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\n      stick: this._getStick(),\n      breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\n    };\n  },\n\n  getVisibleArea() {\n    var canvas = this._getCanvasStartEnd();\n\n    return [canvas.start, canvas.end].sort((a, b) => a - b);\n  },\n\n  _getCanvasStartEnd: function () {\n    var isHorizontal = this._isHorizontal;\n    var canvas = this._canvas || {};\n\n    var invert = this._translator.getBusinessRange().invert;\n\n    var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\n    invert && coords.reverse();\n    return {\n      start: coords[0],\n      end: coords[1]\n    };\n  },\n  _getScreenDelta: function () {\n    var canvas = this._getCanvasStartEnd();\n\n    var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\n    var breaksLength = breaks.length;\n\n    var screenDelta = _abs(canvas.start - canvas.end);\n\n    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);\n  },\n  _getScaleBreaks: function () {\n    return [];\n  },\n  _filterBreaks: function () {\n    return [];\n  },\n  _adjustTitle: _noop,\n  _checkTitleOverflow: _noop,\n  getSpiderTicks: _noop,\n  setSpiderTicks: _noop,\n  _checkBoundedLabelsOverlapping: _noop,\n  _checkShiftedLabels: _noop,\n  drawScaleBreaks: _noop,\n  _visualRange: _noop,\n  _rotateConstantLine: _noop,\n\n  applyVisualRangeSetter(visualRangeSetter) {\n    this._visualRange = visualRangeSetter;\n  },\n\n  getCategoriesSorter(argCategories) {\n    var sort;\n\n    if (this.isArgumentAxis) {\n      sort = argCategories;\n    } else {\n      var categoriesSortingMethod = this._options.categoriesSortingMethod;\n      sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories;\n    }\n\n    return sort;\n  },\n\n  _getAdjustedBusinessRange() {\n    return this.adjustViewport(this._translator.getBusinessRange());\n  }\n\n};","map":{"version":3,"sources":["/Users/rahulsharma/node_modules/devextreme/esm/viz/axes/base_axis.js"],"names":["smartFormatter","_format","formatRange","patchFontOptions","getVizRangeObject","getLogExt","getLog","raiseToExt","raiseTo","valueOf","rotateBBox","getCategoriesInfo","adjustVisualRange","getAddFunction","convertVisualRangeObject","isDefined","isFunction","isPlainObject","type","constants","extend","inArray","formatHelper","getParser","tickGenerator","Translator2D","Range","tick","adjust","dateUtils","noop","_noop","xyMethods","polarMethods","createConstantLine","createStrip","Deferred","when","calculateCanvasMargins","measureLabels","convertTicksToValues","_math","Math","_abs","abs","_max","max","_min","min","_isArray","Array","isArray","DEFAULT_AXIS_LABEL_SPACING","MAX_GRID_BORDER_ADHENSION","TOP","top","BOTTOM","bottom","LEFT","left","RIGHT","right","CENTER","center","KEEP","SHIFT","RESET","ROTATE","DEFAULT_AXIS_DIVISION_FACTOR","DEFAULT_MINOR_AXIS_DIVISION_FACTOR","SCROLL_THRESHOLD","MIN_BAR_MARGIN","MAX_MARGIN_VALUE","dateIntervals","day","week","getTickGenerator","options","incidentOccurred","skipTickGeneration","rangeIsEmpty","adjustDivisionFactor","_ref","_options$workWeek","allowNegatives","linearThreshold","axisType","dataType","logBase","logarithmBase","axisDivisionFactor","minorAxisDivisionFactor","numberMultipliers","calculateMinors","minorTick","visible","minorGrid","allowDecimals","endOnTick","firstDayOfWeek","workWeek","skipCalculationLimits","generateExtraTick","minTickInterval","createMajorTick","axis","renderer","skippedCategory","getOptions","grid","createMinorTick","createBoundaryTick","isFirst","showCustomBoundaryTicks","callAction","elements","action","actionArgument1","actionArgument2","forEach","e","initTickCoords","ticks","drawTickMarks","drawGrids","drawLine","updateTicksPosition","animate","updateGridsPosition","cleanUpInvalidTicks","i","length","removeInvalidTick","coords","x","y","splice","validateAxisOptions","_labelOptions$minSpac","labelOptions","label","position","defaultPosition","isHorizontal","secondaryPosition","labelPosition","alignment","userAlignment","hoverMode","toLowerCase","minSpacing","argumentType","valueType","getOptimalAngle","boxes","labelOpt","angle","asin","height","PI","updateLabels","step","func","index","getContentContainer","removeLabel","getZoomBoundValue","optionValue","dataValue","configureGenerator","viewPort","screenDelta","tickGeneratorOptions","tickInterval","breaks","isEmpty","v","categories","isSpacedMargin","getConstantLineSharpDirection","coord","axisCanvas","start","end","Axis","renderSettings","_renderer","_incidentOccurred","_eventTrigger","eventTrigger","_stripsGroup","stripsGroup","_stripLabelAxesGroup","stripLabelAxesGroup","_labelsAxesGroup","labelsAxesGroup","_constantLinesGroup","constantLinesGroup","_scaleBreaksGroup","scaleBreaksGroup","_axesContainerGroup","axesContainerGroup","_gridContainerGroup","gridGroup","_axisCssPrefix","widgetClass","axisClass","_setType","drawingType","_createAxisGroups","_translator","_createTranslator","isArgumentAxis","_viewport","_firstDrawing","_initRange","_getTemplate","getTemplate","prototype","constructor","_drawAxis","_options","_axisElement","_createAxisElement","_updateAxisElementPosition","attr","width","stroke","color","opacity","sharp","_getSharpParam","getAxisSharpDirection","append","_axisLineGroup","_createPathElement","points","sharpDirection","path","svgElement","arguments","customPositionIsAvailable","getOrthogonalAxis","getCustomPosition","getCustomBoundaryPosition","resolveOverlappingForCustomPositioning","hasNonBoundaryPosition","customPositionIsBoundaryOrthogonalAxis","getResolvedBoundaryPosition","getSharpDirectionByCoords","canvas","_getCanvasStartEnd","maxCoord","getRadius","_isHorizontal","_getGridLineDrawer","that","gridStyle","_getGridPoints","tickPositionField","orthogonalPositions","_orthogonalPositions","positionFrom","positionTo","borderOptions","canvasStart","canvasEnd","getCanvas","firstBorderLinePosition","lastBorderLinePosition","minDelta","maxDelta","areCoordsOutsideAxis","_getConstantLinePos","parsedValue","value","_getTranslatedCoord","_getConstantLineGraphicAttributes","_createConstantLine","_drawConstantLineLabelText","text","_ref2","group","font","cssClass","css","align","class","_drawConstantLineLabels","lineLabelOptions","_text","_checkAlignmentConstantLineLabels","formatLabel","_getConstantLineLabelsCoords","_getStripPos","startValue","endValue","range","isContinuous","minVisible","maxVisible","reduce","result","cat","push","swap","startCategoryIndex","endCategoryIndex","parsedStartValue","parser","parsedEndValue","from","to","outOfCanvas","validateUnit","stripPosition","visibleArea","getVisibleArea","_getStripGraphicAttributes","fromPoint","toPoint","_createStrip","attrs","rect","_adjustStripLabels","_strips","strip","_getAdjustedStripLabelCoords","_adjustLabelsCoord","offset","maxWidth","checkCanvas","getContainerAttrs","_getLabelAdjustedCoord","labelOffset","_majorTicks","updateMultilineTextAlignment","templateContainer","_adjustLabels","positionsAreConsistent","maxSize","size","bBox","labelRotationAngle","labelBBox","labelCoords","additionalOffset","indentFromAxis","templateBox","getBBox","box","textAlign","labelAlignment","isDiscrete","isFlatLabel","axisPosition","_axisPosition","labelX","translateX","translateY","_createAxisConstantLineGroups","classSelector","constantLinesClass","insideGroup","g","outsideGroup1","outsideGroup2","inside","outside1","outside2","remove","clear","_axisGroup","enableLinks","_axisStripGroup","_axisGridGroup","_axisElementsGroup","linkOn","linkAppend","_axisTitleGroup","_axisConstantLineGroups","above","under","_axisStripLabelGroup","_clearAxisGroups","template","isRendered","_getLabelFormatObject","point","_getViewportRange","formatObject","valueText","_tickInterval","showTransition","marker","customizeText","call","formatHint","customizeHint","interval","_setTickOffset","discreteAxisDivisionMode","_tickOffset","resetApplyingAnimation","isFirstDrawing","_resetApplyingAnimation","getMargins","customPosition","placeholderSize","crosshairMargin","isDefinedCustomPositionOption","boundaryPosition","cLeft","cTop","cRight","cBottom","edgeMarginCorrection","constantLineAboveSeries","constantLineUnderSeries","map","concat","margins","moveByOffset","customPositionIsBoundary","unit","idError","parameters","axisTypeMethods","_disposeBreaksGroup","dispose","_title","_axisBreaksGroup","_textOptions","_textFontStyles","_minorTicks","_templatesRendered","reject","setPane","pane","setTypes","typeSelector","_updateTranslator","resetTypes","_initTypes","getTranslator","updateOptions","title","name","priority","_hasLabelFormat","format","logarithmic","logarithmBaseError","_createConstantLines","strips","o","calculateInterval","prevValue","getBusinessRange","getCanvasRange","translator","translate","_processCanvas","updateCanvas","canvasRedesign","positions","_canvas","_initAxisPositions","getAxisShift","_axisShift","hideTitle","getTitle","hideOuterElements","_outsideConstantLines","_resolveLogarithmicOptionsForRange","addRange","isNaN","adjustViewport","businessRange","discrete","_seriesData","wholeRange","adjustRange","visualRange","getViewport","_addConstantLinesToRange","minDefined","maxDefined","_wholeRange$startValu","_wholeRange$endValue","categoriesInfo","adjustedVisualRange","base","isLogarithmic","disabledNegatives","tmp","_getVisualRangeUpdateMode","viewport","newRange","oppositeValue","visualRangeUpdateMode","indexOf","newCategories","c","join","minPoint","minVisiblePoint","maxPoint","maxVisiblePoint","_handleBusinessRangeChanged","oppositeVisualRangeUpdateMode","axisReinitialized","_lastVisualRangeUpdateMode","_prevDataWasEmpty","_setVisualRange","getVisualRangeLength","currentBusinessRange","getVisualRangeCenter","useMerge","ceil","toValue","setBusinessRange","argCategories","_that$_seriesData$min","_that$_seriesData$max","dataIsEmpty","invert","inverted","synchronizedValue","showZero","correctValueZeroLevel","sortCategories","getCategoriesSorter","userBreaks","_getScaleBreaks","_series","updateBusinessRange","dataRange","minValueField","maxValueField","_insideConstantLines","cl","extendAxis","getParsedValue","setGroupSeries","series","getLabelsPosition","labelShift","_constantLabelOffset","getFormattedValue","_getBoundaryTicks","majors","customBounds","customBoundTicks","addMinMax","_boundaryTicksVisibility","boundaryTicks","setPercentLabelFormat","resetAutoLabelFormat","getMultipleAxesSpacing","multipleAxesSpacing","getTicksValues","majorTicksValues","minorTicksValues","estimateTickInterval","_getTicks","setTicks","majorTicks","_getSkippedCategory","minorTicks","_isSynchronized","_adjustDivisionFactor","val","customTicks","customMinorTicks","bind","_getScreenDelta","overlappingBehavior","forceUserTickInterval","minors","minorTickInterval","minorTickCount","_initialBreaks","_createTicksAndLabelFormat","getDateFormatByTicks","getAggregationInfo","useAllAggregatedPoints","_visualRange$startVal","_visualRange$endValue","_that$_seriesData","marginOptions","_marginOptions","aggregateByCategory","aggregationInterval","aggregationGroupWidth","checkInterval","sizePointNormalState","minInterval","generateTicks","add","maxMinDistance","dateToMilliseconds","filteredBreaks","_filterBreaks","breakStyle","_aggregationInterval","getTickInterval","getAggregationInterval","createTicks","_estimatedTickInterval","_calculateValueMargins","minValue","maxValue","_boundaryTicks","filter","minor","some","boundary","_minorTickInterval","oldMajorTicks","majorTicksByValues","r","t","sameType","setSkippedCategory","oldMinorTicks","updateValue","_ticksToRemove","Object","keys","k","slice","_t$label","removeTitle","_reinitTranslator","setMarginOptions","getMarginOptions","_this$_marginOptions","_calculateRangeInterval","isDateTime","minArgs","addToArgs","_calculateWorkWeekInterval","apply","businessInterval","workdaysOnly","weekend","weekendsCount","_getConvertIntervalCoefficient","intervalInPx","ratioOfCanvasRange","_resetMargins","marginSize","valueMarginsEnabled","minValueMargin","maxValueMargin","minPadding","maxPadding","rangeInterval","stubData","startPadding","endPadding","pxInterval","getInterval","isFinite","minPercentPadding","maxPercentPadding","maxPaddingValue","percentStick","canvasStartEnd","commonMargin","screenDeltaWithMargins","skipViewportExtending","firstTickPosition","lastTickPosition","invertMultiplier","minTickPadding","maxTickPadding","commonPadding","coeff","isInverted","_minValue","_maxValue","_minValue2","_maxValue2","correctedMin","correctedMax","getCorrectedValuesToZero","correctZeroLevel","minExpectedPadding","maxExpectedPadding","applyMargins","br","constantLines","l","draw","_drawTitle","drawGridLine","getTemplateDeferred","done","resolve","_dateMarkers","_drawDateMarkers","_measureTitle","_applyWordWrap","_adjustConstantLineLabels","_setLabelsPlacement","_adjustDateMarkers","_adjustTitle","getTemplatesDef","setRenderedState","state","_drawn","convertedTickInterval","textWidth","textHeight","displayMode","_validateDisplayMode","overlappingMode","_validateOverlappingMode","wordWrapMode","wordWrap","overflowMode","textOverflow","usefulSpace","correctByWidth","correctByHeight","setMaxSize","updateSize","updateTitle","_checkTitleOverflow","_updateTitleCoords","animationEnabled","_resetStartCoordinates","updatePosition","prepareAnimation","_updateLabelsPosition","applyClipRects","elementsClipID","canvasClipID","_validateVisualRange","_validateOptions","_customVisualRange","validate","resetVisualRange","isSilent","handleZooming","allowPartialUpdate","_applyZooming","_resetVisualRangeOption","getZoomStartEventArg","event","actionType","cancel","_getZoomEndEventArg","previousRange","zoomFactor","shift","rangeStart","rangeEnd","getZoomBounds","secondPriorityRange","setInitRange","getTemplatesGroups","item","setCustomVisualRange","args","adjustedRange","_getAdjustedBusinessRange","_startValue","_endValue","zoomResults","isPrevented","_visualRange","preventEvents","domEvent","zoomStartEvent","skipEventRising","_storedZoomEndParams","startRange","prevent","handleZoomEnd","previousBusinessRange","typeIsNotChanged","NaN","round","zoomEndEvent","checkZoomingLowerLimitOvercome","stopInteraction","_restorePreviousVisualRange","minZoom","minVisualRangeLength","correctedRange","isOvercoming","beforeVisualRangeLength","afterVisualRangeLength","convert","getRangeByMinZoomValue","canvasLength","fullRange","isExtremePosition","isMax","extremeDataValue","seriesData","extremePoint","visualRangePoint","getFullTicks","sort","a","b","withIndents","widthAxis","indent","viewportRange","maxText","prevLabel","root","ignoreOverlapping","behavior","rotationAngle","staggeringSpacing","notRecastStep","_getStep","_applyLabelMode","_applyLabelOverlapping","mode","array","areLabelsOverlap","_checkBoundedLabelsOverlapping","_checkShiftedLabels","labelHeight","contentContainer","rotate","_getMaxLabelHeight","getMarkerTrackers","coordsIn","update","_getTranslatorOptions","_options$workWeek2","_options$breakStyle$w","_options$breakStyle","shiftZeroValue","semiDiscreteInterval","stick","_getStick","breaksSize","reverse","breaksLength","cumulativeWidth","getSpiderTicks","setSpiderTicks","drawScaleBreaks","_rotateConstantLine","applyVisualRangeSetter","visualRangeSetter","categoriesSortingMethod"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SACIA,cAAc,IAAIC,OADtB,EAEIC,WAFJ,QAGO,mBAHP;AAIA,SACIC,gBADJ,EAEIC,iBAFJ,EAGIC,SAAS,IAAIC,MAHjB,EAIIC,UAAU,IAAIC,OAJlB,EAKIC,OALJ,EAMIC,UANJ,EAOIC,iBAPJ,EAQIC,iBARJ,EASIC,cATJ,EAUIC,wBAVJ,QAWO,eAXP;AAYA,SACIC,SADJ,EAEIC,UAFJ,EAGIC,aAHJ,EAIIC,IAJJ,QAKO,uBALP;AAMA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,SACIC,MADJ,QAEO,yBAFP;AAGA,SACIC,OADJ,QAEO,wBAFP;AAGA,OAAOC,YAAP,MAAyB,qBAAzB;AACA,SACIC,SADJ,QAEO,2BAFP;AAGA,SACIC,aADJ,QAEO,kBAFP;AAGA,SACIC,YADJ,QAEO,6BAFP;AAGA,SACIC,KADJ,QAEO,sBAFP;AAGA,SACIC,IADJ,QAEO,QAFP;AAGA,SACIC,MADJ,QAEO,uBAFP;AAGA,OAAOC,SAAP,MAAsB,uBAAtB;AACA,SACIC,IAAI,IAAIC,KADZ,QAEO,yBAFP;AAGA,OAAOC,SAAP,MAAsB,WAAtB;AACA,OAAO,KAAKC,YAAZ,MAA8B,cAA9B;AACA,OAAOC,kBAAP,MAA+B,iBAA/B;AACA,OAAOC,WAAP,MAAwB,SAAxB;AACA,SACIC,QADJ,EAEIC,IAFJ,QAGO,2BAHP;AAIA,SACIC,sBADJ,EAEIC,aAFJ,QAGO,cAHP;AAIA,IAAIC,oBAAoB,GAAGrB,SAAS,CAACqB,oBAArC;AACA,IAAIC,KAAK,GAAGC,IAAZ;AACA,IAAIC,IAAI,GAAGF,KAAK,CAACG,GAAjB;AACA,IAAIC,IAAI,GAAGJ,KAAK,CAACK,GAAjB;AACA,IAAIC,IAAI,GAAGN,KAAK,CAACO,GAAjB;AACA,IAAIC,QAAQ,GAAGC,KAAK,CAACC,OAArB;AACA,IAAIC,0BAA0B,GAAG,CAAjC;AACA,IAAIC,yBAAyB,GAAG,CAAhC;AACA,IAAIC,GAAG,GAAGnC,SAAS,CAACoC,GAApB;AACA,IAAIC,MAAM,GAAGrC,SAAS,CAACsC,MAAvB;AACA,IAAIC,IAAI,GAAGvC,SAAS,CAACwC,IAArB;AACA,IAAIC,KAAK,GAAGzC,SAAS,CAAC0C,KAAtB;AACA,IAAIC,MAAM,GAAG3C,SAAS,CAAC4C,MAAvB;AACA,IAAIC,IAAI,GAAG,MAAX;AACA,IAAIC,KAAK,GAAG,OAAZ;AACA,IAAIC,KAAK,GAAG,OAAZ;AACA,IAAIC,MAAM,GAAG,QAAb;AACA,IAAIC,4BAA4B,GAAG,EAAnC;AACA,IAAIC,kCAAkC,GAAG,EAAzC;AACA,IAAIC,gBAAgB,GAAG,CAAvB;AACA,IAAIC,cAAc,GAAG,CAArB;AACA,IAAIC,gBAAgB,GAAG,EAAvB;AACA,IAAIC,aAAa,GAAG;AAChBC,EAAAA,GAAG,EAAE,KADW;AAEhBC,EAAAA,IAAI,EAAE;AAFU,CAApB;;AAKA,SAASC,gBAAT,CAA0BC,OAA1B,EAAmCC,gBAAnC,EAAqDC,kBAArD,EAAyEC,YAAzE,EAAuFC,oBAAvF,EAA6GC,IAA7G,EAAmH;AAC/G,MAAIC,iBAAJ;;AACA,MAAI;AACAC,IAAAA,cAAc,EAAEA,cADhB;AAEAC,IAAAA,eAAe,EAAEA;AAFjB,MAGAH,IAHJ;AAIA,SAAO1D,aAAa,CAAC;AACjB8D,IAAAA,QAAQ,EAAET,OAAO,CAAC3D,IADD;AAEjBqE,IAAAA,QAAQ,EAAEV,OAAO,CAACU,QAFD;AAGjBC,IAAAA,OAAO,EAAEX,OAAO,CAACY,aAHA;AAIjBL,IAAAA,cAAc,EAAEA,cAJC;AAKjBC,IAAAA,eAAe,EAAEA,eALA;AAMjBK,IAAAA,kBAAkB,EAAET,oBAAoB,CAACJ,OAAO,CAACa,kBAAR,IAA8BtB,4BAA/B,CANvB;AAOjBuB,IAAAA,uBAAuB,EAAEV,oBAAoB,CAACJ,OAAO,CAACc,uBAAR,IAAmCtB,kCAApC,CAP5B;AAQjBuB,IAAAA,iBAAiB,EAAEf,OAAO,CAACe,iBARV;AASjBC,IAAAA,eAAe,EAAEhB,OAAO,CAACiB,SAAR,CAAkBC,OAAlB,IAA6BlB,OAAO,CAACmB,SAAR,CAAkBD,OAA/C,IAA0DlB,OAAO,CAACgB,eATlE;AAUjBI,IAAAA,aAAa,EAAEpB,OAAO,CAACoB,aAVN;AAWjBC,IAAAA,SAAS,EAAErB,OAAO,CAACqB,SAXF;AAYjBpB,IAAAA,gBAAgB,EAAEA,gBAZD;AAajBqB,IAAAA,cAAc,EAAE,UAAUhB,iBAAiB,GAAGN,OAAO,CAACuB,QAAtC,KAAmD,KAAK,CAAL,KAAWjB,iBAA9D,GAAkF,KAAK,CAAvF,GAA2FA,iBAAiB,CAAC,CAAD,CAb3G;AAcjBJ,IAAAA,kBAAkB,EAAEA,kBAdH;AAejBsB,IAAAA,qBAAqB,EAAExB,OAAO,CAACwB,qBAfd;AAgBjBC,IAAAA,iBAAiB,EAAEzB,OAAO,CAACyB,iBAhBV;AAiBjBC,IAAAA,eAAe,EAAE1B,OAAO,CAAC0B,eAjBR;AAkBjBvB,IAAAA,YAAY,EAAEA;AAlBG,GAAD,CAApB;AAoBH;;AAED,SAASwB,eAAT,CAAyBC,IAAzB,EAA+BC,QAA/B,EAAyCC,eAAzC,EAA0D;AACtD,MAAI9B,OAAO,GAAG4B,IAAI,CAACG,UAAL,EAAd;AACA,SAAOjF,IAAI,CAAC8E,IAAD,EAAOC,QAAP,EAAiB7B,OAAO,CAAClD,IAAzB,EAA+BkD,OAAO,CAACgC,IAAvC,EAA6CF,eAA7C,EAA8D,KAA9D,CAAX;AACH;;AAED,SAASG,eAAT,CAAyBL,IAAzB,EAA+BC,QAA/B,EAAyC;AACrC,MAAI7B,OAAO,GAAG4B,IAAI,CAACG,UAAL,EAAd;AACA,SAAOjF,IAAI,CAAC8E,IAAD,EAAOC,QAAP,EAAiB7B,OAAO,CAACiB,SAAzB,EAAoCjB,OAAO,CAACmB,SAA5C,CAAX;AACH;;AAED,SAASe,kBAAT,CAA4BN,IAA5B,EAAkCC,QAAlC,EAA4CM,OAA5C,EAAqD;AACjD,MAAInC,OAAO,GAAG4B,IAAI,CAACG,UAAL,EAAd;AACA,SAAOjF,IAAI,CAAC8E,IAAD,EAAOC,QAAP,EAAiBtF,MAAM,CAAC,EAAD,EAAKyD,OAAO,CAAClD,IAAb,EAAmB;AACjDoE,IAAAA,OAAO,EAAElB,OAAO,CAACoC;AADgC,GAAnB,CAAvB,EAEPpC,OAAO,CAACgC,IAFD,EAEO,KAAK,CAFZ,EAEe,KAFf,EAEsBG,OAAO,GAAG,CAAC,CAAJ,GAAQ,CAFrC,CAAX;AAGH;;AAED,SAASE,UAAT,CAAoBC,QAApB,EAA8BC,MAA9B,EAAsCC,eAAtC,EAAuDC,eAAvD,EAAwE;AACpE,GAACH,QAAQ,IAAI,EAAb,EAAiBI,OAAjB,CAAyBC,CAAC,IAAIA,CAAC,CAACJ,MAAD,CAAD,CAAUC,eAAV,EAA2BC,eAA3B,CAA9B;AACH;;AAED,SAASG,cAAT,CAAwBC,KAAxB,EAA+B;AAC3BR,EAAAA,UAAU,CAACQ,KAAD,EAAQ,YAAR,CAAV;AACH;;AAED,SAASC,aAAT,CAAuBD,KAAvB,EAA8B7C,OAA9B,EAAuC;AACnCqC,EAAAA,UAAU,CAACQ,KAAD,EAAQ,UAAR,EAAoB7C,OAApB,CAAV;AACH;;AAED,SAAS+C,SAAT,CAAmBF,KAAnB,EAA0BG,QAA1B,EAAoC;AAChCX,EAAAA,UAAU,CAACQ,KAAD,EAAQ,UAAR,EAAoBG,QAApB,CAAV;AACH;;AAED,SAASC,mBAAT,CAA6BJ,KAA7B,EAAoC7C,OAApC,EAA6CkD,OAA7C,EAAsD;AAClDb,EAAAA,UAAU,CAACQ,KAAD,EAAQ,oBAAR,EAA8B7C,OAA9B,EAAuCkD,OAAvC,CAAV;AACH;;AAED,SAASC,mBAAT,CAA6BN,KAA7B,EAAoCK,OAApC,EAA6C;AACzCb,EAAAA,UAAU,CAACQ,KAAD,EAAQ,oBAAR,EAA8BK,OAA9B,CAAV;AACH;;AAED,SAASE,mBAAT,CAA6BP,KAA7B,EAAoC;AAChC,MAAIQ,CAAC,GAAGR,KAAK,CAACS,MAAN,GAAe,CAAvB;;AACA,OAAKD,CAAL,EAAQA,CAAC,IAAI,CAAb,EAAgBA,CAAC,EAAjB,EAAqB;AACjB,QAAI,CAACE,iBAAiB,CAACV,KAAD,EAAQQ,CAAR,CAAtB,EAAkC;AAC9B;AACH;AACJ;;AACD,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGR,KAAK,CAACS,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;AAC/B,QAAIE,iBAAiB,CAACV,KAAD,EAAQQ,CAAR,CAArB,EAAiC;AAC7BA,MAAAA,CAAC;AACJ,KAFD,MAEO;AACH;AACH;AACJ;AACJ;;AAED,SAASE,iBAAT,CAA2BV,KAA3B,EAAkCQ,CAAlC,EAAqC;AACjC,MAAI,SAASR,KAAK,CAACQ,CAAD,CAAL,CAASG,MAAT,CAAgBC,CAAzB,IAA8B,SAASZ,KAAK,CAACQ,CAAD,CAAL,CAASG,MAAT,CAAgBE,CAA3D,EAA8D;AAC1Db,IAAAA,KAAK,CAACc,MAAN,CAAaN,CAAb,EAAgB,CAAhB;AACA,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AAED,SAASO,mBAAT,CAA6B5D,OAA7B,EAAsC;AAClC,MAAI6D,qBAAJ;;AACA,MAAIC,YAAY,GAAG9D,OAAO,CAAC+D,KAA3B;AACA,MAAIC,QAAQ,GAAGhE,OAAO,CAACgE,QAAvB;AACA,MAAIC,eAAe,GAAGjE,OAAO,CAACkE,YAAR,GAAuBvF,MAAvB,GAAgCE,IAAtD;AACA,MAAIsF,iBAAiB,GAAGnE,OAAO,CAACkE,YAAR,GAAuBzF,GAAvB,GAA6BM,KAArD;AACA,MAAIqF,aAAa,GAAGN,YAAY,CAACE,QAAjC;;AACA,MAAIA,QAAQ,KAAKC,eAAb,IAAgCD,QAAQ,KAAKG,iBAAjD,EAAoE;AAChEH,IAAAA,QAAQ,GAAGC,eAAX;AACH;;AACD,MAAI,CAACG,aAAD,IAAkB,cAAcA,aAApC,EAAmD;AAC/CA,IAAAA,aAAa,GAAGJ,QAAhB;AACH,GAFD,MAEO,IAAI,aAAaI,aAAjB,EAAgC;AACnCA,IAAAA,aAAa,GAAG;AACZ,OAAC3F,GAAD,GAAOE,MADK;AAEZ,OAACA,MAAD,GAAUF,GAFE;AAGZ,OAACI,IAAD,GAAQE,KAHI;AAIZ,OAACA,KAAD,GAASF;AAJG,MAKbmF,QALa,CAAhB;AAMH;;AACD,MAAII,aAAa,KAAKH,eAAlB,IAAqCG,aAAa,KAAKD,iBAA3D,EAA8E;AAC1EC,IAAAA,aAAa,GAAGJ,QAAhB;AACH;;AACD,MAAIF,YAAY,CAACO,SAAb,KAA2BpF,MAA3B,IAAqC,CAAC6E,YAAY,CAACQ,aAAvD,EAAsE;AAClER,IAAAA,YAAY,CAACO,SAAb,GAAyB;AACrB,OAAC5F,GAAD,GAAOQ,MADc;AAErB,OAACN,MAAD,GAAUM,MAFW;AAGrB,OAACJ,IAAD,GAAQE,KAHa;AAIrB,OAACA,KAAD,GAASF;AAJY,MAKtBuF,aALsB,CAAzB;AAMH;;AACDpE,EAAAA,OAAO,CAACgE,QAAR,GAAmBA,QAAnB;AACAF,EAAAA,YAAY,CAACE,QAAb,GAAwBI,aAAxB;AACApE,EAAAA,OAAO,CAACuE,SAAR,GAAoBvE,OAAO,CAACuE,SAAR,GAAoBvE,OAAO,CAACuE,SAAR,CAAkBC,WAAlB,EAApB,GAAsD,MAA1E;AACAV,EAAAA,YAAY,CAACW,UAAb,GAA0B,UAAUZ,qBAAqB,GAAGC,YAAY,CAACW,UAA/C,KAA8D,KAAK,CAAL,KAAWZ,qBAAzE,GAAiGA,qBAAjG,GAAyHtF,0BAAnJ;AACAyB,EAAAA,OAAO,CAAC3D,IAAR,KAAiB2D,OAAO,CAAC3D,IAAR,GAAe2D,OAAO,CAAC3D,IAAR,CAAamI,WAAb,EAAhC;AACAxE,EAAAA,OAAO,CAAC0E,YAAR,KAAyB1E,OAAO,CAAC0E,YAAR,GAAuB1E,OAAO,CAAC0E,YAAR,CAAqBF,WAArB,EAAhD;AACAxE,EAAAA,OAAO,CAAC2E,SAAR,KAAsB3E,OAAO,CAAC2E,SAAR,GAAoB3E,OAAO,CAAC2E,SAAR,CAAkBH,WAAlB,EAA1C;AACH;;AAED,SAASI,eAAT,CAAyBC,KAAzB,EAAgCC,QAAhC,EAA0C;AACtC,MAAIC,KAAK,GAAG,MAAMnH,KAAK,CAACoH,IAAN,CAAW,CAACH,KAAK,CAAC,CAAD,CAAL,CAASI,MAAT,GAAkBH,QAAQ,CAACL,UAA5B,KAA2CI,KAAK,CAAC,CAAD,CAAL,CAASpB,CAAT,GAAaoB,KAAK,CAAC,CAAD,CAAL,CAASpB,CAAjE,CAAX,CAAN,GAAwF7F,KAAK,CAACsH,EAA1G;;AACA,SAAOH,KAAK,GAAG,EAAR,GAAa,CAAC,EAAd,GAAmB,CAAC,EAA3B;AACH;;AAED,SAASI,YAAT,CAAsBtC,KAAtB,EAA6BuC,IAA7B,EAAmCC,IAAnC,EAAyC;AACrCxC,EAAAA,KAAK,CAACH,OAAN,CAAe,UAAS5F,IAAT,EAAewI,KAAf,EAAsB;AACjC,QAAIxI,IAAI,CAACyI,mBAAL,EAAJ,EAAgC;AAC5B,UAAID,KAAK,GAAGF,IAAR,KAAiB,CAArB,EAAwB;AACpBtI,QAAAA,IAAI,CAAC0I,WAAL;AACH,OAFD,MAEO,IAAIH,IAAJ,EAAU;AACbA,QAAAA,IAAI,CAACvI,IAAD,EAAOwI,KAAP,CAAJ;AACH;AACJ;AACJ,GARD;AASH;;AAED,SAASG,iBAAT,CAA2BC,WAA3B,EAAwCC,SAAxC,EAAmD;AAC/C,MAAI,KAAK,CAAL,KAAWD,WAAf,EAA4B;AACxB,WAAOC,SAAP;AACH,GAFD,MAEO,IAAI,SAASD,WAAb,EAA0B;AAC7B;AACH,GAFM,MAEA;AACH,WAAOA,WAAP;AACH;AACJ;;AAED,SAASE,kBAAT,CAA4B5F,OAA5B,EAAqCa,kBAArC,EAAyDgF,QAAzD,EAAmEC,WAAnE,EAAgFpE,eAAhF,EAAiG;AAC7F,MAAIqE,oBAAoB,GAAGxJ,MAAM,CAAC,EAAD,EAAKyD,OAAL,EAAc;AAC3CqB,IAAAA,SAAS,EAAE,IADgC;AAE3CR,IAAAA,kBAAkB,EAAEA,kBAFuB;AAG3CW,IAAAA,qBAAqB,EAAE,IAHoB;AAI3CC,IAAAA,iBAAiB,EAAE,IAJwB;AAK3CC,IAAAA,eAAe,EAAEA;AAL0B,GAAd,CAAjC;AAOA,SAAO,UAASsE,YAAT,EAAuB9F,kBAAvB,EAA2C/B,GAA3C,EAAgDF,GAAhD,EAAqDgI,MAArD,EAA6D;AAChE,WAAOlG,gBAAgB,CAACgG,oBAAD,EAAuB7I,KAAvB,EAA8BgD,kBAA9B,EAAkD2F,QAAQ,CAACK,OAAT,EAAlD,EAAsEC,CAAC,IAAIA,CAA3E,EAA8EN,QAA9E,CAAhB,CAAwG;AAC3G1H,MAAAA,GAAG,EAAEA,GADsG;AAE3GF,MAAAA,GAAG,EAAEA,GAFsG;AAG3GmI,MAAAA,UAAU,EAAEP,QAAQ,CAACO,UAHsF;AAI3GC,MAAAA,cAAc,EAAER,QAAQ,CAACQ;AAJkF,KAAxG,EAKJP,WALI,EAKSE,YALT,EAKuB9J,SAAS,CAAC8J,YAAD,CALhC,EAKgD,KAAK,CALrD,EAKwD,KAAK,CAL7D,EAKgE,KAAK,CALrE,EAKwEC,MALxE,CAAP;AAMH,GAPD;AAQH;;AAED,SAASK,6BAAT,CAAuCC,KAAvC,EAA8CC,UAA9C,EAA0D;AACtD,SAAO3I,IAAI,CAACI,GAAL,CAASuI,UAAU,CAACC,KAApB,EAA2BD,UAAU,CAACE,GAAtC,MAA+CH,KAA/C,GAAuD,CAAvD,GAA2D,CAAC,CAAnE;AACH;;AACD,OAAO,IAAII,IAAI,GAAG,UAASC,cAAT,EAAyB;AACvC,OAAKC,SAAL,GAAiBD,cAAc,CAAC/E,QAAhC;AACA,OAAKiF,iBAAL,GAAyBF,cAAc,CAAC3G,gBAAxC;AACA,OAAK8G,aAAL,GAAqBH,cAAc,CAACI,YAApC;AACA,OAAKC,YAAL,GAAoBL,cAAc,CAACM,WAAnC;AACA,OAAKC,oBAAL,GAA4BP,cAAc,CAACQ,mBAA3C;AACA,OAAKC,gBAAL,GAAwBT,cAAc,CAACU,eAAvC;AACA,OAAKC,mBAAL,GAA2BX,cAAc,CAACY,kBAA1C;AACA,OAAKC,iBAAL,GAAyBb,cAAc,CAACc,gBAAxC;AACA,OAAKC,mBAAL,GAA2Bf,cAAc,CAACgB,kBAA1C;AACA,OAAKC,mBAAL,GAA2BjB,cAAc,CAACkB,SAA1C;AACA,OAAKC,cAAL,GAAsBnB,cAAc,CAACoB,WAAf,GAA6B,GAA7B,IAAoCpB,cAAc,CAACqB,SAAf,GAA2BrB,cAAc,CAACqB,SAAf,GAA2B,GAAtD,GAA4D,EAAhG,CAAtB;;AACA,OAAKC,QAAL,CAActB,cAAc,CAACnG,QAA7B,EAAuCmG,cAAc,CAACuB,WAAtD;;AACA,OAAKC,iBAAL;;AACA,OAAKC,WAAL,GAAmB,KAAKC,iBAAL,EAAnB;AACA,OAAKC,cAAL,GAAsB3B,cAAc,CAAC2B,cAArC;AACA,OAAKC,SAAL,GAAiB,EAAjB;AACA,OAAKC,aAAL,GAAqB,IAArB;AACA,OAAKC,UAAL,GAAkB,EAAlB;AACA,OAAKC,YAAL,GAAoB/B,cAAc,CAACgC,WAAnC;AACH,CApBM;AAqBPjC,IAAI,CAACkC,SAAL,GAAiB;AACbC,EAAAA,WAAW,EAAEnC,IADA;;AAEboC,EAAAA,SAAS,GAAG;AACR,QAAI/I,OAAO,GAAG,KAAKgJ,QAAnB;;AACA,QAAI,CAAChJ,OAAO,CAACkB,OAAb,EAAsB;AAClB;AACH;;AACD,SAAK+H,YAAL,GAAoB,KAAKC,kBAAL,EAApB;;AACA,SAAKC,0BAAL;;AACA,SAAKF,YAAL,CAAkBG,IAAlB,CAAuB;AACnB,sBAAgBpJ,OAAO,CAACqJ,KADL;AAEnBC,MAAAA,MAAM,EAAEtJ,OAAO,CAACuJ,KAFG;AAGnB,wBAAkBvJ,OAAO,CAACwJ;AAHP,KAAvB,EAIGC,KAJH,CAIS,KAAKC,cAAL,CAAoB,IAApB,CAJT,EAIoC,KAAKC,qBAAL,EAJpC,EAIkEC,MAJlE,CAIyE,KAAKC,cAJ9E;AAKH,GAdY;;AAebC,EAAAA,kBAAkB,CAACC,MAAD,EAASX,IAAT,EAAeY,cAAf,EAA+B;AAC7C,WAAO,KAAKP,KAAL,CAAW,KAAK5C,SAAL,CAAeoD,IAAf,CAAoBF,MAApB,EAA4B,MAA5B,EAAoCX,IAApC,CAAyCA,IAAzC,CAAX,EAA2DY,cAA3D,CAAP;AACH,GAjBY;;AAkBbP,EAAAA,KAAK,CAACS,UAAD,EAAa;AACd,QAAIF,cAAc,GAAGG,SAAS,CAAC7G,MAAV,GAAmB,CAAnB,IAAwB,KAAK,CAAL,KAAW6G,SAAS,CAAC,CAAD,CAA5C,GAAkDA,SAAS,CAAC,CAAD,CAA3D,GAAiE,CAAtF;AACA,WAAOD,UAAU,CAACT,KAAX,CAAiB,KAAKC,cAAL,EAAjB,EAAwCM,cAAxC,CAAP;AACH,GArBY;;AAsBbI,EAAAA,yBAAyB,EAAE,MAAM,KAtBpB;AAuBbC,EAAAA,iBAAiB,EAAEnN,KAvBN;AAwBboN,EAAAA,iBAAiB,EAAEpN,KAxBN;AAyBbqN,EAAAA,yBAAyB,EAAErN,KAzBd;AA0BbsN,EAAAA,sCAAsC,EAAEtN,KA1B3B;AA2BbuN,EAAAA,sBAAsB,EAAE,MAAM,KA3BjB;AA4BbC,EAAAA,sCAAsC,EAAE,MAAM,KA5BjC;;AA6BbC,EAAAA,2BAA2B,GAAG;AAC1B,WAAO,KAAK5I,UAAL,GAAkBiC,QAAzB;AACH,GA/BY;;AAgCb2F,EAAAA,qBAAqB,GAAG;AACpB,QAAI3F,QAAQ,GAAG,KAAK2G,2BAAL,EAAf;AACA,WAAO,KAAKF,sBAAL,MAAiCzG,QAAQ,KAAKrF,MAAb,IAAuBqF,QAAQ,KAAKjF,KAArE,GAA6E,CAA7E,GAAiF,CAAC,CAAzF;AACH,GAnCY;;AAoCb6L,EAAAA,yBAAyB,CAACpH,MAAD,EAAS;AAC9B,QAAIqH,MAAM,GAAG,KAAKC,kBAAL,EAAb;;AACA,QAAIC,QAAQ,GAAGlN,IAAI,CAACI,GAAL,CAAS4M,MAAM,CAACpE,KAAhB,EAAuBoE,MAAM,CAACnE,GAA9B,CAAf;AACA,WAAO,KAAKsE,SAAL,GAAiB,CAAjB,GAAqBD,QAAQ,KAAKvH,MAAM,CAAC,KAAKyH,aAAL,GAAqB,GAArB,GAA2B,GAA5B,CAAnB,GAAsD,CAAtD,GAA0D,CAAC,CAAvF;AACH,GAxCY;;AAyCbC,EAAAA,kBAAkB,EAAE,YAAW;AAC3B,QAAIC,IAAI,GAAG,IAAX;AACA,WAAO,UAASrO,IAAT,EAAesO,SAAf,EAA0B;AAC7B,UAAIpJ,IAAI,GAAGmJ,IAAI,CAACE,cAAL,CAAoBvO,IAAI,CAAC0G,MAAzB,CAAX;;AACA,UAAIxB,IAAI,CAAC+H,MAAT,EAAiB;AACb,eAAOoB,IAAI,CAACrB,kBAAL,CAAwB9H,IAAI,CAAC+H,MAA7B,EAAqCqB,SAArC,EAAgDD,IAAI,CAACP,yBAAL,CAA+B9N,IAAI,CAAC0G,MAApC,CAAhD,CAAP;AACH;;AACD,aAAO,IAAP;AACH,KAND;AAOH,GAlDY;AAmDb6H,EAAAA,cAAc,EAAE,UAAS7H,MAAT,EAAiB;AAC7B,QAAIU,YAAY,GAAG,KAAK+G,aAAxB;AACA,QAAIK,iBAAiB,GAAGpH,YAAY,GAAG,GAAH,GAAS,GAA7C;AACA,QAAIqH,mBAAmB,GAAG,KAAKC,oBAA/B;AACA,QAAIC,YAAY,GAAGF,mBAAmB,CAAC9E,KAAvC;AACA,QAAIiF,UAAU,GAAGH,mBAAmB,CAAC7E,GAArC;AACA,QAAIiF,aAAa,GAAG,KAAKA,aAAzB;AACA,QAAIC,WAAW,GAAG1H,YAAY,GAAGrF,IAAH,GAAUJ,GAAxC;AACA,QAAIoN,SAAS,GAAG3H,YAAY,GAAGnF,KAAH,GAAWJ,MAAvC;AACA,QAAI6H,UAAU,GAAG,KAAKsF,SAAL,EAAjB;AACA,QAAIjB,MAAM,GAAG;AACT/L,MAAAA,IAAI,EAAE0H,UAAU,CAAC1H,IADR;AAETE,MAAAA,KAAK,EAAEwH,UAAU,CAAC6C,KAAX,GAAmB7C,UAAU,CAACxH,KAF5B;AAGTN,MAAAA,GAAG,EAAE8H,UAAU,CAAC9H,GAHP;AAITE,MAAAA,MAAM,EAAE4H,UAAU,CAACvB,MAAX,GAAoBuB,UAAU,CAAC5H;AAJ9B,KAAb;AAMA,QAAImN,uBAAuB,GAAGJ,aAAa,CAACzK,OAAd,IAAyByK,aAAa,CAACC,WAAD,CAAtC,GAAsDf,MAAM,CAACe,WAAD,CAA5D,GAA4E,KAAK,CAA/G;AACA,QAAII,sBAAsB,GAAGL,aAAa,CAACzK,OAAd,IAAyByK,aAAa,CAACE,SAAD,CAAtC,GAAoDhB,MAAM,CAACgB,SAAD,CAA1D,GAAwE,KAAK,CAA1G;AACA,QAAII,QAAQ,GAAGzN,yBAAyB,GAAGuN,uBAA3C;AACA,QAAIG,QAAQ,GAAGF,sBAAsB,GAAGxN,yBAAxC;;AACA,QAAI,KAAK2N,oBAAL,CAA0B3I,MAA1B,KAAqC,KAAK,CAAL,KAAWA,MAAM,CAAC8H,iBAAD,CAAtD,IAA6E9H,MAAM,CAAC8H,iBAAD,CAAN,GAA4BW,QAAzG,IAAqHzI,MAAM,CAAC8H,iBAAD,CAAN,GAA4BY,QAArJ,EAA+J;AAC3J,aAAO;AACHnC,QAAAA,MAAM,EAAE;AADL,OAAP;AAGH;;AACD,WAAO;AACHA,MAAAA,MAAM,EAAE7F,YAAY,GAAG,SAASV,MAAM,CAAC8H,iBAAD,CAAf,GAAqC,CAAC9H,MAAM,CAAC8H,iBAAD,CAAP,EAA4BG,YAA5B,EAA0CjI,MAAM,CAAC8H,iBAAD,CAAhD,EAAqEI,UAArE,CAArC,GAAwH,IAA3H,GAAkI,SAASlI,MAAM,CAAC8H,iBAAD,CAAf,GAAqC,CAACG,YAAD,EAAejI,MAAM,CAAC8H,iBAAD,CAArB,EAA0CI,UAA1C,EAAsDlI,MAAM,CAAC8H,iBAAD,CAA5D,CAArC,GAAwH;AAD3Q,KAAP;AAGH,GA/EY;AAgFbc,EAAAA,mBAAmB,EAAE,UAASC,WAAT,EAAsBT,WAAtB,EAAmCC,SAAnC,EAA8C;AAC/D,QAAIS,KAAK,GAAG,KAAKC,mBAAL,CAAyBF,WAAzB,CAAZ;;AACA,QAAI,CAACnQ,SAAS,CAACoQ,KAAD,CAAV,IAAqBA,KAAK,GAAGpO,IAAI,CAAC0N,WAAD,EAAcC,SAAd,CAAjC,IAA6DS,KAAK,GAAGtO,IAAI,CAAC4N,WAAD,EAAcC,SAAd,CAA7E,EAAuG;AACnG;AACH;;AACD,WAAOS,KAAP;AACH,GAtFY;AAuFbE,EAAAA,iCAAiC,EAAE,UAASF,KAAT,EAAgB;AAC/C,QAAIb,YAAY,GAAG,KAAKD,oBAAL,CAA0B/E,KAA7C;AACA,QAAIiF,UAAU,GAAG,KAAKF,oBAAL,CAA0B9E,GAA3C;AACA,WAAO;AACHqD,MAAAA,MAAM,EAAE,KAAKkB,aAAL,GAAqB,CAACqB,KAAD,EAAQb,YAAR,EAAsBa,KAAtB,EAA6BZ,UAA7B,CAArB,GAAgE,CAACD,YAAD,EAAea,KAAf,EAAsBZ,UAAtB,EAAkCY,KAAlC;AADrE,KAAP;AAGH,GA7FY;AA8FbG,EAAAA,mBAAmB,EAAE,UAASH,KAAT,EAAgBlD,IAAhB,EAAsB;AACvC,WAAO,KAAKU,kBAAL,CAAwB,KAAK0C,iCAAL,CAAuCF,KAAvC,EAA8CvC,MAAtE,EAA8EX,IAA9E,EAAoF9C,6BAA6B,CAACgG,KAAD,EAAQ,KAAKxB,kBAAL,EAAR,CAAjH,CAAP;AACH,GAhGY;AAiGb4B,EAAAA,0BAA0B,EAAE,UAASC,IAAT,EAAelJ,CAAf,EAAkBC,CAAlB,EAAqBkJ,KAArB,EAA4BC,KAA5B,EAAmC;AAC3D,QAAI;AACAC,MAAAA,IAAI,EAAEA,IADN;AAEAC,MAAAA,QAAQ,EAAEA;AAFV,QAGAH,KAHJ;AAIA,WAAO,KAAK/F,SAAL,CAAe8F,IAAf,CAAoBA,IAApB,EAA0BlJ,CAA1B,EAA6BC,CAA7B,EAAgCsJ,GAAhC,CAAoC1R,gBAAgB,CAACiB,MAAM,CAAC,EAAD,EAAK,KAAKyM,QAAL,CAAcjF,KAAd,CAAoB+I,IAAzB,EAA+BA,IAA/B,CAAP,CAApD,EAAkG1D,IAAlG,CAAuG;AAC1G6D,MAAAA,KAAK,EAAE,QADmG;AAE1GC,MAAAA,KAAK,EAAEH;AAFmG,KAAvG,EAGJnD,MAHI,CAGGiD,KAHH,CAAP;AAIH,GA1GY;AA2GbM,EAAAA,uBAAuB,EAAE,UAASd,WAAT,EAAsBe,gBAAtB,EAAwCd,KAAxC,EAA+CO,KAA/C,EAAsD;AAC3E,QAAIQ,KAAJ;;AACA,QAAIV,IAAI,GAAGS,gBAAgB,CAACT,IAA5B;AACA,QAAI3M,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIlF,YAAY,GAAG9D,OAAO,CAAC+D,KAA3B;;AACA,SAAKuJ,iCAAL,CAAuCF,gBAAvC;;AACAT,IAAAA,IAAI,GAAG,UAAUU,KAAK,GAAGV,IAAlB,KAA2B,KAAK,CAAL,KAAWU,KAAtC,GAA8CA,KAA9C,GAAsD,KAAKE,WAAL,CAAiBlB,WAAjB,EAA8BvI,YAA9B,CAA7D;;AACA,QAAIN,MAAM,GAAG,KAAKgK,4BAAL,CAAkClB,KAAlC,EAAyCc,gBAAzC,CAAb;;AACA,WAAO,KAAKV,0BAAL,CAAgCC,IAAhC,EAAsCnJ,MAAM,CAACC,CAA7C,EAAgDD,MAAM,CAACE,CAAvD,EAA0D0J,gBAA1D,EAA4EP,KAA5E,CAAP;AACH,GApHY;AAqHbY,EAAAA,YAAY,EAAE,UAASC,UAAT,EAAqBC,QAArB,EAA+B/B,WAA/B,EAA4CC,SAA5C,EAAuD+B,KAAvD,EAA8D;AACxE,QAAIC,YAAY,GAAG,CAAC,EAAED,KAAK,CAACE,UAAN,IAAoBF,KAAK,CAACG,UAA5B,CAApB;AACA,QAAI3H,UAAU,GAAG,CAACwH,KAAK,CAACxH,UAAN,IAAoB,EAArB,EAAyB4H,MAAzB,CAAiC,UAASC,MAAT,EAAiBC,GAAjB,EAAsB;AACpED,MAAAA,MAAM,CAACE,IAAP,CAAYD,GAAG,CAACtS,OAAJ,EAAZ;AACA,aAAOqS,MAAP;AACH,KAHgB,EAGb,EAHa,CAAjB;AAIA,QAAIxH,KAAJ;AACA,QAAIC,GAAJ;AACA,QAAI0H,IAAJ;AACA,QAAIC,kBAAJ;AACA,QAAIC,gBAAJ;;AACA,QAAI,CAACT,YAAL,EAAmB;AACf,UAAI3R,SAAS,CAACwR,UAAD,CAAT,IAAyBxR,SAAS,CAACyR,QAAD,CAAtC,EAAkD;AAC9C,YAAIY,gBAAgB,GAAG,KAAKC,MAAL,CAAYd,UAAZ,CAAvB;AACA,YAAIe,cAAc,GAAG,KAAKD,MAAL,CAAYb,QAAZ,CAArB;AACAU,QAAAA,kBAAkB,GAAG7R,OAAO,CAACN,SAAS,CAACqS,gBAAD,CAAT,GAA8BA,gBAAgB,CAAC3S,OAAjB,EAA9B,GAA2D,KAAK,CAAjE,EAAoEwK,UAApE,CAA5B;AACAkI,QAAAA,gBAAgB,GAAG9R,OAAO,CAACN,SAAS,CAACuS,cAAD,CAAT,GAA4BA,cAAc,CAAC7S,OAAf,EAA5B,GAAuD,KAAK,CAA7D,EAAgEwK,UAAhE,CAA1B;;AACA,YAAI,CAAC,CAAD,KAAOiI,kBAAP,IAA6B,CAAC,CAAD,KAAOC,gBAAxC,EAA0D;AACtD,iBAAO;AACHI,YAAAA,IAAI,EAAE,CADH;AAEHC,YAAAA,EAAE,EAAE,CAFD;AAGHC,YAAAA,WAAW,EAAE;AAHV,WAAP;AAKH;;AACD,YAAIP,kBAAkB,GAAGC,gBAAzB,EAA2C;AACvCF,UAAAA,IAAI,GAAGT,QAAP;AACAA,UAAAA,QAAQ,GAAGD,UAAX;AACAA,UAAAA,UAAU,GAAGU,IAAb;AACH;AACJ;AACJ;;AACD,QAAIlS,SAAS,CAACwR,UAAD,CAAb,EAA2B;AACvBA,MAAAA,UAAU,GAAG,KAAKmB,YAAL,CAAkBnB,UAAlB,EAA8B,OAA9B,EAAuC,OAAvC,CAAb;AACAjH,MAAAA,KAAK,GAAG,KAAK8F,mBAAL,CAAyBmB,UAAzB,EAAqC,CAAC,CAAtC,CAAR;AACH,KAHD,MAGO;AACHjH,MAAAA,KAAK,GAAGmF,WAAR;AACH;;AACD,QAAI1P,SAAS,CAACyR,QAAD,CAAb,EAAyB;AACrBA,MAAAA,QAAQ,GAAG,KAAKkB,YAAL,CAAkBlB,QAAlB,EAA4B,OAA5B,EAAqC,OAArC,CAAX;AACAjH,MAAAA,GAAG,GAAG,KAAK6F,mBAAL,CAAyBoB,QAAzB,EAAmC,CAAnC,CAAN;AACH,KAHD,MAGO;AACHjH,MAAAA,GAAG,GAAGmF,SAAN;AACH;;AACD,QAAIiD,aAAa,GAAGrI,KAAK,GAAGC,GAAR,GAAc;AAC9BgI,MAAAA,IAAI,EAAEjI,KADwB;AAE9BkI,MAAAA,EAAE,EAAEjI;AAF0B,KAAd,GAGhB;AACAgI,MAAAA,IAAI,EAAEhI,GADN;AAEAiI,MAAAA,EAAE,EAAElI;AAFJ,KAHJ;AAOA,QAAIsI,WAAW,GAAG,KAAKC,cAAL,EAAlB;;AACA,QAAIF,aAAa,CAACJ,IAAd,IAAsBK,WAAW,CAAC,CAAD,CAAjC,IAAwCD,aAAa,CAACH,EAAd,IAAoBI,WAAW,CAAC,CAAD,CAAvE,IAA8ED,aAAa,CAACJ,IAAd,IAAsBK,WAAW,CAAC,CAAD,CAAjC,IAAwCD,aAAa,CAACH,EAAd,IAAoBI,WAAW,CAAC,CAAD,CAAzJ,EAA8J;AAC1JD,MAAAA,aAAa,CAACF,WAAd,GAA4B,IAA5B;AACH;;AACD,WAAOE,aAAP;AACH,GA5KY;AA6KbG,EAAAA,0BAA0B,EAAE,UAASC,SAAT,EAAoBC,OAApB,EAA6B;AACrD,QAAI1L,CAAJ;AACA,QAAIC,CAAJ;AACA,QAAI2F,KAAJ;AACA,QAAIpE,MAAJ;AACA,QAAIsG,mBAAmB,GAAG,KAAKC,oBAA/B;AACA,QAAIC,YAAY,GAAGF,mBAAmB,CAAC9E,KAAvC;AACA,QAAIiF,UAAU,GAAGH,mBAAmB,CAAC7E,GAArC;;AACA,QAAI,KAAKuE,aAAT,EAAwB;AACpBxH,MAAAA,CAAC,GAAGyL,SAAJ;AACAxL,MAAAA,CAAC,GAAGxF,IAAI,CAACuN,YAAD,EAAeC,UAAf,CAAR;AACArC,MAAAA,KAAK,GAAG8F,OAAO,GAAGD,SAAlB;AACAjK,MAAAA,MAAM,GAAGnH,IAAI,CAAC2N,YAAY,GAAGC,UAAhB,CAAb;AACH,KALD,MAKO;AACHjI,MAAAA,CAAC,GAAGvF,IAAI,CAACuN,YAAD,EAAeC,UAAf,CAAR;AACAhI,MAAAA,CAAC,GAAGwL,SAAJ;AACA7F,MAAAA,KAAK,GAAGvL,IAAI,CAAC2N,YAAY,GAAGC,UAAhB,CAAZ;AACAzG,MAAAA,MAAM,GAAGnH,IAAI,CAACoR,SAAS,GAAGC,OAAb,CAAb;AACH;;AACD,WAAO;AACH1L,MAAAA,CAAC,EAAEA,CADA;AAEHC,MAAAA,CAAC,EAAEA,CAFA;AAGH2F,MAAAA,KAAK,EAAEA,KAHJ;AAIHpE,MAAAA,MAAM,EAAEA;AAJL,KAAP;AAMH,GAtMY;AAuMbmK,EAAAA,YAAY,EAAE,UAASC,KAAT,EAAgB;AAC1B,WAAO,KAAKxI,SAAL,CAAeyI,IAAf,CAAoBD,KAAK,CAAC5L,CAA1B,EAA6B4L,KAAK,CAAC3L,CAAnC,EAAsC2L,KAAK,CAAChG,KAA5C,EAAmDgG,KAAK,CAACpK,MAAzD,CAAP;AACH,GAzMY;AA0MbsK,EAAAA,kBAAkB,EAAE,YAAW;AAC3B,QAAIpE,IAAI,GAAG,IAAX;;AACA,SAAKqE,OAAL,CAAa9M,OAAb,CAAsB,UAAS+M,KAAT,EAAgB;AAClC,UAAIA,KAAK,CAAC1L,KAAV,EAAiB;AACb0L,QAAAA,KAAK,CAAC1L,KAAN,CAAYqF,IAAZ,CAAiB+B,IAAI,CAACuE,4BAAL,CAAkCD,KAAlC,CAAjB;AACH;AACJ,KAJD;AAKH,GAjNY;;AAkNbE,EAAAA,kBAAkB,CAACC,MAAD,EAASC,QAAT,EAAmBC,WAAnB,EAAgC;AAC9C,QAAIC,iBAAiB,GAAGjT,IAAI,IAAI,KAAKkT,sBAAL,CAA4BlT,IAA5B,EAAkC8S,MAAM,IAAI9S,IAAI,CAACmT,WAAL,IAAoB,CAAxB,CAAxC,EAAoEJ,QAApE,EAA8EC,WAA9E,CAAhC;;AACA,SAAKI,WAAL,CAAiBxN,OAAjB,CAA0B,UAAS5F,IAAT,EAAe;AACrC,UAAIA,IAAI,CAACiH,KAAT,EAAgB;AACZjH,QAAAA,IAAI,CAACqT,4BAAL;AACArT,QAAAA,IAAI,CAACiH,KAAL,CAAWqF,IAAX,CAAgB2G,iBAAiB,CAACjT,IAAD,CAAjC;AACH,OAHD,MAGO;AACHA,QAAAA,IAAI,CAACsT,iBAAL,IAA0BtT,IAAI,CAACsT,iBAAL,CAAuBhH,IAAvB,CAA4B2G,iBAAiB,CAACjT,IAAD,CAA7C,CAA1B;AACH;AACJ,KAPD;AAQH,GA5NY;;AA6NbuT,EAAAA,aAAa,EAAE,UAAST,MAAT,EAAiB;AAC5B,QAAI5P,OAAO,GAAG,KAAK+B,UAAL,EAAd;AACA,QAAIuO,sBAAsB,GAAGtQ,OAAO,CAACgE,QAAR,KAAqBhE,OAAO,CAAC+D,KAAR,CAAcC,QAAhE;;AACA,QAAIuM,OAAO,GAAG,KAAKL,WAAL,CAAiBlC,MAAjB,CAAyB,UAASwC,IAAT,EAAe1T,IAAf,EAAqB;AACxD,UAAI,CAACA,IAAI,CAACyI,mBAAL,EAAL,EAAiC;AAC7B,eAAOiL,IAAP;AACH;;AACD,UAAIC,IAAI,GAAG3T,IAAI,CAAC4T,kBAAL,GAA0B7U,UAAU,CAACiB,IAAI,CAAC6T,SAAN,EAAiB,CAAC7T,IAAI,CAAC8T,WAAL,CAAiBnN,CAAlB,EAAqB3G,IAAI,CAAC8T,WAAL,CAAiBlN,CAAtC,CAAjB,EAA2D,CAAC5G,IAAI,CAAC4T,kBAAjE,CAApC,GAA2H5T,IAAI,CAAC6T,SAA3I;AACA,aAAO;AACHtH,QAAAA,KAAK,EAAErL,IAAI,CAACwS,IAAI,CAACnH,KAAL,IAAc,CAAf,EAAkBoH,IAAI,CAACpH,KAAvB,CADR;AAEHpE,QAAAA,MAAM,EAAEjH,IAAI,CAACwS,IAAI,CAACvL,MAAL,IAAe,CAAhB,EAAmBwL,IAAI,CAACxL,MAAxB,CAFT;AAGH2K,QAAAA,MAAM,EAAE5R,IAAI,CAACwS,IAAI,CAACZ,MAAL,IAAe,CAAhB,EAAmB9S,IAAI,CAACmT,WAAL,IAAoB,CAAvC;AAHT,OAAP;AAKH,KAVa,EAUV,EAVU,CAAd;;AAWA,QAAIY,gBAAgB,GAAGP,sBAAsB,GAAG,KAAKrF,aAAL,GAAqBsF,OAAO,CAACtL,MAA7B,GAAsCsL,OAAO,CAAClH,KAAjD,GAAyD,CAAtG;;AACA,SAAKsG,kBAAL,CAAwBC,MAAxB,EAAgCW,OAAO,CAAClH,KAAxC;;AACA,WAAOuG,MAAM,GAAGiB,gBAAT,IAA6BA,gBAAgB,IAAI,KAAK7H,QAAL,CAAcjF,KAAd,CAAoB+M,cAArE,KAAwFR,sBAAsB,GAAGC,OAAO,CAACX,MAAX,GAAoB,CAAlI,CAAP;AACH,GA9OY;AA+ObI,EAAAA,sBAAsB,EAAE,UAASlT,IAAT,EAAe8S,MAAf,EAAuBC,QAAvB,EAAiC;AACrDD,IAAAA,MAAM,GAAGA,MAAM,IAAI,CAAnB;AACA,QAAI5P,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAI+H,WAAW,GAAGjU,IAAI,CAACsT,iBAAL,IAA0BtT,IAAI,CAACsT,iBAAL,CAAuBY,OAAvB,EAA5C;AACA,QAAIC,GAAG,GAAGF,WAAW,IAAIlV,UAAU,CAACiB,IAAI,CAAC6T,SAAN,EAAiB,CAAC7T,IAAI,CAAC8T,WAAL,CAAiBnN,CAAlB,EAAqB3G,IAAI,CAAC8T,WAAL,CAAiBlN,CAAtC,CAAjB,EAA2D,CAAC5G,IAAI,CAAC4T,kBAAN,IAA4B,CAAvF,CAAnC;AACA,QAAIQ,SAAS,GAAGpU,IAAI,CAACqU,cAAL,IAAuBnR,OAAO,CAAC+D,KAAR,CAAcM,SAArD;AACA,QAAI+M,UAAU,GAAG,eAAe,KAAKpI,QAAL,CAAc3M,IAA9C;AACA,QAAIgV,WAAW,GAAGvU,IAAI,CAAC4T,kBAAL,GAA0B,EAA1B,KAAiC,CAAnD;AACA,QAAII,cAAc,GAAG9Q,OAAO,CAAC+D,KAAR,CAAc+M,cAAnC;AACA,QAAI1M,aAAa,GAAGpE,OAAO,CAAC+D,KAAR,CAAcC,QAAlC;AACA,QAAIsN,YAAY,GAAG,KAAKC,aAAxB;AACA,QAAIX,WAAW,GAAG9T,IAAI,CAAC8T,WAAvB;AACA,QAAIY,MAAM,GAAGZ,WAAW,CAACnN,CAAzB;AACA,QAAIgO,UAAJ;AACA,QAAIC,UAAJ;;AACA,QAAI,KAAKzG,aAAT,EAAwB;AACpB,UAAI7G,aAAa,KAAKzF,MAAtB,EAA8B;AAC1B+S,QAAAA,UAAU,GAAGJ,YAAY,GAAGR,cAAf,GAAgCG,GAAG,CAACvN,CAApC,GAAwCkM,MAArD;AACH,OAFD,MAEO;AACH8B,QAAAA,UAAU,GAAGJ,YAAY,GAAGR,cAAf,IAAiCG,GAAG,CAACvN,CAAJ,GAAQuN,GAAG,CAAChM,MAA7C,IAAuD2K,MAApE;AACH;;AACD,UAAIsB,SAAS,KAAKnS,KAAlB,EAAyB;AACrB0S,QAAAA,UAAU,GAAGL,UAAU,IAAIC,WAAd,GAA4BvU,IAAI,CAAC0G,MAAL,CAAYC,CAAZ,IAAiBwN,GAAG,CAACxN,CAAJ,GAAQwN,GAAG,CAAC5H,KAA7B,CAA5B,GAAkEmI,MAAM,GAAGP,GAAG,CAACxN,CAAb,GAAiBwN,GAAG,CAAC5H,KAApG;AACH,OAFD,MAEO,IAAI6H,SAAS,KAAKrS,IAAlB,EAAwB;AAC3B4S,QAAAA,UAAU,GAAGL,UAAU,IAAIC,WAAd,GAA4BG,MAAM,GAAGP,GAAG,CAACxN,CAAb,IAAkB3G,IAAI,CAAC0G,MAAL,CAAYC,CAAZ,GAAgB+N,MAAlC,CAA5B,GAAwEA,MAAM,GAAGP,GAAG,CAACxN,CAAlG;AACH,OAFM,MAEA;AACHgO,QAAAA,UAAU,GAAGD,MAAM,GAAGP,GAAG,CAACxN,CAAb,GAAiBwN,GAAG,CAAC5H,KAAJ,GAAY,CAA1C;AACH;AACJ,KAbD,MAaO;AACHqI,MAAAA,UAAU,GAAGd,WAAW,CAAClN,CAAZ,GAAgBuN,GAAG,CAACvN,CAApB,GAAwBuN,GAAG,CAAChM,MAAJ,GAAa,CAAlD;;AACA,UAAIb,aAAa,KAAKvF,IAAtB,EAA4B;AACxB,YAAIqS,SAAS,KAAKrS,IAAlB,EAAwB;AACpB4S,UAAAA,UAAU,GAAGH,YAAY,GAAGR,cAAf,GAAgCjB,QAAhC,GAA2CoB,GAAG,CAACxN,CAA5D;AACH,SAFD,MAEO,IAAIyN,SAAS,KAAKjS,MAAlB,EAA0B;AAC7BwS,UAAAA,UAAU,GAAGH,YAAY,GAAGR,cAAf,GAAgCjB,QAAQ,GAAG,CAA3C,GAA+CoB,GAAG,CAACxN,CAAnD,GAAuDwN,GAAG,CAAC5H,KAAJ,GAAY,CAAhF;AACH,SAFM,MAEA;AACHoI,UAAAA,UAAU,GAAGH,YAAY,GAAGR,cAAf,GAAgCG,GAAG,CAACxN,CAApC,GAAwCwN,GAAG,CAAC5H,KAAzD;AACH;;AACDoI,QAAAA,UAAU,IAAI7B,MAAd;AACH,OATD,MASO;AACH,YAAIsB,SAAS,KAAKnS,KAAlB,EAAyB;AACrB0S,UAAAA,UAAU,GAAGH,YAAY,GAAGR,cAAf,GAAgCjB,QAAhC,GAA2CoB,GAAG,CAACxN,CAA/C,GAAmDwN,GAAG,CAAC5H,KAApE;AACH,SAFD,MAEO,IAAI6H,SAAS,KAAKjS,MAAlB,EAA0B;AAC7BwS,UAAAA,UAAU,GAAGH,YAAY,GAAGR,cAAf,GAAgCjB,QAAQ,GAAG,CAA3C,GAA+CoB,GAAG,CAACxN,CAAnD,GAAuDwN,GAAG,CAAC5H,KAAJ,GAAY,CAAhF;AACH,SAFM,MAEA;AACHoI,UAAAA,UAAU,GAAGH,YAAY,GAAGR,cAAf,GAAgCG,GAAG,CAACxN,CAAjD;AACH;;AACDgO,QAAAA,UAAU,IAAI7B,MAAd;AACH;AACJ;;AACD,WAAO;AACH6B,MAAAA,UAAU,EAAEA,UADT;AAEHC,MAAAA,UAAU,EAAEA;AAFT,KAAP;AAIH,GArSY;AAsSbC,EAAAA,6BAA6B,EAAE,YAAW;AACtC,QAAI9P,QAAQ,GAAG,KAAKgF,SAApB;AACA,QAAI+K,aAAa,GAAG,KAAK7J,cAAzB;AACA,QAAI8J,kBAAkB,GAAGD,aAAa,GAAG,gBAAzC;AACA,QAAIE,WAAW,GAAGjQ,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AAChC8D,MAAAA,KAAK,EAAE2E;AADyB,KAAlB,CAAlB;AAGA,QAAIG,aAAa,GAAGnQ,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AAClC8D,MAAAA,KAAK,EAAE2E;AAD2B,KAAlB,CAApB;AAGA,QAAII,aAAa,GAAGpQ,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AAClC8D,MAAAA,KAAK,EAAE2E;AAD2B,KAAlB,CAApB;AAGA,WAAO;AACHK,MAAAA,MAAM,EAAEJ,WADL;AAEHK,MAAAA,QAAQ,EAAEH,aAFP;AAGHlT,MAAAA,IAAI,EAAEkT,aAHH;AAIHtT,MAAAA,GAAG,EAAEsT,aAJF;AAKHI,MAAAA,QAAQ,EAAEH,aALP;AAMHjT,MAAAA,KAAK,EAAEiT,aANJ;AAOHrT,MAAAA,MAAM,EAAEqT,aAPL;AAQHI,MAAAA,MAAM,EAAE,YAAW;AACf,aAAKH,MAAL,CAAYG,MAAZ;AACA,aAAKF,QAAL,CAAcE,MAAd;AACA,aAAKD,QAAL,CAAcC,MAAd;AACH,OAZE;AAaHC,MAAAA,KAAK,EAAE,YAAW;AACd,aAAKJ,MAAL,CAAYI,KAAZ;AACA,aAAKH,QAAL,CAAcG,KAAd;AACA,aAAKF,QAAL,CAAcE,KAAd;AACH;AAjBE,KAAP;AAmBH,GAtUY;AAuUblK,EAAAA,iBAAiB,EAAE,YAAW;AAC1B,QAAIvG,QAAQ,GAAG,KAAKgF,SAApB;AACA,QAAI+K,aAAa,GAAG,KAAK7J,cAAzB;AACA,SAAKwK,UAAL,GAAkB1Q,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AAChC8D,MAAAA,KAAK,EAAE0E,aAAa,GAAG;AADS,KAAlB,EAEfY,WAFe,EAAlB;AAGA,SAAKC,eAAL,GAAuB5Q,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AACrC8D,MAAAA,KAAK,EAAE0E,aAAa,GAAG;AADc,KAAlB,CAAvB;AAGA,SAAKc,cAAL,GAAsB7Q,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AACpC8D,MAAAA,KAAK,EAAE0E,aAAa,GAAG;AADa,KAAlB,CAAtB;AAGA,SAAKe,kBAAL,GAA0B9Q,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AACxC8D,MAAAA,KAAK,EAAE0E,aAAa,GAAG;AADiB,KAAlB,CAA1B;AAGA,SAAK/H,cAAL,GAAsBhI,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AACpC8D,MAAAA,KAAK,EAAE0E,aAAa,GAAG;AADa,KAAlB,EAEnBgB,MAFmB,CAEZ,KAAKL,UAFO,EAEK,UAFL,EAEiBM,UAFjB,EAAtB;AAGA,SAAKC,eAAL,GAAuBjR,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AACrC8D,MAAAA,KAAK,EAAE0E,aAAa,GAAG;AADc,KAAlB,EAEpBhI,MAFoB,CAEb,KAAK2I,UAFQ,CAAvB;AAGA,SAAKQ,uBAAL,GAA+B;AAC3BC,MAAAA,KAAK,EAAE,KAAKrB,6BAAL,EADoB;AAE3BsB,MAAAA,KAAK,EAAE,KAAKtB,6BAAL;AAFoB,KAA/B;AAIA,SAAKuB,oBAAL,GAA4BrR,QAAQ,CAACkQ,CAAT,GAAa3I,IAAb,CAAkB;AAC1C8D,MAAAA,KAAK,EAAE0E,aAAa,GAAG;AADmB,KAAlB,CAA5B;AAGH,GAnWY;AAoWbuB,EAAAA,gBAAgB,EAAE,YAAW;AACzB,SAAKZ,UAAL,CAAgBF,MAAhB;;AACA,SAAKI,eAAL,CAAqBJ,MAArB;;AACA,SAAKa,oBAAL,CAA0Bb,MAA1B;;AACA,SAAKU,uBAAL,CAA6BC,KAA7B,CAAmCX,MAAnC;;AACA,SAAKU,uBAAL,CAA6BE,KAA7B,CAAmCZ,MAAnC;;AACA,SAAKK,cAAL,CAAoBL,MAApB;;AACA,SAAKS,eAAL,CAAqBR,KAArB;;AACA,QAAI,CAAC,KAAKtJ,QAAL,CAAcjF,KAAd,CAAoBqP,QAArB,IAAiC,CAAC,KAAKC,UAAL,EAAtC,EAAyD;AACrD,WAAKV,kBAAL,CAAwBN,MAAxB;;AACA,WAAKM,kBAAL,CAAwBL,KAAxB;AACH;;AACD,SAAKzI,cAAL,IAAuB,KAAKA,cAAL,CAAoByI,KAApB,EAAvB;AACA,SAAKG,eAAL,IAAwB,KAAKA,eAAL,CAAqBH,KAArB,EAAxB;AACA,SAAKI,cAAL,IAAuB,KAAKA,cAAL,CAAoBJ,KAApB,EAAvB;;AACA,SAAKS,uBAAL,CAA6BC,KAA7B,CAAmCV,KAAnC;;AACA,SAAKS,uBAAL,CAA6BE,KAA7B,CAAmCX,KAAnC;;AACA,SAAKY,oBAAL,IAA6B,KAAKA,oBAAL,CAA0BZ,KAA1B,EAA7B;AACH,GAtXY;AAuXbgB,EAAAA,qBAAqB,EAAE,UAAShH,KAAT,EAAgBxI,YAAhB,EAA8B8J,KAA9B,EAAqC2F,KAArC,EAA4CvN,YAA5C,EAA0DnD,KAA1D,EAAiE;AACpF+K,IAAAA,KAAK,GAAGA,KAAK,IAAI,KAAK4F,iBAAL,EAAjB;AACA,QAAIC,YAAY,GAAG;AACfnH,MAAAA,KAAK,EAAEA,KADQ;AAEfoH,MAAAA,SAAS,EAAEtY,OAAO,CAACkR,KAAD,EAAQ;AACtBxI,QAAAA,YAAY,EAAEA,YADQ;AAEtBjB,QAAAA,KAAK,EAAEA,KAAK,IAAIlF,oBAAoB,CAAC,KAAKuS,WAAN,CAFd;AAGtBlK,QAAAA,YAAY,EAAE,SAASA,YAAT,IAAyB,KAAK,CAAL,KAAWA,YAApC,GAAmDA,YAAnD,GAAkE,KAAK2N,aAH/D;AAItBjT,QAAAA,QAAQ,EAAE,KAAKsI,QAAL,CAActI,QAJF;AAKtBE,QAAAA,aAAa,EAAE,KAAKoI,QAAL,CAAcpI,aALP;AAMtBvE,QAAAA,IAAI,EAAE,KAAK2M,QAAL,CAAc3M,IANE;AAOtBuX,QAAAA,cAAc,EAAE,CAAC,KAAK5K,QAAL,CAAc6K,MAAd,CAAqB3S,OAPhB;AAQtBqS,QAAAA,KAAK,EAAEA;AARe,OAAR,CAAP,IASL,EAXS;AAYfpV,MAAAA,GAAG,EAAEyP,KAAK,CAACE,UAZI;AAaf7P,MAAAA,GAAG,EAAE2P,KAAK,CAACG;AAbI,KAAnB;;AAeA,QAAIwF,KAAJ,EAAW;AACPE,MAAAA,YAAY,CAACF,KAAb,GAAqBA,KAArB;AACH;;AACD,WAAOE,YAAP;AACH,GA5YY;AA6YblG,EAAAA,WAAW,EAAE,UAASjB,KAAT,EAAgBxI,YAAhB,EAA8B8J,KAA9B,EAAqC2F,KAArC,EAA4CvN,YAA5C,EAA0DnD,KAA1D,EAAiE;AAC1E,QAAI4Q,YAAY,GAAG,KAAKH,qBAAL,CAA2BhH,KAA3B,EAAkCxI,YAAlC,EAAgD8J,KAAhD,EAAuD2F,KAAvD,EAA8DvN,YAA9D,EAA4EnD,KAA5E,CAAnB;;AACA,WAAO1G,UAAU,CAAC2H,YAAY,CAACgQ,aAAd,CAAV,GAAyChQ,YAAY,CAACgQ,aAAb,CAA2BC,IAA3B,CAAgCN,YAAhC,EAA8CA,YAA9C,CAAzC,GAAuGA,YAAY,CAACC,SAA3H;AACH,GAhZY;AAiZbM,EAAAA,UAAU,EAAE,UAAS1H,KAAT,EAAgBxI,YAAhB,EAA8B8J,KAA9B,EAAqC;AAC7C,QAAI6F,YAAY,GAAG,KAAKH,qBAAL,CAA2BhH,KAA3B,EAAkCxI,YAAlC,EAAgD8J,KAAhD,CAAnB;;AACA,WAAOzR,UAAU,CAAC2H,YAAY,CAACmQ,aAAd,CAAV,GAAyCnQ,YAAY,CAACmQ,aAAb,CAA2BF,IAA3B,CAAgCN,YAAhC,EAA8CA,YAA9C,CAAzC,GAAuG,KAAK,CAAnH;AACH,GApZY;;AAqZbpY,EAAAA,WAAW,CAACqS,UAAD,EAAaC,QAAb,EAAuBuG,QAAvB,EAAiC;AACxC,WAAO7Y,WAAW,CAACqS,UAAD,EAAaC,QAAb,EAAuBuG,QAAvB,EAAiC,KAAKnS,UAAL,EAAjC,CAAlB;AACH,GAvZY;;AAwZboS,EAAAA,cAAc,EAAE,YAAW;AACvB,QAAInU,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIoL,wBAAwB,GAAGpU,OAAO,CAACoU,wBAAvC;AACA,SAAKC,WAAL,GAAmB,EAAE,kBAAkBD,wBAAlB,IAA8C,CAACA,wBAAjD,CAAnB;AACH,GA5ZY;AA6ZbE,EAAAA,sBAAsB,EAAE,UAASC,cAAT,EAAyB;AAC7C,SAAKC,uBAAL,GAA+B,IAA/B;;AACA,QAAID,cAAJ,EAAoB;AAChB,WAAK9L,aAAL,GAAqB,IAArB;AACH;AACJ,GAlaY;;AAmab8L,EAAAA,cAAc,GAAG;AACb,WAAO,KAAK9L,aAAZ;AACH,GAraY;;AAsabgM,EAAAA,UAAU,EAAE,YAAW;AACnB,QAAItJ,IAAI,GAAG,IAAX;AACA,QAAI;AACAnH,MAAAA,QAAQ,EAAEA,QADV;AAEA4L,MAAAA,MAAM,EAAEA,MAFR;AAGA8E,MAAAA,cAAc,EAAEA,cAHhB;AAIAC,MAAAA,eAAe,EAAEA,eAJjB;AAKA3S,MAAAA,IAAI,EAAEA,IALN;AAMAlF,MAAAA,IAAI,EAAEA,IANN;AAOA8X,MAAAA,eAAe,EAAEA;AAPjB,QAQAzJ,IAAI,CAACnC,QART;AASA,QAAI6L,6BAA6B,GAAG3Y,SAAS,CAACwY,cAAD,CAA7C;AACA,QAAII,gBAAgB,GAAG3J,IAAI,CAACR,2BAAL,EAAvB;AACA,QAAIE,MAAM,GAAGM,IAAI,CAACW,SAAL,EAAb;AACA,QAAIiJ,KAAK,GAAGlK,MAAM,CAAC/L,IAAnB;AACA,QAAIkW,IAAI,GAAGnK,MAAM,CAACnM,GAAlB;AACA,QAAIuW,MAAM,GAAGpK,MAAM,CAACxB,KAAP,GAAewB,MAAM,CAAC7L,KAAnC;AACA,QAAIkW,OAAO,GAAGrK,MAAM,CAAC5F,MAAP,GAAgB4F,MAAM,CAACjM,MAArC;;AACA,QAAIuW,oBAAoB,GAAGnX,IAAI,CAACgE,IAAI,CAACd,OAAL,IAAgBc,IAAI,CAACqH,KAArB,IAA8B,CAA/B,EAAkCvM,IAAI,CAACoE,OAAL,IAAgBpE,IAAI,CAACuM,KAArB,IAA8B,CAAhE,CAA/B;;AACA,QAAI+L,uBAAuB,GAAGjK,IAAI,CAAC4H,uBAAL,CAA6BC,KAA3D;AACA,QAAIqC,uBAAuB,GAAGlK,IAAI,CAAC4H,uBAAL,CAA6BE,KAA3D;AACA,QAAIpO,KAAK,GAAG,CAACsG,IAAI,CAACwH,kBAAN,EAA0ByC,uBAAuB,CAACjD,QAAlD,EAA4DiD,uBAAuB,CAAChD,QAApF,EAA8FiD,uBAAuB,CAAClD,QAAtH,EAAgIkD,uBAAuB,CAACjD,QAAxJ,EAAkKjH,IAAI,CAACtB,cAAvK,EAAuLyL,GAAvL,CAA2LzI,KAAK,IAAIA,KAAK,IAAIA,KAAK,CAACmE,OAAN,EAA7M,EAA8NuE,MAA9N,CAAqO,UAAS1I,KAAT,EAAgB;AAC7P,UAAIoE,GAAG,GAAGpE,KAAK,IAAIA,KAAK,CAACmE,OAAN,EAAnB;;AACA,UAAI,CAACC,GAAD,IAAQA,GAAG,CAAC/K,OAAhB,EAAyB;AACrB,eAAO+K,GAAP;AACH;;AACD,UAAI9F,IAAI,CAACF,aAAT,EAAwB;AACpBgG,QAAAA,GAAG,CAACxN,CAAJ,GAAQsR,KAAR;AACA9D,QAAAA,GAAG,CAAC5H,KAAJ,GAAY4L,MAAM,GAAGF,KAArB;AACH,OAHD,MAGO;AACH9D,QAAAA,GAAG,CAACvN,CAAJ,GAAQsR,IAAR;AACA/D,QAAAA,GAAG,CAAChM,MAAJ,GAAaiQ,OAAO,GAAGF,IAAvB;AACH;;AACD,aAAO/D,GAAP;AACH,KAbgP,CAa/O9F,IAAI,CAAC2H,eAb0O,CAArO,CAAZ;AAcA,QAAI0C,OAAO,GAAG/X,sBAAsB,CAACoH,KAAD,EAAQgG,MAAR,CAApC;AACA2K,IAAAA,OAAO,CAACxR,QAAD,CAAP,IAAqB4Q,eAArB;;AACA,QAAIzJ,IAAI,CAACV,sBAAL,MAAiCoK,6BAArC,EAAoE;AAChEW,MAAAA,OAAO,CAACV,gBAAD,CAAP,GAA4B,CAA5B;AACH;;AACD,QAAIH,eAAJ,EAAqB;AACjBa,MAAAA,OAAO,CAACxR,QAAD,CAAP,GAAoB2Q,eAApB;AACH;;AACD,QAAIQ,oBAAJ,EAA0B;AACtB,UAAIhK,IAAI,CAACF,aAAL,IAAsBJ,MAAM,CAAC7L,KAAP,GAAemW,oBAArC,IAA6DK,OAAO,CAACxW,KAAR,GAAgBmW,oBAAjF,EAAuG;AACnGK,QAAAA,OAAO,CAACxW,KAAR,GAAgBmW,oBAAhB;AACH;;AACD,UAAI,CAAChK,IAAI,CAACF,aAAN,IAAuBJ,MAAM,CAACjM,MAAP,GAAgBuW,oBAAvC,IAA+DK,OAAO,CAAC5W,MAAR,GAAiBuW,oBAApF,EAA0G;AACtGK,QAAAA,OAAO,CAAC5W,MAAR,GAAiBuW,oBAAjB;AACH;AACJ;;AACD,QAAI,CAACN,6BAAD,IAAkC3Y,SAAS,CAAC0T,MAAD,CAA/C,EAAyD;AACrD,UAAI6F,YAAY,GAAGtK,IAAI,CAACuK,wBAAL,OAAoC9F,MAAM,GAAG,CAAT,KAAekF,gBAAgB,KAAKjW,IAArB,IAA6BiW,gBAAgB,KAAKrW,GAAjE,KAAyEmR,MAAM,GAAG,CAAT,KAAekF,gBAAgB,KAAK/V,KAArB,IAA8B+V,gBAAgB,KAAKnW,MAAlE,CAA7G,CAAnB;AACA6W,MAAAA,OAAO,CAACV,gBAAD,CAAP,IAA6BW,YAAY,GAAG7F,MAAH,GAAY,CAArD;AACH;;AACD,WAAO4F,OAAP;AACH,GA9dY;AA+db3G,EAAAA,YAAY,EAAE,UAAS8G,IAAT,EAAeC,OAAf,EAAwBC,UAAxB,EAAoC;AAC9CF,IAAAA,IAAI,GAAG,KAAKnH,MAAL,CAAYmH,IAAZ,CAAP;;AACA,QAAI,KAAK,CAAL,KAAWA,IAAX,IAAmBC,OAAvB,EAAgC;AAC5B,WAAK9O,iBAAL,CAAuB8O,OAAvB,EAAgC,CAACC,UAAD,CAAhC;AACH;;AACD,WAAOF,IAAP;AACH,GAreY;AAsebzN,EAAAA,QAAQ,EAAE,UAASzH,QAAT,EAAmB0H,WAAnB,EAAgC;AACtC,QAAI2N,eAAJ;;AACA,YAAQrV,QAAR;AACI,WAAK,QAAL;AACIqV,QAAAA,eAAe,GAAG3Y,SAAlB;AACA;;AACJ,WAAK,WAAL;AACI2Y,QAAAA,eAAe,GAAG1Y,YAAlB;AALR;;AAOAb,IAAAA,MAAM,CAAC,IAAD,EAAOuZ,eAAe,CAAC3N,WAAD,CAAtB,CAAN;AACH,GAhfY;AAifbuB,EAAAA,cAAc,EAAE,YAAW;AACvB,WAAO,IAAP;AACH,GAnfY;AAofbqM,EAAAA,mBAAmB,EAAE7Y,KApfR;AAqfb8Y,EAAAA,OAAO,EAAE,YAAW;AAChB,KAAC,KAAKrD,kBAAN,EAA0B,KAAKF,eAA/B,EAAgD,KAAKF,UAArD,EAAiE7P,OAAjE,CAA0E,UAASqP,CAAT,EAAY;AAClFA,MAAAA,CAAC,CAACiE,OAAF;AACH,KAFD;AAGA,SAAKxG,OAAL,GAAe,KAAKyG,MAAL,GAAc,IAA7B;AACA,SAAKxD,eAAL,GAAuB,KAAKM,uBAAL,GAA+B,KAAKG,oBAAL,GAA4B,KAAKgD,gBAAL,GAAwB,IAA1G;AACA,SAAKrM,cAAL,GAAsB,KAAK8I,kBAAL,GAA0B,KAAKD,cAAL,GAAsB,IAAtE;AACA,SAAKH,UAAL,GAAkB,KAAKO,eAAL,GAAuB,IAAzC;AACA,SAAKnL,mBAAL,GAA2B,KAAKV,YAAL,GAAoB,KAAKM,mBAAL,GAA2B,KAAKF,gBAAL,GAAwB,IAAlG;AACA,SAAKR,SAAL,GAAiB,KAAKmC,QAAL,GAAgB,KAAKmN,YAAL,GAAoB,KAAKC,eAAL,GAAuB,IAA5E;AACA,SAAK/N,WAAL,GAAmB,IAAnB;AACA,SAAK6H,WAAL,GAAmB,KAAKmG,WAAL,GAAmB,IAAtC;;AACA,SAAKN,mBAAL;;AACA,SAAKO,kBAAL,IAA2B,KAAKA,kBAAL,CAAwBC,MAAxB,EAA3B;AACH,GAngBY;AAogBbxU,EAAAA,UAAU,EAAE,YAAW;AACnB,WAAO,KAAKiH,QAAZ;AACH,GAtgBY;AAugBbwN,EAAAA,OAAO,EAAE,UAASC,IAAT,EAAe;AACpB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKzN,QAAL,CAAcyN,IAAd,GAAqBA,IAArB;AACH,GA1gBY;AA2gBbC,EAAAA,QAAQ,EAAE,UAASra,IAAT,EAAeoE,QAAf,EAAyBkW,YAAzB,EAAuC;AAC7C,SAAK3N,QAAL,CAAc3M,IAAd,GAAqBA,IAAI,IAAI,KAAK2M,QAAL,CAAc3M,IAA3C;AACA,SAAK2M,QAAL,CAAc2N,YAAd,IAA8BlW,QAAQ,IAAI,KAAKuI,QAAL,CAAc2N,YAAd,CAA1C;;AACA,SAAKC,iBAAL;AACH,GA/gBY;AAghBbC,EAAAA,UAAU,EAAE,UAASF,YAAT,EAAuB;AAC/B,SAAK3N,QAAL,CAAc3M,IAAd,GAAqB,KAAKya,UAAL,CAAgBza,IAArC;AACA,SAAK2M,QAAL,CAAc2N,YAAd,IAA8B,KAAKG,UAAL,CAAgBH,YAAhB,CAA9B;AACH,GAnhBY;AAohBbI,EAAAA,aAAa,EAAE,YAAW;AACtB,WAAO,KAAK1O,WAAZ;AACH,GAthBY;AAuhBb2O,EAAAA,aAAa,EAAE,UAAShX,OAAT,EAAkB;AAC7B,QAAImL,IAAI,GAAG,IAAX;AACA,QAAIrG,QAAQ,GAAG9E,OAAO,CAAC+D,KAAvB;AACAH,IAAAA,mBAAmB,CAAC5D,OAAD,CAAnB;AACAmL,IAAAA,IAAI,CAACnC,QAAL,GAAgBhJ,OAAhB;AACAA,IAAAA,OAAO,CAAClD,IAAR,GAAekD,OAAO,CAAClD,IAAR,IAAgB,EAA/B;AACAkD,IAAAA,OAAO,CAACiB,SAAR,GAAoBjB,OAAO,CAACiB,SAAR,IAAqB,EAAzC;AACAjB,IAAAA,OAAO,CAACgC,IAAR,GAAehC,OAAO,CAACgC,IAAR,IAAgB,EAA/B;AACAhC,IAAAA,OAAO,CAACmB,SAAR,GAAoBnB,OAAO,CAACmB,SAAR,IAAqB,EAAzC;AACAnB,IAAAA,OAAO,CAACiX,KAAR,GAAgBjX,OAAO,CAACiX,KAAR,IAAiB,EAAjC;AACAjX,IAAAA,OAAO,CAAC6T,MAAR,GAAiB7T,OAAO,CAAC6T,MAAR,IAAkB,EAAnC;AACA1I,IAAAA,IAAI,CAAC2L,UAAL,GAAkB;AACdza,MAAAA,IAAI,EAAE2D,OAAO,CAAC3D,IADA;AAEdqI,MAAAA,YAAY,EAAE1E,OAAO,CAAC0E,YAFR;AAGdC,MAAAA,SAAS,EAAE3E,OAAO,CAAC2E;AAHL,KAAlB;;AAKAwG,IAAAA,IAAI,CAACgJ,cAAL;;AACAhJ,IAAAA,IAAI,CAACF,aAAL,GAAqBjL,OAAO,CAACkE,YAA7B;AACAiH,IAAAA,IAAI,CAACsL,IAAL,GAAYzW,OAAO,CAACyW,IAApB;AACAtL,IAAAA,IAAI,CAAC+L,IAAL,GAAYlX,OAAO,CAACkX,IAApB;AACA/L,IAAAA,IAAI,CAACgM,QAAL,GAAgBnX,OAAO,CAACmX,QAAxB;AACAhM,IAAAA,IAAI,CAACiM,eAAL,GAAuB,OAAOtS,QAAQ,CAACuS,MAAhB,IAA0Bnb,SAAS,CAAC4I,QAAQ,CAACuS,MAAV,CAA1D;AACAlM,IAAAA,IAAI,CAACgL,YAAL,GAAoB;AAChB3M,MAAAA,OAAO,EAAE1E,QAAQ,CAAC0E,OADF;AAEhByD,MAAAA,KAAK,EAAE,QAFS;AAGhBC,MAAAA,KAAK,EAAEpI,QAAQ,CAACiI;AAHA,KAApB;AAKA5B,IAAAA,IAAI,CAACiL,eAAL,GAAuB9a,gBAAgB,CAACwJ,QAAQ,CAACgI,IAAV,CAAvC;;AACA,QAAI9M,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAACgb,WAA/B,EAA4C;AACxC,UAAItX,OAAO,CAACuX,kBAAZ,EAAgC;AAC5BpM,QAAAA,IAAI,CAACrE,iBAAL,CAAuB,OAAvB;;AACA,eAAO9G,OAAO,CAACuX,kBAAf;AACH;AACJ;;AACDpM,IAAAA,IAAI,CAACyL,iBAAL;;AACAzL,IAAAA,IAAI,CAACqM,oBAAL;;AACArM,IAAAA,IAAI,CAACqE,OAAL,GAAe,CAACxP,OAAO,CAACyX,MAAR,IAAkB,EAAnB,EAAuBnC,GAAvB,CAA2BoC,CAAC,IAAIpa,WAAW,CAAC6N,IAAD,EAAOuM,CAAP,CAA3C,CAAf;AACAvM,IAAAA,IAAI,CAAC+E,WAAL,GAAmB/E,IAAI,CAACkL,WAAL,GAAmB,IAAtC;AACAlL,IAAAA,IAAI,CAAC1C,aAAL,GAAqB,IAArB;AACH,GA9jBY;AA+jBbkP,EAAAA,iBAAiB,EAAE,UAASrL,KAAT,EAAgBsL,SAAhB,EAA2B;AAC1C,QAAI5X,OAAO,GAAG,KAAKgJ,QAAnB;;AACA,QAAI,CAAChJ,OAAD,IAAYA,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAACgb,WAA3C,EAAwD;AACpD,aAAOxZ,IAAI,CAACwO,KAAK,GAAGsL,SAAT,CAAX;AACH;;AACD,QAAI;AACArX,MAAAA,cAAc,EAAEA,cADhB;AAEAC,MAAAA,eAAe,EAAEA;AAFjB,QAGA,IAAI3D,KAAJ,CAAU,KAAKka,aAAL,GAAqBc,gBAArB,EAAV,CAHJ;AAIA,WAAO/Z,IAAI,CAACrC,MAAM,CAAC6Q,KAAD,EAAQtM,OAAO,CAACY,aAAhB,EAA+BL,cAA/B,EAA+CC,eAA/C,CAAN,GAAwE/E,MAAM,CAACmc,SAAD,EAAY5X,OAAO,CAACY,aAApB,EAAmCL,cAAnC,EAAmDC,eAAnD,CAA/E,CAAX;AACH,GAzkBY;;AA0kBbsX,EAAAA,cAAc,GAAG;AACb,QAAIC,UAAU,GAAG,KAAK1P,WAAtB;AACA,WAAO;AACHqF,MAAAA,UAAU,EAAEqK,UAAU,CAACrJ,IAAX,CAAgBqJ,UAAU,CAACC,SAAX,CAAqB,uBAArB,CAAhB,CADT;AAEHrK,MAAAA,QAAQ,EAAEoK,UAAU,CAACrJ,IAAX,CAAgBqJ,UAAU,CAACC,SAAX,CAAqB,qBAArB,CAAhB;AAFP,KAAP;AAIH,GAhlBY;;AAilBbC,EAAAA,cAAc,EAAE,UAASpN,MAAT,EAAiB;AAC7B,WAAOA,MAAP;AACH,GAnlBY;AAolBbqN,EAAAA,YAAY,EAAE,UAASrN,MAAT,EAAiBsN,cAAjB,EAAiC;AAC3C,QAAI,CAACA,cAAL,EAAqB;AACjB,UAAIC,SAAS,GAAG,KAAK5M,oBAAL,GAA4B;AACxC/E,QAAAA,KAAK,EAAE,CAAC,KAAKwE,aAAN,GAAsBJ,MAAM,CAAC/L,IAA7B,GAAoC+L,MAAM,CAACnM,GADV;AAExCgI,QAAAA,GAAG,EAAE,CAAC,KAAKuE,aAAN,GAAsBJ,MAAM,CAACxB,KAAP,GAAewB,MAAM,CAAC7L,KAA5C,GAAoD6L,MAAM,CAAC5F,MAAP,GAAgB4F,MAAM,CAACjM;AAFxC,OAA5C;AAIAwZ,MAAAA,SAAS,CAAClZ,MAAV,GAAmBkZ,SAAS,CAAC3R,KAAV,GAAkB,CAAC2R,SAAS,CAAC1R,GAAV,GAAgB0R,SAAS,CAAC3R,KAA3B,IAAoC,CAAzE;AACH,KAND,MAMO;AACH,WAAK+E,oBAAL,GAA4B,IAA5B;AACH;;AACD,SAAK6M,OAAL,GAAexN,MAAf;;AACA,SAAKxC,WAAL,CAAiB6P,YAAjB,CAA8B,KAAKD,cAAL,CAAoBpN,MAApB,CAA9B;;AACA,SAAKyN,kBAAL;AACH,GAjmBY;AAkmBbxM,EAAAA,SAAS,EAAE,YAAW;AAClB,WAAO,KAAKuM,OAAZ;AACH,GApmBY;;AAqmBbE,EAAAA,YAAY,GAAG;AACX,WAAO,KAAKC,UAAL,IAAmB,CAA1B;AACH,GAvmBY;;AAwmBbC,EAAAA,SAAS,EAAE,YAAW;AAClB,QAAI,KAAKzP,QAAL,CAAciO,KAAd,CAAoBtK,IAAxB,EAA8B;AAC1B,WAAK7F,iBAAL,CAAuB,OAAvB,EAAgC,CAAC,KAAKmE,aAAL,GAAqB,YAArB,GAAoC,UAArC,CAAhC;;AACA,WAAK6H,eAAL,CAAqBR,KAArB;AACH;AACJ,GA7mBY;AA8mBboG,EAAAA,QAAQ,EAAE,YAAW;AACjB,WAAO,KAAKzC,MAAZ;AACH,GAhnBY;AAinBb0C,EAAAA,iBAAiB,EAAE,YAAW;AAC1B,QAAI3Y,OAAO,GAAG,KAAKgJ,QAAnB;;AACA,QAAI,CAAChJ,OAAO,CAAC+D,KAAR,CAAc7C,OAAd,IAAyB,KAAK0X,qBAAL,CAA2BtV,MAArD,KAAgE,CAAC,KAAK+E,WAAL,CAAiBwP,gBAAjB,GAAoC3R,OAApC,EAArE,EAAoH;AAChH,WAAKY,iBAAL,CAAuB,OAAvB,EAAgC,CAAC,KAAKmE,aAAL,GAAqB,YAArB,GAAoC,UAArC,CAAhC;;AACA,WAAK0H,kBAAL,CAAwBL,KAAxB;;AACAjQ,MAAAA,UAAU,CAAC,KAAKuW,qBAAN,EAA6B,aAA7B,CAAV;AACH;AACJ,GAxnBY;;AAynBbC,EAAAA,kCAAkC,CAACjL,KAAD,EAAQ;AACtC,QAAI5N,OAAO,GAAG,KAAKgJ,QAAnB;;AACA,QAAIhJ,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAACgb,WAA/B,EAA4C;AACxC1J,MAAAA,KAAK,CAACkL,QAAN,CAAe;AACXvY,QAAAA,cAAc,EAAE,KAAK,CAAL,KAAWP,OAAO,CAACO,cAAnB,GAAoCP,OAAO,CAACO,cAA5C,GAA6DqN,KAAK,CAACzP,GAAN,IAAa;AAD/E,OAAf;;AAGA,UAAI,CAAC4a,KAAK,CAAC/Y,OAAO,CAACQ,eAAT,CAAV,EAAqC;AACjCoN,QAAAA,KAAK,CAACpN,eAAN,GAAwBR,OAAO,CAACQ,eAAhC;AACH;AACJ;AACJ,GAnoBY;;AAooBbwY,EAAAA,cAAc,CAACC,aAAD,EAAgB;AAC1B,QAAIjZ,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIoI,UAAU,GAAGpR,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAAC4c,QAA5C;AACA,QAAI9S,UAAU,GAAG,KAAK+S,WAAL,IAAoB,KAAKA,WAAL,CAAiB/S,UAArC,IAAmD,EAApE;AACA,QAAIgT,UAAU,GAAG,KAAKC,WAAL,CAAiB9d,iBAAiB,CAACyE,OAAO,CAACoZ,UAAT,CAAlC,CAAjB;AACA,QAAIE,WAAW,GAAG,KAAKC,WAAL,MAAsB,EAAxC;AACA,QAAItL,MAAM,GAAG,IAAIpR,KAAJ,CAAUoc,aAAV,CAAb;;AACA,SAAKO,wBAAL,CAA8BvL,MAA9B,EAAsC,YAAtC,EAAoD,YAApD;;AACA,QAAIwL,UAAU,GAAGvd,SAAS,CAACod,WAAW,CAAC5L,UAAb,CAA1B;AACA,QAAIgM,UAAU,GAAGxd,SAAS,CAACod,WAAW,CAAC3L,QAAb,CAA1B;;AACA,QAAI,CAACyD,UAAL,EAAiB;AACbqI,MAAAA,UAAU,GAAGA,UAAU,KAAK,CAACvd,SAAS,CAACkd,UAAU,CAACzL,QAAZ,CAAV,IAAmC2L,WAAW,CAAC5L,UAAZ,GAAyB0L,UAAU,CAACzL,QAA5E,CAAvB;AACA+L,MAAAA,UAAU,GAAGA,UAAU,KAAK,CAACxd,SAAS,CAACkd,UAAU,CAAC1L,UAAZ,CAAV,IAAqC4L,WAAW,CAAC3L,QAAZ,GAAuByL,UAAU,CAAC1L,UAA5E,CAAvB;AACH;;AACD,QAAII,UAAU,GAAG2L,UAAU,GAAGH,WAAW,CAAC5L,UAAf,GAA4BO,MAAM,CAACH,UAA9D;AACA,QAAIC,UAAU,GAAG2L,UAAU,GAAGJ,WAAW,CAAC3L,QAAf,GAA0BM,MAAM,CAACF,UAA5D;;AACA,QAAI,CAACqD,UAAL,EAAiB;AACb,UAAIuI,qBAAJ,EAA2BC,oBAA3B;;AACA3L,MAAAA,MAAM,CAAC9P,GAAP,GAAa,UAAUwb,qBAAqB,GAAGP,UAAU,CAAC1L,UAA7C,KAA4D,KAAK,CAAL,KAAWiM,qBAAvE,GAA+FA,qBAA/F,GAAuH1L,MAAM,CAAC9P,GAA3I;AACA8P,MAAAA,MAAM,CAAChQ,GAAP,GAAa,UAAU2b,oBAAoB,GAAGR,UAAU,CAACzL,QAA5C,KAAyD,KAAK,CAAL,KAAWiM,oBAApE,GAA2FA,oBAA3F,GAAkH3L,MAAM,CAAChQ,GAAtI;AACH,KAJD,MAIO;AACH,UAAI4b,cAAc,GAAG/d,iBAAiB,CAACsK,UAAD,EAAagT,UAAU,CAAC1L,UAAxB,EAAoC0L,UAAU,CAACzL,QAA/C,CAAtC;AACAvH,MAAAA,UAAU,GAAGyT,cAAc,CAACzT,UAA5B;AACA6H,MAAAA,MAAM,CAAC7H,UAAP,GAAoBA,UAApB;AACH;;AACD,QAAI0T,mBAAmB,GAAG/d,iBAAiB,CAAC;AACxC0E,MAAAA,QAAQ,EAAET,OAAO,CAAC3D,IADsB;AAExCqE,MAAAA,QAAQ,EAAEV,OAAO,CAACU,QAFsB;AAGxCqZ,MAAAA,IAAI,EAAE/Z,OAAO,CAACY;AAH0B,KAAD,EAIxC;AACC8M,MAAAA,UAAU,EAAE+L,UAAU,GAAGH,WAAW,CAAC5L,UAAf,GAA4B,KAAK,CADxD;AAECC,MAAAA,QAAQ,EAAE+L,UAAU,GAAGJ,WAAW,CAAC3L,QAAf,GAA0B,KAAK,CAFpD;AAGCrK,MAAAA,MAAM,EAAEgW,WAAW,CAAChW;AAHrB,KAJwC,EAQxC;AACC8C,MAAAA,UAAU,EAAEA,UADb;AAECjI,MAAAA,GAAG,EAAEib,UAAU,CAAC1L,UAFjB;AAGCzP,MAAAA,GAAG,EAAEmb,UAAU,CAACzL;AAHjB,KARwC,EAYxC;AACCvH,MAAAA,UAAU,EAAEA,UADb;AAECjI,MAAAA,GAAG,EAAE2P,UAFN;AAGC7P,MAAAA,GAAG,EAAE8P;AAHN,KAZwC,CAA3C;AAiBAE,IAAAA,MAAM,CAACH,UAAP,GAAoBgM,mBAAmB,CAACpM,UAAxC;AACAO,IAAAA,MAAM,CAACF,UAAP,GAAoB+L,mBAAmB,CAACnM,QAAxC;AACA,KAACzR,SAAS,CAAC+R,MAAM,CAAC9P,GAAR,CAAV,KAA2B8P,MAAM,CAAC9P,GAAP,GAAa8P,MAAM,CAACH,UAA/C;AACA,KAAC5R,SAAS,CAAC+R,MAAM,CAAChQ,GAAR,CAAV,KAA2BgQ,MAAM,CAAChQ,GAAP,GAAagQ,MAAM,CAACF,UAA/C;AACAE,IAAAA,MAAM,CAAC6K,QAAP,CAAgB,EAAhB;;AACA,SAAKD,kCAAL,CAAwC5K,MAAxC;;AACA,WAAOA,MAAP;AACH,GArrBY;;AAsrBboL,EAAAA,WAAW,CAACzL,KAAD,EAAQ;AACfA,IAAAA,KAAK,GAAGA,KAAK,IAAI,EAAjB;AACA,QAAIwD,UAAU,GAAG,KAAKpI,QAAL,CAAc3M,IAAd,KAAuBC,SAAS,CAAC4c,QAAlD;AACA,QAAIc,aAAa,GAAG,KAAKhR,QAAL,CAAc3M,IAAd,KAAuBC,SAAS,CAACgb,WAArD;AACA,QAAI2C,iBAAiB,GAAG,UAAU,KAAKjR,QAAL,CAAczI,cAAhD;;AACA,QAAIyZ,aAAJ,EAAmB;AACfpM,MAAAA,KAAK,CAACF,UAAN,GAAmBuM,iBAAiB,IAAIrM,KAAK,CAACF,UAAN,IAAoB,CAAzC,GAA6C,IAA7C,GAAoDE,KAAK,CAACF,UAA7E;AACAE,MAAAA,KAAK,CAACD,QAAN,GAAiBsM,iBAAiB,IAAIrM,KAAK,CAACD,QAAN,IAAkB,CAAvC,GAA2C,IAA3C,GAAkDC,KAAK,CAACD,QAAzE;AACH;;AACD,QAAI,CAACyD,UAAD,IAAelV,SAAS,CAAC0R,KAAK,CAACF,UAAP,CAAxB,IAA8CxR,SAAS,CAAC0R,KAAK,CAACD,QAAP,CAAvD,IAA2EC,KAAK,CAACF,UAAN,GAAmBE,KAAK,CAACD,QAAxG,EAAkH;AAC9G,UAAIuM,GAAG,GAAGtM,KAAK,CAACD,QAAhB;AACAC,MAAAA,KAAK,CAACD,QAAN,GAAiBC,KAAK,CAACF,UAAvB;AACAE,MAAAA,KAAK,CAACF,UAAN,GAAmBwM,GAAnB;AACH;;AACD,WAAOtM,KAAP;AACH,GArsBY;;AAssBbuM,EAAAA,yBAAyB,CAACC,QAAD,EAAWC,QAAX,EAAqBC,aAArB,EAAoC;AACzD,QAAIhO,KAAK,GAAG,KAAKtD,QAAL,CAAcuR,qBAA1B;AACA,QAAIxC,UAAU,GAAG,KAAK1P,WAAtB;AACA,QAAIuF,KAAK,GAAG,KAAKuL,WAAjB;;AACA,QAAI,KAAK5Q,cAAT,EAAyB;AACrB,UAAI,CAAC,CAAD,KAAO,CAACnJ,KAAD,EAAQD,IAAR,EAAcE,KAAd,EAAqBmb,OAArB,CAA6BlO,KAA7B,CAAX,EAAgD;AAC5C,YAAIsB,KAAK,CAACnN,QAAN,KAAmBnE,SAAS,CAAC4c,QAAjC,EAA2C;AACvC,cAAI9S,UAAU,GAAGwH,KAAK,CAACxH,UAAvB;AACA,cAAIqU,aAAa,GAAGJ,QAAQ,CAACjU,UAA7B;AACA,cAAIkT,WAAW,GAAG,KAAKA,WAAL,EAAlB;;AACA,cAAIlT,UAAU,IAAIqU,aAAd,IAA+BrU,UAAU,CAAC9C,MAA1C,IAAoD,CAAC,CAAD,KAAOmX,aAAa,CAACnF,GAAd,CAAkBoF,CAAC,IAAIA,CAAC,CAAC9e,OAAF,EAAvB,EAAoC+e,IAApC,CAAyC,GAAzC,EAA8CH,OAA9C,CAAsDpU,UAAU,CAACkP,GAAX,CAAeoF,CAAC,IAAIA,CAAC,CAAC9e,OAAF,EAApB,EAAiC+e,IAAjC,CAAsC,GAAtC,CAAtD,CAA3D,KAAiKrB,WAAW,CAAC5L,UAAZ,CAAuB9R,OAAvB,OAAqCwK,UAAU,CAAC,CAAD,CAAV,CAAcxK,OAAd,EAArC,IAAgE0d,WAAW,CAAC3L,QAAZ,CAAqB/R,OAArB,OAAmCwK,UAAU,CAACA,UAAU,CAAC9C,MAAX,GAAoB,CAArB,CAAV,CAAkC1H,OAAlC,EAApQ,CAAJ,EAAsT;AAClT0Q,YAAAA,KAAK,GAAGnN,IAAR;AACH,WAFD,MAEO;AACHmN,YAAAA,KAAK,GAAGjN,KAAR;AACH;AACJ,SATD,MASO;AACH,cAAIub,QAAQ,GAAG7C,UAAU,CAACC,SAAX,CAAqBpK,KAAK,CAACzP,GAA3B,CAAf;AACA,cAAI0c,eAAe,GAAG9C,UAAU,CAACC,SAAX,CAAqBoC,QAAQ,CAAC1M,UAA9B,CAAtB;AACA,cAAIoN,QAAQ,GAAG/C,UAAU,CAACC,SAAX,CAAqBpK,KAAK,CAAC3P,GAA3B,CAAf;AACA,cAAI8c,eAAe,GAAGhD,UAAU,CAACC,SAAX,CAAqBoC,QAAQ,CAACzM,QAA9B,CAAtB;;AACA,cAAIiN,QAAQ,KAAKC,eAAb,IAAgCC,QAAQ,KAAKC,eAAjD,EAAkE;AAC9DzO,YAAAA,KAAK,GAAGjN,KAAR;AACH,WAFD,MAEO,IAAIub,QAAQ,KAAKC,eAAb,IAAgCC,QAAQ,KAAKC,eAAjD,EAAkE;AACrEzO,YAAAA,KAAK,GAAGlN,KAAR;AACH,WAFM,MAEA;AACHkN,YAAAA,KAAK,GAAGnN,IAAR;AACH;AACJ;AACJ;AACJ,KAzBD,MAyBO,IAAI,CAAC,CAAD,KAAO,CAACA,IAAD,EAAOE,KAAP,EAAcmb,OAAd,CAAsBlO,KAAtB,CAAX,EAAyC;AAC5C,UAAIgO,aAAa,KAAKnb,IAAtB,EAA4B;AACxBmN,QAAAA,KAAK,GAAGnN,IAAR;AACH,OAFD,MAEO;AACHmN,QAAAA,KAAK,GAAGjN,KAAR;AACH;AACJ;;AACD,WAAOiN,KAAP;AACH,GA3uBY;;AA4uBb0O,EAAAA,2BAA2B,CAACC,6BAAD,EAAgCC,iBAAhC,EAAmDb,QAAnD,EAA6D;AACpF,QAAIf,WAAW,GAAG,KAAKA,WAAL,EAAlB;;AACA,QAAI4B,iBAAiB,IAAI,KAAK7S,WAAL,CAAiBwP,gBAAjB,GAAoC3R,OAApC,EAAzB,EAAwE;AACpE;AACH;;AACD,QAAIqU,qBAAqB,GAAG,KAAKY,0BAAL,GAAkC,KAAKhB,yBAAL,CAA+Bb,WAA/B,EAA4Ce,QAA5C,EAAsDY,6BAAtD,CAA9D;;AACA,QAAIb,QAAQ,GAAG,KAAKb,WAAL,EAAf;;AACA,QAAI,CAACrd,SAAS,CAACke,QAAQ,CAAC1M,UAAV,CAAV,IAAmC,CAACxR,SAAS,CAACke,QAAQ,CAACzM,QAAV,CAA7C,IAAoE,CAACzR,SAAS,CAACke,QAAQ,CAAC9W,MAAV,CAAlF,EAAqG;AACjGiX,MAAAA,qBAAqB,GAAGlb,KAAxB;AACH,KAFD,MAEO;AACH,WAAK+b,iBAAL,KAA2Bb,qBAAqB,GAAGpb,IAAnD;AACH;;AACD,QAAIob,qBAAqB,KAAKpb,IAA9B,EAAoC;AAChC,WAAKkc,eAAL,CAAqB,CAAC/B,WAAW,CAAC5L,UAAb,EAAyB4L,WAAW,CAAC3L,QAArC,CAArB;AACH;;AACD,QAAI4M,qBAAqB,KAAKlb,KAA9B,EAAqC;AACjC,WAAKgc,eAAL,CAAqB,CAAC,IAAD,EAAO,IAAP,CAArB;AACH;;AACD,QAAId,qBAAqB,KAAKnb,KAA9B,EAAqC;AACjC,WAAKic,eAAL,CAAqB;AACjB/X,QAAAA,MAAM,EAAE,KAAKgY,oBAAL;AADS,OAArB;AAGH;AACJ,GAnwBY;;AAowBbA,EAAAA,oBAAoB,CAAC1N,KAAD,EAAQ;AACxB,QAAI2N,oBAAoB,GAAG3N,KAAK,IAAI,KAAKvF,WAAL,CAAiBwP,gBAAjB,EAApC;;AACA,QAAI;AACAxb,MAAAA,IAAI,EAAEA;AADN,QAEA,KAAK2M,QAFT;AAGA,QAAI1F,MAAJ;;AACA,QAAIjH,IAAI,KAAKC,SAAS,CAACgb,WAAvB,EAAoC;AAChChU,MAAAA,MAAM,GAAGvG,MAAM,CAAC,KAAK4a,iBAAL,CAAuB4D,oBAAoB,CAACxN,UAA5C,EAAwDwN,oBAAoB,CAACzN,UAA7E,CAAD,CAAf;AACH,KAFD,MAEO,IAAIzR,IAAI,KAAKC,SAAS,CAAC4c,QAAvB,EAAiC;AACpC,UAAIW,cAAc,GAAG/d,iBAAiB,CAACyf,oBAAoB,CAACnV,UAAtB,EAAkCmV,oBAAoB,CAACzN,UAAvD,EAAmEyN,oBAAoB,CAACxN,UAAxF,CAAtC;AACAzK,MAAAA,MAAM,GAAGuW,cAAc,CAACzT,UAAf,CAA0B9C,MAAnC;AACH,KAHM,MAGA;AACHA,MAAAA,MAAM,GAAGiY,oBAAoB,CAACxN,UAArB,GAAkCwN,oBAAoB,CAACzN,UAAhE;AACH;;AACD,WAAOxK,MAAP;AACH,GAnxBY;;AAoxBbkY,EAAAA,oBAAoB,CAAC5N,KAAD,EAAQ6N,QAAR,EAAkB;AAClC,QAAI1D,UAAU,GAAG,KAAKhB,aAAL,EAAjB;AACA,QAAIkC,aAAa,GAAGlB,UAAU,CAACF,gBAAX,EAApB;AACA,QAAI0D,oBAAoB,GAAGE,QAAQ,GAAGlf,MAAM,CAAC,IAAD,EAAO,EAAP,EAAW0c,aAAX,EAA0BrL,KAAK,IAAI,EAAnC,CAAT,GAAkDA,KAAK,IAAIqL,aAA9F;AACA,QAAI;AACA5c,MAAAA,IAAI,EAAEA,IADN;AAEAuE,MAAAA,aAAa,EAAEA;AAFf,QAGA,KAAKoI,QAHT;AAIA,QAAI9J,MAAJ;;AACA,QAAI,CAAChD,SAAS,CAACqf,oBAAoB,CAACzN,UAAtB,CAAV,IAA+C,CAAC5R,SAAS,CAACqf,oBAAoB,CAACxN,UAAtB,CAA7D,EAAgG;AAC5F;AACH;;AACD,QAAI1R,IAAI,KAAKC,SAAS,CAACgb,WAAvB,EAAoC;AAChC,UAAI;AACA/W,QAAAA,cAAc,EAAEA,cADhB;AAEAC,QAAAA,eAAe,EAAEA,eAFjB;AAGAsN,QAAAA,UAAU,EAAEA,UAHZ;AAIAC,QAAAA,UAAU,EAAEA;AAJZ,UAKAwN,oBALJ;AAMArc,MAAAA,MAAM,GAAGvD,OAAO,CAACoB,MAAM,CAACtB,MAAM,CAACsS,UAAD,EAAanN,aAAb,EAA4BL,cAA5B,EAA4CC,eAA5C,CAAN,GAAqE/E,MAAM,CAACqS,UAAD,EAAalN,aAAb,EAA4BL,cAA5B,EAA4CC,eAA5C,CAA5E,CAAN,GAAkJ,CAAnJ,EAAsJI,aAAtJ,EAAqKL,cAArK,EAAqLC,eAArL,CAAhB;AACH,KARD,MAQO,IAAInE,IAAI,KAAKC,SAAS,CAAC4c,QAAvB,EAAiC;AACpC,UAAIW,cAAc,GAAG/d,iBAAiB,CAACyf,oBAAoB,CAACnV,UAAtB,EAAkCmV,oBAAoB,CAACzN,UAAvD,EAAmEyN,oBAAoB,CAACxN,UAAxF,CAAtC;AACA,UAAIzI,KAAK,GAAGzH,IAAI,CAAC6d,IAAL,CAAU7B,cAAc,CAACzT,UAAf,CAA0B9C,MAA1B,GAAmC,CAA7C,IAAkD,CAA9D;AACApE,MAAAA,MAAM,GAAG+Z,aAAa,CAAC7S,UAAd,CAAyBoU,OAAzB,CAAiCX,cAAc,CAACzT,UAAf,CAA0Bd,KAA1B,CAAjC,CAAT;AACH,KAJM,MAIA;AACHpG,MAAAA,MAAM,GAAG6Y,UAAU,CAAC4D,OAAX,CAAmB,CAACJ,oBAAoB,CAACxN,UAArB,CAAgCnS,OAAhC,KAA4C2f,oBAAoB,CAACzN,UAArB,CAAgClS,OAAhC,EAA7C,IAA0F,CAA7G,CAAT;AACH;;AACD,WAAOsD,MAAP;AACH,GAhzBY;;AAizBb0c,EAAAA,gBAAgB,CAAChO,KAAD,EAAQsN,iBAAR,EAA2BD,6BAA3B,EAA0DY,aAA1D,EAAyE;AACrF,QAAIC,qBAAJ,EAA2BC,qBAA3B;;AACA,QAAI/b,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIoI,UAAU,GAAGpR,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAAC4c,QAA5C;;AACA,SAAK8B,2BAAL,CAAiCC,6BAAjC,EAAgEC,iBAAhE,EAAmFtN,KAAnF;;AACA,SAAKuL,WAAL,GAAmB,IAAItc,KAAJ,CAAU+Q,KAAV,CAAnB;;AACA,QAAIoO,WAAW,GAAG,KAAK7C,WAAL,CAAiBjT,OAAjB,EAAlB;;AACA,SAAKkV,iBAAL,GAAyBY,WAAzB;;AACA,SAAK7C,WAAL,CAAiBL,QAAjB,CAA0B;AACtB1S,MAAAA,UAAU,EAAEpG,OAAO,CAACoG,UADE;AAEtB1F,MAAAA,QAAQ,EAAEV,OAAO,CAACU,QAFI;AAGtBD,MAAAA,QAAQ,EAAET,OAAO,CAAC3D,IAHI;AAItB0d,MAAAA,IAAI,EAAE/Z,OAAO,CAACY,aAJQ;AAKtBqb,MAAAA,MAAM,EAAEjc,OAAO,CAACkc;AALM,KAA1B;;AAOA,SAAKrD,kCAAL,CAAwC,KAAKM,WAA7C;;AACA,QAAI,CAAC/H,UAAL,EAAiB;AACb,UAAI,CAAClV,SAAS,CAAC,KAAKid,WAAL,CAAiBhb,GAAlB,CAAV,IAAoC,CAACjC,SAAS,CAAC,KAAKid,WAAL,CAAiBlb,GAAlB,CAAlD,EAA0E;AACtE,YAAIqb,WAAW,GAAG,KAAKC,WAAL,EAAlB;AACAD,QAAAA,WAAW,IAAI,KAAKH,WAAL,CAAiBL,QAAjB,CAA0B;AACrC3a,UAAAA,GAAG,EAAEmb,WAAW,CAAC5L,UADoB;AAErCzP,UAAAA,GAAG,EAAEqb,WAAW,CAAC3L;AAFoB,SAA1B,CAAf;AAIH;;AACD,UAAIwO,iBAAiB,GAAGnc,OAAO,CAACmc,iBAAhC;;AACA,UAAIjgB,SAAS,CAACigB,iBAAD,CAAb,EAAkC;AAC9B,aAAKhD,WAAL,CAAiBL,QAAjB,CAA0B;AACtB3a,UAAAA,GAAG,EAAEge,iBADiB;AAEtBle,UAAAA,GAAG,EAAEke;AAFiB,SAA1B;AAIH;AACJ;;AACD,SAAKhD,WAAL,CAAiBrL,UAAjB,GAA8B,UAAUgO,qBAAqB,GAAG,KAAK3C,WAAL,CAAiBrL,UAAnD,KAAkE,KAAK,CAAL,KAAWgO,qBAA7E,GAAqGA,qBAArG,GAA6H,KAAK3C,WAAL,CAAiBhb,GAA5K;AACA,SAAKgb,WAAL,CAAiBpL,UAAjB,GAA8B,UAAUgO,qBAAqB,GAAG,KAAK5C,WAAL,CAAiBpL,UAAnD,KAAkE,KAAK,CAAL,KAAWgO,qBAA7E,GAAqGA,qBAArG,GAA6H,KAAK5C,WAAL,CAAiBlb,GAA5K;;AACA,QAAI,CAAC,KAAKsK,cAAN,IAAwBvI,OAAO,CAACoc,QAApC,EAA8C;AAC1C,WAAKjD,WAAL,CAAiBkD,qBAAjB;AACH;;AACD,SAAKlD,WAAL,CAAiBmD,cAAjB,CAAgC,KAAKC,mBAAL,CAAyBV,aAAzB,CAAhC;;AACA,SAAK1C,WAAL,CAAiBqD,UAAjB,GAA8B,KAAKrD,WAAL,CAAiBjT,OAAjB,KAA6B,EAA7B,GAAkC,KAAKuW,eAAL,CAAqBzc,OAArB,EAA8B,KAAKmZ,WAAnC,EAAgD,KAAKuD,OAArD,EAA8D,KAAKnU,cAAnE,CAAhE;;AACA,SAAKF,WAAL,CAAiBsU,mBAAjB,CAAqC,KAAKnJ,iBAAL,EAArC;AACH,GAz1BY;;AA01BbgG,EAAAA,wBAAwB,CAACoD,SAAD,EAAYC,aAAZ,EAA2BC,aAA3B,EAA0C;AAC9D,SAAKlE,qBAAL,CAA2BrD,MAA3B,CAAkC,KAAKwH,oBAAL,IAA6B,EAA/D,EAAmEra,OAAnE,CAA2Esa,EAAE,IAAI;AAC7E,UAAIA,EAAE,CAAChd,OAAH,CAAWid,UAAf,EAA2B;AACvB,YAAI3Q,KAAK,GAAG0Q,EAAE,CAACE,cAAH,EAAZ;AACAN,QAAAA,SAAS,CAAC9D,QAAV,CAAmB;AACf,WAAC+D,aAAD,GAAiBvQ,KADF;AAEf,WAACwQ,aAAD,GAAiBxQ;AAFF,SAAnB;AAIH;AACJ,KARD;AASH,GAp2BY;;AAq2Bb6Q,EAAAA,cAAc,EAAE,UAASC,MAAT,EAAiB;AAC7B,SAAKV,OAAL,GAAeU,MAAf;AACH,GAv2BY;AAw2BbC,EAAAA,iBAAiB,EAAE,YAAW;AAC1B,QAAIrd,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIhF,QAAQ,GAAGhE,OAAO,CAACgE,QAAvB;AACA,QAAIsZ,UAAU,GAAGtd,OAAO,CAAC+D,KAAR,CAAc+M,cAAd,IAAgC,KAAK0H,UAAL,IAAmB,CAAnD,IAAwD,KAAK+E,oBAA9E;AACA,QAAIjM,YAAY,GAAG,KAAKC,aAAxB;AACA,WAAOvN,QAAQ,KAAKvF,GAAb,IAAoBuF,QAAQ,KAAKnF,IAAjC,GAAwCyS,YAAY,GAAGgM,UAAvD,GAAoEhM,YAAY,GAAGgM,UAA1F;AACH,GA92BY;AA+2BbE,EAAAA,iBAAiB,EAAE,UAASlR,KAAT,EAAgBtM,OAAhB,EAAyBuT,KAAzB,EAAgC;AAC/C,QAAIzP,YAAY,GAAG,KAAKkF,QAAL,CAAcjF,KAAjC;AACA,WAAO7H,SAAS,CAACoQ,KAAD,CAAT,GAAmB,KAAKiB,WAAL,CAAiBjB,KAAjB,EAAwB/P,MAAM,CAAC,IAAD,EAAO,EAAP,EAAWuH,YAAX,EAAyB9D,OAAzB,CAA9B,EAAiE,KAAK,CAAtE,EAAyEuT,KAAzE,CAAnB,GAAqG,IAA5G;AACH,GAl3BY;AAm3BbkK,EAAAA,iBAAiB,EAAE,UAASC,MAAT,EAAiB7X,QAAjB,EAA2B;AAC1C,QAAIvC,MAAM,GAAGoa,MAAM,CAACpa,MAApB;AACA,QAAItD,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAI2U,YAAY,GAAG3d,OAAO,CAAC4d,gBAA3B;AACA,QAAIzf,GAAG,GAAG0H,QAAQ,CAACiI,UAAnB;AACA,QAAI7P,GAAG,GAAG4H,QAAQ,CAACkI,UAAnB;AACA,QAAI8P,SAAS,GAAG7d,OAAO,CAACoC,uBAAR,GAAkC,KAAK0b,wBAAvC,GAAkE,EAAlF;AACA,QAAIC,aAAa,GAAG,EAApB;;AACA,QAAI/d,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAAC4c,QAA/B,EAAyC;AACrC,UAAI,KAAK7E,WAAL,IAAoB,MAAMqJ,MAAM,CAACpa,MAArC,EAA6C;AACzCya,QAAAA,aAAa,GAAG,CAACL,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAACA,MAAM,CAACpa,MAAP,GAAgB,CAAjB,CAAlB,CAAhB;AACH;AACJ,KAJD,MAIO,IAAIqa,YAAJ,EAAkB;AACrB,UAAIE,SAAS,CAAC1f,GAAV,IAAiBjC,SAAS,CAACyhB,YAAY,CAAC,CAAD,CAAb,CAA9B,EAAiD;AAC7CI,QAAAA,aAAa,CAAC5P,IAAd,CAAmBwP,YAAY,CAAC,CAAD,CAA/B;AACH;;AACD,UAAIE,SAAS,CAAC5f,GAAV,IAAiB/B,SAAS,CAACyhB,YAAY,CAAC,CAAD,CAAb,CAA9B,EAAiD;AAC7CI,QAAAA,aAAa,CAAC5P,IAAd,CAAmBwP,YAAY,CAAC,CAAD,CAA/B;AACH;AACJ,KAPM,MAOA;AACH,UAAIE,SAAS,CAAC1f,GAAV,KAAkB,MAAMmF,MAAN,IAAgBoa,MAAM,CAAC,CAAD,CAAN,GAAYvf,GAA9C,CAAJ,EAAwD;AACpD4f,QAAAA,aAAa,CAAC5P,IAAd,CAAmBhQ,GAAnB;AACH;;AACD,UAAI0f,SAAS,CAAC5f,GAAV,KAAkB,MAAMqF,MAAN,IAAgBoa,MAAM,CAACpa,MAAM,GAAG,CAAV,CAAN,GAAqBrF,GAAvD,CAAJ,EAAiE;AAC7D8f,QAAAA,aAAa,CAAC5P,IAAd,CAAmBlQ,GAAnB;AACH;AACJ;;AACD,WAAO8f,aAAP;AACH,GA/4BY;AAg5BbC,EAAAA,qBAAqB,EAAE,YAAW;AAC9B,QAAI,CAAC,KAAK5G,eAAV,EAA2B;AACvB,WAAKpO,QAAL,CAAcjF,KAAd,CAAoBsT,MAApB,GAA6B,SAA7B;AACH;AACJ,GAp5BY;AAq5Bb4G,EAAAA,oBAAoB,EAAE,YAAW;AAC7B,QAAI,CAAC,KAAK7G,eAAV,EAA2B;AACvB,aAAO,KAAKpO,QAAL,CAAcjF,KAAd,CAAoBsT,MAA3B;AACH;AACJ,GAz5BY;AA05Bb6G,EAAAA,sBAAsB,EAAE,YAAW;AAC/B,WAAO,KAAKlV,QAAL,CAAcmV,mBAAd,IAAqC,CAA5C;AACH,GA55BY;AA65BbC,EAAAA,cAAc,EAAE,YAAW;AACvB,WAAO;AACHC,MAAAA,gBAAgB,EAAE1gB,oBAAoB,CAAC,KAAKuS,WAAN,CADnC;AAEHoO,MAAAA,gBAAgB,EAAE3gB,oBAAoB,CAAC,KAAK0Y,WAAN;AAFnC,KAAP;AAIH,GAl6BY;AAm6BbkI,EAAAA,oBAAoB,EAAE,UAAS1T,MAAT,EAAiB;AACnC,SAAKqN,YAAL,CAAkBrN,MAAlB;AACA,WAAO,KAAK8I,aAAL,KAAuB,KAAK6K,SAAL,CAAe,KAAKhL,iBAAL,EAAf,EAAyCtW,KAAzC,EAAgD,IAAhD,EAAsD8I,YAApF;AACH,GAt6BY;AAu6BbyY,EAAAA,QAAQ,EAAE,UAAS5b,KAAT,EAAgB;AACtB,QAAI6a,MAAM,GAAG7a,KAAK,CAAC6b,UAAN,IAAoB,EAAjC;AACA,SAAKxO,WAAL,GAAmBwN,MAAM,CAACpI,GAAP,CAAW3T,eAAe,CAAC,IAAD,EAAO,KAAKkF,SAAZ,EAAuB,KAAK8X,mBAAL,CAAyBjB,MAAzB,CAAvB,CAA1B,CAAnB;AACA,SAAKrH,WAAL,GAAmB,CAACxT,KAAK,CAAC+b,UAAN,IAAoB,EAArB,EAAyBtJ,GAAzB,CAA6BrT,eAAe,CAAC,IAAD,EAAO,KAAK4E,SAAZ,CAA5C,CAAnB;AACA,SAAKgY,eAAL,GAAuB,IAAvB;AACH,GA56BY;AA66BbC,EAAAA,qBAAqB,EAAE,UAASC,GAAT,EAAc;AACjC,WAAOA,GAAP;AACH,GA/6BY;AAg7BbP,EAAAA,SAAS,EAAE,UAAS3Y,QAAT,EAAmB5F,gBAAnB,EAAqCC,kBAArC,EAAyD;AAChE,QAAIF,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIgW,WAAW,GAAGhf,OAAO,CAACgf,WAA1B;AACA,QAAIC,gBAAgB,GAAGjf,OAAO,CAACif,gBAA/B;AACA,WAAOlf,gBAAgB,CAACC,OAAD,EAAUC,gBAAgB,IAAI,KAAK6G,iBAAnC,EAAsD5G,kBAAtD,EAA0E,KAAKmI,WAAL,CAAiBwP,gBAAjB,GAAoC3R,OAApC,EAA1E,EAAyH,KAAK4Y,qBAAL,CAA2BI,IAA3B,CAAgC,IAAhC,CAAzH,EAAgKrZ,QAAhK,CAAhB,CAA0L;AAC7L1H,MAAAA,GAAG,EAAE0H,QAAQ,CAACiI,UAD+K;AAE7L7P,MAAAA,GAAG,EAAE4H,QAAQ,CAACkI,UAF+K;AAG7L3H,MAAAA,UAAU,EAAEP,QAAQ,CAACO,UAHwK;AAI7LC,MAAAA,cAAc,EAAER,QAAQ,CAACQ;AAJoK,KAA1L,EAKJ,KAAK8Y,eAAL,EALI,EAKoBnf,OAAO,CAACgG,YAL5B,EAK0C,aAAahG,OAAO,CAAC+D,KAAR,CAAcqb,mBAA3B,IAAkDpf,OAAO,CAACqf,qBALpG,EAK2H;AAC9H3B,MAAAA,MAAM,EAAEsB,WADsH;AAE9HM,MAAAA,MAAM,EAAEL;AAFsH,KAL3H,EAQJjf,OAAO,CAACuf,iBARJ,EAQuBvf,OAAO,CAACwf,cAR/B,EAQ+C,KAAKC,cARpD,CAAP;AASH,GA77BY;AA87BbC,EAAAA,0BAA0B,EAAE,UAAS9R,KAAT,EAAgB3N,gBAAhB,EAAkC;AAC1D,QAAID,OAAO,GAAG,KAAKgJ,QAAnB;;AACA,QAAInG,KAAK,GAAG,KAAK2b,SAAL,CAAe5Q,KAAf,EAAsB3N,gBAAtB,EAAwC,KAAxC,CAAZ;;AACA,QAAI,CAAC2N,KAAK,CAAC1H,OAAN,EAAD,IAAoBlG,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAAC4c,QAA/C,IAA2D,eAAelZ,OAAO,CAACU,QAAlF,IAA8F,CAAC,KAAK0W,eAApG,IAAuHvU,KAAK,CAACA,KAAN,CAAYS,MAAvI,EAA+I;AAC3ItD,MAAAA,OAAO,CAAC+D,KAAR,CAAcsT,MAAd,GAAuB5a,YAAY,CAACkjB,oBAAb,CAAkC9c,KAAK,CAACA,KAAxC,CAAvB;AACH;;AACD,WAAOA,KAAP;AACH,GAr8BY;;AAs8Bb+c,EAAAA,kBAAkB,CAACC,sBAAD,EAAyBjS,KAAzB,EAAgC;AAC9C,QAAIkS,qBAAJ,EAA2BC,qBAA3B,EAAkDC,iBAAlD;;AACA,QAAIhgB,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIiX,aAAa,GAAG,KAAKC,cAAzB;AACA,QAAIjH,aAAa,GAAG,IAAIpc,KAAJ,CAAU,KAAKka,aAAL,GAAqBc,gBAArB,EAAV,EAAmDiB,QAAnD,CAA4DlL,KAA5D,CAApB;AACA,QAAI0L,WAAW,GAAG,KAAKC,WAAL,EAAlB;AACA,QAAIzL,UAAU,GAAG,UAAUgS,qBAAqB,GAAG,SAASxG,WAAT,IAAwB,KAAK,CAAL,KAAWA,WAAnC,GAAiD,KAAK,CAAtD,GAA0DA,WAAW,CAAC5L,UAAxG,KAAuH,KAAK,CAAL,KAAWoS,qBAAlI,GAA0JA,qBAA1J,GAAkL7G,aAAa,CAACnL,UAAjN;AACA,QAAIC,UAAU,GAAG,UAAUgS,qBAAqB,GAAG,SAASzG,WAAT,IAAwB,KAAK,CAAL,KAAWA,WAAnC,GAAiD,KAAK,CAAtD,GAA0DA,WAAW,CAAC3L,QAAxG,KAAqH,KAAK,CAAL,KAAWoS,qBAAhI,GAAwJA,qBAAxJ,GAAgL9G,aAAa,CAAClL,UAA/M;AACA,QAAIlL,KAAK,GAAG,EAAZ;;AACA,QAAI7C,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAAC4c,QAA3B,IAAuClZ,OAAO,CAACmgB,mBAAnD,EAAwE;AACpE,aAAO;AACHA,QAAAA,mBAAmB,EAAE;AADlB,OAAP;AAGH;;AACD,QAAIC,mBAAmB,GAAGpgB,OAAO,CAACogB,mBAAlC;AACA,QAAIC,qBAAqB,GAAGrgB,OAAO,CAACqgB,qBAApC;;AACA,QAAI,CAACA,qBAAD,IAA0BJ,aAA9B,EAA6C;AACzC,UAAIA,aAAa,CAACK,aAAlB,EAAiC;AAC7BD,QAAAA,qBAAqB,GAAGrgB,OAAO,CAACa,kBAAhC;AACH;;AACD,UAAIof,aAAa,CAACM,oBAAlB,EAAwC;AACpCF,QAAAA,qBAAqB,GAAGxiB,IAAI,CAACM,GAAL,CAAS8hB,aAAa,CAACM,oBAAvB,EAA6CvgB,OAAO,CAACa,kBAArD,CAAxB;AACH;AACJ;;AACD,QAAI2f,WAAW,GAAG,CAACxgB,OAAO,CAACqgB,qBAAT,IAAkC,CAACD,mBAAnC,IAA0DxS,KAAK,CAACsG,QAAlF;AACA,QAAIuM,aAAa,GAAG7a,kBAAkB,CAAC5F,OAAD,EAAUqgB,qBAAV,EAAiCpH,aAAjC,EAAgD,KAAKkG,eAAL,EAAhD,EAAwEqB,WAAxE,CAAtC;AACA,QAAIxa,YAAY,GAAGya,aAAa,CAACL,mBAAD,EAAsB,IAAtB,EAA4BtS,UAA5B,EAAwCC,UAAxC,EAAoD,UAAUiS,iBAAiB,GAAG,KAAK7G,WAAnC,KAAmD,KAAK,CAAL,KAAW6G,iBAA9D,GAAkF,KAAK,CAAvF,GAA2FA,iBAAiB,CAAC/Z,MAAjK,CAAb,CAAsLD,YAAzM;;AACA,QAAIhG,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAAC4c,QAA/B,EAAyC;AACrC,UAAI/a,GAAG,GAAG0hB,sBAAsB,GAAG5G,aAAa,CAAC9a,GAAjB,GAAuB2P,UAAvD;AACA,UAAI7P,GAAG,GAAG4hB,sBAAsB,GAAG5G,aAAa,CAAChb,GAAjB,GAAuB8P,UAAvD;;AACA,UAAI7R,SAAS,CAACiC,GAAD,CAAT,IAAkBjC,SAAS,CAAC+B,GAAD,CAA/B,EAAsC;AAClC,YAAIyiB,GAAG,GAAG1kB,cAAc,CAAC;AACrB+d,UAAAA,IAAI,EAAE/Z,OAAO,CAACY,aADO;AAErBH,UAAAA,QAAQ,EAAET,OAAO,CAAC3D,IAFG;AAGrBqE,UAAAA,QAAQ,EAAEV,OAAO,CAACU;AAHG,SAAD,EAIrB,KAJqB,CAAxB;AAKA,YAAI+F,KAAK,GAAGtI,GAAZ;AACA,YAAIuI,GAAG,GAAGzI,GAAV;;AACA,YAAI,CAAC4hB,sBAAL,EAA6B;AACzB,cAAIc,cAAc,GAAG9iB,IAAI,CAACI,GAAL,CAAS,KAAK0Z,iBAAL,CAAuB1Z,GAAvB,EAA4BE,GAA5B,CAAT,EAA2C,eAAe6B,OAAO,CAACU,QAAvB,GAAkC1D,SAAS,CAAC4jB,kBAAV,CAA6B5a,YAA7B,CAAlC,GAA+EA,YAA1H,CAArB;AACAS,UAAAA,KAAK,GAAGia,GAAG,CAACviB,GAAD,EAAMwiB,cAAN,EAAsB,CAAC,CAAvB,CAAX;AACAja,UAAAA,GAAG,GAAGga,GAAG,CAACziB,GAAD,EAAM0iB,cAAN,CAAT;AACH;;AACDla,QAAAA,KAAK,GAAGA,KAAK,GAAGwS,aAAa,CAAC9a,GAAtB,GAA4B8a,aAAa,CAAC9a,GAA1C,GAAgDsI,KAAxD;AACAC,QAAAA,GAAG,GAAGA,GAAG,GAAGuS,aAAa,CAAChb,GAApB,GAA0Bgb,aAAa,CAAChb,GAAxC,GAA8CyI,GAApD;;AACA,YAAIT,MAAM,GAAG,KAAKwW,eAAL,CAAqBzc,OAArB,EAA8B;AACvC8N,UAAAA,UAAU,EAAErH,KAD2B;AAEvCsH,UAAAA,UAAU,EAAErH;AAF2B,SAA9B,EAGV,KAAKgW,OAHK,EAGI,KAAKnU,cAHT,CAAb;;AAIA,YAAIsY,cAAc,GAAG,KAAKC,aAAL,CAAmB7a,MAAnB,EAA2B;AAC5C6H,UAAAA,UAAU,EAAErH,KADgC;AAE5CsH,UAAAA,UAAU,EAAErH;AAFgC,SAA3B,EAGlB1G,OAAO,CAAC+gB,UAHU,CAArB;;AAIAle,QAAAA,KAAK,GAAG4d,aAAa,CAACza,YAAD,EAAe,KAAf,EAAsBS,KAAtB,EAA6BC,GAA7B,EAAkCma,cAAlC,CAAb,CAA+Dhe,KAAvE;AACH;AACJ;;AACD,SAAKme,oBAAL,GAA4Bhb,YAA5B;AACA,WAAO;AACHkO,MAAAA,QAAQ,EAAElO,YADP;AAEHnD,MAAAA,KAAK,EAAEA;AAFJ,KAAP;AAIH,GAngCY;;AAogCboe,EAAAA,eAAe,GAAG;AACd,WAAO,KAAKtN,aAAZ;AACH,GAtgCY;;AAugCbuN,EAAAA,sBAAsB,GAAG;AACrB,WAAO,KAAKF,oBAAZ;AACH,GAzgCY;;AA0gCbG,EAAAA,WAAW,EAAE,UAAStW,MAAT,EAAiB;AAC1B,QAAIM,IAAI,GAAG,IAAX;AACA,QAAItJ,QAAQ,GAAGsJ,IAAI,CAACtE,SAApB;AACA,QAAI7G,OAAO,GAAGmL,IAAI,CAACnC,QAAnB;;AACA,QAAI,CAAC6B,MAAL,EAAa;AACT;AACH;;AACDM,IAAAA,IAAI,CAAC0T,eAAL,GAAuB,KAAvB;AACA1T,IAAAA,IAAI,CAAC+M,YAAL,CAAkBrN,MAAlB;;AACA,QAAI+C,KAAK,GAAGzC,IAAI,CAACqI,iBAAL,EAAZ;;AACArI,IAAAA,IAAI,CAACsU,cAAL,GAAsB7R,KAAK,CAAC3H,MAAN,GAAe,KAAKkT,WAAL,CAAiBlT,MAAjB,GAA0BkF,IAAI,CAAC2V,aAAL,CAAmB,KAAK3H,WAAL,CAAiBqD,UAApC,EAAgD5O,KAAhD,EAAuD5N,OAAO,CAAC+gB,UAA/D,CAA/D;AACA5V,IAAAA,IAAI,CAACiW,sBAAL,GAA8BjW,IAAI,CAACqT,SAAL,CAAerT,IAAI,CAAC6N,cAAL,CAAoB,KAAKG,WAAzB,CAAf,EAAsDjc,KAAtD,EAA6D,IAA7D,EAAmE8I,YAAjG;;AACA,QAAIwP,OAAO,GAAG,KAAK6L,sBAAL,EAAd;;AACAzT,IAAAA,KAAK,CAACkL,QAAN,CAAe;AACXhL,MAAAA,UAAU,EAAE0H,OAAO,CAAC8L,QADT;AAEXvT,MAAAA,UAAU,EAAEyH,OAAO,CAAC+L,QAFT;AAGXlb,MAAAA,cAAc,EAAEmP,OAAO,CAACnP;AAHb,KAAf;;AAKA,QAAIxD,KAAK,GAAGsI,IAAI,CAACuU,0BAAL,CAAgC9R,KAAhC,CAAZ;;AACA,QAAImQ,aAAa,GAAG5S,IAAI,CAACsS,iBAAL,CAAuB5a,KAAK,CAACA,KAA7B,EAAoCsI,IAAI,CAACqI,iBAAL,EAApC,CAApB;;AACA,QAAIxT,OAAO,CAACoC,uBAAR,IAAmC2b,aAAa,CAACza,MAArD,EAA6D;AACzD6H,MAAAA,IAAI,CAACqW,cAAL,GAAsB,CAACzD,aAAa,CAAC,CAAD,CAAd,EAAmBzI,GAAnB,CAAuBpT,kBAAkB,CAACiJ,IAAD,EAAOtJ,QAAP,EAAiB,IAAjB,CAAzC,CAAtB;;AACA,UAAIkc,aAAa,CAACza,MAAd,GAAuB,CAA3B,EAA8B;AAC1B6H,QAAAA,IAAI,CAACqW,cAAL,GAAsBrW,IAAI,CAACqW,cAAL,CAAoBjM,MAApB,CAA2B,CAACwI,aAAa,CAAC,CAAD,CAAd,EAAmBzI,GAAnB,CAAuBpT,kBAAkB,CAACiJ,IAAD,EAAOtJ,QAAP,EAAiB,KAAjB,CAAzC,CAA3B,CAAtB;AACH;AACJ,KALD,MAKO;AACHsJ,MAAAA,IAAI,CAACqW,cAAL,GAAsB,EAAtB;AACH;;AACD,QAAIlC,MAAM,GAAG,CAACzc,KAAK,CAAC+b,UAAN,IAAoB,EAArB,EAAyB6C,MAAzB,CAAiC,UAASC,KAAT,EAAgB;AAC1D,aAAO,CAAC3D,aAAa,CAAC4D,IAAd,CAAoB,UAASC,QAAT,EAAmB;AAC3C,eAAOhmB,OAAO,CAACgmB,QAAD,CAAP,KAAsBhmB,OAAO,CAAC8lB,KAAD,CAApC;AACH,OAFO,CAAR;AAGH,KAJY,CAAb;AAKAvW,IAAAA,IAAI,CAACwI,aAAL,GAAqB9Q,KAAK,CAACmD,YAA3B;AACAmF,IAAAA,IAAI,CAAC0W,kBAAL,GAA0Bhf,KAAK,CAAC0c,iBAAhC;AACA,QAAIuC,aAAa,GAAG3W,IAAI,CAAC+E,WAAL,IAAoB,EAAxC;AACA,QAAI6R,kBAAkB,GAAGD,aAAa,CAAC9T,MAAd,CAAqB,CAACgU,CAAD,EAAIC,CAAJ,KAAU;AACpDD,MAAAA,CAAC,CAACC,CAAC,CAAC3V,KAAF,CAAQ1Q,OAAR,EAAD,CAAD,GAAuBqmB,CAAvB;AACA,aAAOD,CAAP;AACH,KAHwB,EAGtB,EAHsB,CAAzB;AAIA,QAAIE,QAAQ,GAAG7lB,IAAI,CAACwG,KAAK,CAACA,KAAN,CAAY,CAAZ,CAAD,CAAJ,KAAyBxG,IAAI,CAACylB,aAAa,CAAC,CAAD,CAAb,IAAoBA,aAAa,CAAC,CAAD,CAAb,CAAiBxV,KAAtC,CAA5C;;AACA,QAAIxK,eAAe,GAAGqJ,IAAI,CAACwT,mBAAL,CAAyB9b,KAAK,CAACA,KAA/B,CAAtB;;AACA,QAAI6b,UAAU,GAAG7b,KAAK,CAACA,KAAN,CAAYyS,GAAZ,CAAgBnP,CAAC,IAAI;AAClC,UAAIrJ,IAAI,GAAGilB,kBAAkB,CAAC5b,CAAC,CAACvK,OAAF,EAAD,CAA7B;;AACA,UAAIkB,IAAI,IAAIolB,QAAZ,EAAsB;AAClB,eAAOH,kBAAkB,CAAC5b,CAAC,CAACvK,OAAF,EAAD,CAAzB;AACAkB,QAAAA,IAAI,CAACqlB,kBAAL,CAAwBrgB,eAAxB;AACA,eAAOhF,IAAP;AACH,OAJD,MAIO;AACH,eAAO6E,eAAe,CAACwJ,IAAD,EAAOtJ,QAAP,EAAiBC,eAAjB,CAAf,CAAiDqE,CAAjD,CAAP;AACH;AACJ,KATgB,CAAjB;AAUAgF,IAAAA,IAAI,CAAC+E,WAAL,GAAmBwO,UAAnB;AACA,QAAI0D,aAAa,GAAGjX,IAAI,CAACkL,WAAL,IAAoB,EAAxC;AACAlL,IAAAA,IAAI,CAACkL,WAAL,GAAmBiJ,MAAM,CAAChK,GAAP,CAAW,CAACnP,CAAD,EAAI9C,CAAJ,KAAU;AACpC,UAAIpC,SAAS,GAAGmhB,aAAa,CAAC/e,CAAD,CAA7B;;AACA,UAAIpC,SAAJ,EAAe;AACXA,QAAAA,SAAS,CAACohB,WAAV,CAAsBlc,CAAtB;AACA,eAAOlF,SAAP;AACH;;AACD,aAAOgB,eAAe,CAACkJ,IAAD,EAAOtJ,QAAP,CAAf,CAAgCsE,CAAhC,CAAP;AACH,KAPkB,CAAnB;AAQAgF,IAAAA,IAAI,CAACmX,cAAL,GAAsBC,MAAM,CAACC,IAAP,CAAYT,kBAAZ,EAAgCzM,GAAhC,CAAoCmN,CAAC,IAAIV,kBAAkB,CAACU,CAAD,CAA3D,EAAgElN,MAAhE,CAAuE6M,aAAa,CAACM,KAAd,CAAoBvX,IAAI,CAACkL,WAAL,CAAiB/S,MAArC,EAA6C8e,aAAa,CAAC9e,MAA3D,CAAvE,CAAtB;;AACA6H,IAAAA,IAAI,CAACmX,cAAL,CAAoB5f,OAApB,CAA4Buf,CAAC,IAAI;AAC7B,UAAIU,QAAJ;;AACA,aAAO,UAAUA,QAAQ,GAAGV,CAAC,CAACle,KAAvB,KAAiC,KAAK,CAAL,KAAW4e,QAA5C,GAAuD,KAAK,CAA5D,GAAgEA,QAAQ,CAACC,WAAT,EAAvE;AACH,KAHD;;AAIA,QAAI/f,KAAK,CAACoD,MAAV,EAAkB;AACdkF,MAAAA,IAAI,CAACgO,WAAL,CAAiBlT,MAAjB,GAA0BpD,KAAK,CAACoD,MAAhC;AACH;;AACDkF,IAAAA,IAAI,CAAC0X,iBAAL,CAAuB1X,IAAI,CAACqI,iBAAL,EAAvB;AACH,GAjlCY;AAklCbqP,EAAAA,iBAAiB,EAAE,UAASjV,KAAT,EAAgB;AAC/B,QAAImK,UAAU,GAAG,KAAK1P,WAAtB;;AACA,QAAI,KAAKwW,eAAT,EAA0B;AACtB;AACH;;AACD9G,IAAAA,UAAU,CAAC4E,mBAAX,CAA+B/O,KAA/B;AACH,GAxlCY;;AAylCb4F,EAAAA,iBAAiB,GAAG;AAChB,WAAO,KAAKwF,cAAL,CAAoB,KAAKG,WAAzB,CAAP;AACH,GA3lCY;;AA4lCb2J,EAAAA,gBAAgB,EAAE,UAAS9iB,OAAT,EAAkB;AAChC,SAAKkgB,cAAL,GAAsBlgB,OAAtB;AACH,GA9lCY;;AA+lCb+iB,EAAAA,gBAAgB,GAAG;AACf,QAAIC,oBAAJ;;AACA,WAAO,UAAUA,oBAAoB,GAAG,KAAK9C,cAAtC,KAAyD,KAAK,CAAL,KAAW8C,oBAApE,GAA2FA,oBAA3F,GAAkH,EAAzH;AACH,GAlmCY;;AAmmCbC,EAAAA,uBAAuB,EAAE,UAAS/O,QAAT,EAAmB;AACxC,QAAIgP,UAAU,GAAG,eAAe,KAAKla,QAAL,CAActI,QAA9C;AACA,QAAIyiB,OAAO,GAAG,EAAd;;AACA,QAAIC,SAAS,GAAG,UAAS9W,KAAT,EAAgB;AAC5BpQ,MAAAA,SAAS,CAACoQ,KAAD,CAAT,IAAoB6W,OAAO,CAAChV,IAAR,CAAa+U,UAAU,GAAGlmB,SAAS,CAAC4jB,kBAAV,CAA6BtU,KAA7B,CAAH,GAAyCA,KAAhE,CAApB;AACH,KAFD;;AAGA8W,IAAAA,SAAS,CAAC,KAAKzP,aAAN,CAAT;AACAyP,IAAAA,SAAS,CAAC,KAAKhC,sBAAN,CAAT;AACAllB,IAAAA,SAAS,CAACgY,QAAD,CAAT,IAAuBiP,OAAO,CAAChV,IAAR,CAAa+F,QAAb,CAAvB;AACAkP,IAAAA,SAAS,CAAC,KAAKpC,oBAAN,CAAT;AACA,WAAO,KAAKqC,0BAAL,CAAgCnlB,IAAI,CAAColB,KAAL,CAAW,IAAX,EAAiBH,OAAjB,CAAhC,CAAP;AACH,GA9mCY;;AA+mCbE,EAAAA,0BAA0B,CAACE,gBAAD,EAAmB;AACzC,QAAIvjB,OAAO,GAAG,KAAKgJ,QAAnB;;AACA,QAAI,eAAehJ,OAAO,CAACU,QAAvB,IAAmCV,OAAO,CAACwjB,YAA3C,IAA2DD,gBAA/D,EAAiF;AAC7E,UAAIhiB,QAAQ,GAAGvB,OAAO,CAACuB,QAAR,CAAiB+B,MAAjB,GAA0B1D,aAAa,CAACC,GAAvD;AACA,UAAI4jB,OAAO,GAAG7jB,aAAa,CAACE,IAAd,GAAqByB,QAAnC;;AACA,UAAIA,QAAQ,KAAKgiB,gBAAb,IAAiCE,OAAO,GAAGF,gBAA/C,EAAiE;AAC7D,YAAIG,aAAa,GAAG7lB,IAAI,CAAC6d,IAAL,CAAU6H,gBAAgB,GAAG3jB,aAAa,CAACE,IAA3C,CAApB;AACAyjB,QAAAA,gBAAgB,IAAIE,OAAO,GAAGC,aAA9B;AACH,OAHD,MAGO,IAAID,OAAO,IAAIF,gBAAX,IAA+BA,gBAAgB,GAAG3jB,aAAa,CAACC,GAApE,EAAyE;AAC5E0jB,QAAAA,gBAAgB,GAAG3jB,aAAa,CAACC,GAAjC;AACH;AACJ;;AACD,WAAO0jB,gBAAP;AACH,GA5nCY;;AA6nCbI,EAAAA,8BAA8B,CAACC,YAAD,EAAe9d,WAAf,EAA4B;AACtD,QAAI+d,kBAAkB,GAAG,KAAKxb,WAAL,CAAiBwb,kBAAjB,EAAzB;;AACA,WAAOA,kBAAkB,IAAIA,kBAAkB,GAAG/d,WAArB,IAAoC8d,YAAY,GAAG9d,WAAnD,CAAJ,CAAzB;AACH,GAhoCY;;AAioCbub,EAAAA,sBAAsB,CAACxe,KAAD,EAAQ;AAC1B,SAAKihB,aAAL;;AACA,QAAItO,OAAO,GAAG,KAAKuN,gBAAL,EAAd;AACA,QAAIgB,UAAU,GAAG,CAACvO,OAAO,CAAChF,IAAR,IAAgB,CAAjB,IAAsB,CAAvC;AACA,QAAIxQ,OAAO,GAAG,KAAKgJ,QAAnB;;AACA,QAAI4T,SAAS,GAAG,KAAKpJ,iBAAL,EAAhB;;AACA,QAAI3N,QAAQ,GAAG,KAAK0T,WAAL,EAAf;;AACA,QAAIzT,WAAW,GAAG,KAAKqZ,eAAL,EAAlB;;AACA,QAAI/N,UAAU,GAAG,CAAC,CAAD,KAAO,CAACpR,OAAO,CAAC3D,IAAR,IAAgB,EAAjB,EAAqBme,OAArB,CAA6Ble,SAAS,CAAC4c,QAAvC,CAAxB;AACA,QAAI8K,mBAAmB,GAAGhkB,OAAO,CAACgkB,mBAAR,IAA+B,CAAC5S,UAAhC,IAA8C,CAAC,KAAK1G,sCAAL,EAAzE;AACA,QAAIqN,UAAU,GAAG,KAAK1P,WAAtB;AACA,QAAI4b,cAAc,GAAGjkB,OAAO,CAACikB,cAA7B;AACA,QAAIC,cAAc,GAAGlkB,OAAO,CAACkkB,cAA7B;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIlQ,QAAQ,GAAG,CAAf;AACA,QAAImQ,aAAJ;;AACA,QAAIzH,SAAS,CAAC0H,QAAV,IAAsB,CAACxe,WAA3B,EAAwC;AACpC,aAAO;AACHye,QAAAA,YAAY,EAAE,CADX;AAEHC,QAAAA,UAAU,EAAE;AAFT,OAAP;AAIH;;AACD,QAAI,KAAKjc,cAAL,IAAuBiN,OAAO,CAAC8K,aAAnC,EAAkD;AAC9C+D,MAAAA,aAAa,GAAG,KAAKpB,uBAAL,CAA6BrG,SAAS,CAAC1I,QAAvC,CAAhB;AACA,UAAIuQ,UAAU,GAAG1M,UAAU,CAAC2M,WAAX,CAAuBL,aAAvB,CAAjB;;AACA,UAAIM,QAAQ,CAACF,UAAD,CAAZ,EAA0B;AACtBvQ,QAAAA,QAAQ,GAAGrW,IAAI,CAAC6d,IAAL,CAAU+I,UAAU,IAAI,IAAI,KAAKd,8BAAL,CAAoCc,UAApC,EAAgD3e,WAAhD,CAAR,CAApB,CAAX;AACH,OAFD,MAEO;AACHue,QAAAA,aAAa,GAAG,CAAhB;AACH;AACJ;;AACD,QAAIO,iBAAJ;AACA,QAAIC,iBAAJ;AACA,QAAIC,eAAe,GAAGhf,WAAW,GAAGnG,gBAAd,GAAiC,CAAvD;;AACA,QAAIqkB,mBAAJ,EAAyB;AACrB,UAAI9nB,SAAS,CAAC+nB,cAAD,CAAb,EAA+B;AAC3BW,QAAAA,iBAAiB,GAAGD,QAAQ,CAACV,cAAD,CAAR,GAA2BA,cAA3B,GAA4C,CAAhE;AACH,OAFD,MAEO,IAAI,CAAC,KAAK1b,cAAN,IAAwBiN,OAAO,CAAC8K,aAAhC,IAAiD1kB,OAAO,CAACghB,SAAS,CAAC9O,UAAX,CAAP,GAAgC,CAAjF,IAAsFlS,OAAO,CAACghB,SAAS,CAAC9O,UAAX,CAAP,KAAkClS,OAAO,CAACghB,SAAS,CAACze,GAAX,CAAnI,EAAoJ;AACvJgmB,QAAAA,UAAU,GAAGzkB,cAAb;AACH,OAFM,MAEA;AACHykB,QAAAA,UAAU,GAAGtmB,IAAI,CAACI,GAAL,CAAS8lB,UAAT,EAAqB7P,QAArB,CAAb;AACAiQ,QAAAA,UAAU,GAAGtmB,IAAI,CAACM,GAAL,CAAS2mB,eAAT,EAA0BX,UAA1B,CAAb;AACH;;AACD,UAAIjoB,SAAS,CAACgoB,cAAD,CAAb,EAA+B;AAC3BW,QAAAA,iBAAiB,GAAGF,QAAQ,CAACT,cAAD,CAAR,GAA2BA,cAA3B,GAA4C,CAAhE;AACH,OAFD,MAEO,IAAI,CAAC,KAAK3b,cAAN,IAAwBiN,OAAO,CAAC8K,aAAhC,IAAiD1kB,OAAO,CAACghB,SAAS,CAAC7O,UAAX,CAAP,GAAgC,CAAjF,IAAsFnS,OAAO,CAACghB,SAAS,CAAC7O,UAAX,CAAP,KAAkCnS,OAAO,CAACghB,SAAS,CAAC3e,GAAX,CAAnI,EAAoJ;AACvJmmB,QAAAA,UAAU,GAAG1kB,cAAb;AACH,OAFM,MAEA;AACH0kB,QAAAA,UAAU,GAAGvmB,IAAI,CAACI,GAAL,CAAS8lB,UAAT,EAAqB7P,QAArB,CAAb;AACAkQ,QAAAA,UAAU,GAAGvmB,IAAI,CAACM,GAAL,CAAS2mB,eAAT,EAA0BV,UAA1B,CAAb;AACH;AACJ;;AACD,QAAIW,YAAY,GAAGvP,OAAO,CAACuP,YAAR,IAAwB,CAAC,KAAKxc,cAAjD;;AACA,QAAIwc,YAAJ,EAAkB;AACd,UAAI,MAAMjnB,IAAI,CAAC8e,SAAS,CAAC3e,GAAX,CAAd,EAA+B;AAC3BmmB,QAAAA,UAAU,GAAG,CAAb;AACH;;AACD,UAAI,MAAMtmB,IAAI,CAAC8e,SAAS,CAACze,GAAX,CAAd,EAA+B;AAC3BgmB,QAAAA,UAAU,GAAG,CAAb;AACH;AACJ;;AACD,QAAIa,cAAc,GAAG,KAAKla,kBAAL,EAArB;;AACA,QAAIma,YAAY,GAAG,KAAKL,iBAAiB,IAAI,CAA1B,KAAgCC,iBAAiB,IAAI,CAArD,CAAnB;AACA,QAAIK,sBAAsB,GAAG,CAACpf,WAAW,GAAGqe,UAAd,GAA2BC,UAA5B,IAA0Ca,YAA1C,IAA0Dnf,WAAvF;;AACA,QAAI,KAAK,CAAL,KAAW8e,iBAAX,IAAgC,KAAK,CAAL,KAAWC,iBAA/C,EAAkE;AAC9D,UAAI,KAAK,CAAL,KAAWD,iBAAf,EAAkC;AAC9BT,QAAAA,UAAU,GAAGe,sBAAsB,GAAGN,iBAAtC;AACH;;AACD,UAAI,KAAK,CAAL,KAAWC,iBAAf,EAAkC;AAC9BT,QAAAA,UAAU,GAAGc,sBAAsB,GAAGL,iBAAtC;AACH;AACJ;;AACD,QAAIvD,QAAJ;AACA,QAAIC,QAAJ;;AACA,QAAIvhB,OAAO,CAAC3D,IAAR,KAAiBC,SAAS,CAAC4c,QAA3B,IAAuCrW,KAAvC,IAAgDA,KAAK,CAACS,MAAN,GAAe,CAA/D,IAAoE,CAACtD,OAAO,CAACmlB,qBAA7E,IAAsG,CAACtf,QAAQ,CAACtD,MAAhH,IAA0H,UAAUvC,OAAO,CAACqB,SAAhJ,EAA2J;AACvJ,UAAIiC,MAAM,GAAGT,KAAK,CAACS,MAAnB;AACA,UAAI8hB,iBAAiB,GAAGrN,UAAU,CAACC,SAAX,CAAqBnV,KAAK,CAAC,CAAD,CAAL,CAASyJ,KAA9B,CAAxB;AACA,UAAI+Y,gBAAgB,GAAGtN,UAAU,CAACC,SAAX,CAAqBnV,KAAK,CAACS,MAAM,GAAG,CAAV,CAAL,CAAkBgJ,KAAvC,CAAvB;AACA,UAAIgZ,gBAAgB,GAAGF,iBAAiB,GAAGC,gBAApB,GAAuC,CAAC,CAAxC,GAA4C,CAAnE;;AACA,UAAIE,cAAc,GAAGvnB,IAAI,CAACsnB,gBAAgB,IAAIN,cAAc,CAACve,KAAf,GAAuB2e,iBAA3B,CAAjB,EAAgE,CAAhE,CAAzB;;AACA,UAAII,cAAc,GAAGxnB,IAAI,CAACsnB,gBAAgB,IAAID,gBAAgB,GAAGL,cAAc,CAACte,GAAtC,CAAjB,EAA6D,CAA7D,CAAzB;;AACA,UAAI6e,cAAc,GAAGpB,UAAjB,IAA+BqB,cAAc,GAAGpB,UAApD,EAAgE;AAC5D,YAAIqB,aAAa,GAAGD,cAAc,GAAGD,cAArC;;AACA,YAAIG,KAAK,GAAG,KAAK/B,8BAAL,CAAoC8B,aAApC,EAAmD3f,WAAnD,CAAZ;;AACA,YAAIyf,cAAc,IAAIpB,UAAtB,EAAkC;AAC9B7C,UAAAA,QAAQ,GAAGze,KAAK,CAAC,CAAD,CAAL,CAASyJ,KAApB;AACH;;AACD,YAAIkZ,cAAc,IAAIpB,UAAtB,EAAkC;AAC9B7C,UAAAA,QAAQ,GAAG1e,KAAK,CAACS,MAAM,GAAG,CAAV,CAAL,CAAkBgJ,KAA7B;AACH;;AACD6X,QAAAA,UAAU,GAAGnmB,IAAI,CAACunB,cAAD,EAAiBpB,UAAjB,CAAJ,GAAmCuB,KAAhD;AACAtB,QAAAA,UAAU,GAAGpmB,IAAI,CAACwnB,cAAD,EAAiBpB,UAAjB,CAAJ,GAAmCsB,KAAhD;AACH;AACJ;;AACDd,IAAAA,iBAAiB,GAAG,KAAK,CAAL,KAAWA,iBAAX,GAA+BT,UAAU,GAAGe,sBAA5C,GAAqEN,iBAAzF;AACAC,IAAAA,iBAAiB,GAAG,KAAK,CAAL,KAAWA,iBAAX,GAA+BT,UAAU,GAAGc,sBAA5C,GAAqEL,iBAAzF;;AACA,QAAI,CAACzT,UAAL,EAAiB;AACb,UAAI,KAAK/I,WAAL,CAAiBsd,UAAjB,EAAJ,EAAmC;AAC/B,YAAIC,SAAJ,EAAeC,SAAf;;AACAvE,QAAAA,QAAQ,GAAG,UAAUsE,SAAS,GAAGtE,QAAtB,KAAmC,KAAK,CAAL,KAAWsE,SAA9C,GAA0DA,SAA1D,GAAsE7N,UAAU,CAACrJ,IAAX,CAAgBsW,cAAc,CAACve,KAAf,GAAuBX,WAAW,GAAG8e,iBAArD,EAAwE,CAAC,CAAzE,CAAjF;AACArD,QAAAA,QAAQ,GAAG,UAAUsE,SAAS,GAAGtE,QAAtB,KAAmC,KAAK,CAAL,KAAWsE,SAA9C,GAA0DA,SAA1D,GAAsE9N,UAAU,CAACrJ,IAAX,CAAgBsW,cAAc,CAACte,GAAf,GAAqBZ,WAAW,GAAG+e,iBAAnD,EAAsE,CAAtE,CAAjF;AACH,OAJD,MAIO;AACH,YAAIiB,UAAJ,EAAgBC,UAAhB;;AACAzE,QAAAA,QAAQ,GAAG,UAAUwE,UAAU,GAAGxE,QAAvB,KAAoC,KAAK,CAAL,KAAWwE,UAA/C,GAA4DA,UAA5D,GAAyE/N,UAAU,CAACrJ,IAAX,CAAgBsW,cAAc,CAACve,KAAf,GAAuBX,WAAW,GAAG8e,iBAArD,EAAwE,CAAC,CAAzE,CAApF;AACArD,QAAAA,QAAQ,GAAG,UAAUwE,UAAU,GAAGxE,QAAvB,KAAoC,KAAK,CAAL,KAAWwE,UAA/C,GAA4DA,UAA5D,GAAyEhO,UAAU,CAACrJ,IAAX,CAAgBsW,cAAc,CAACte,GAAf,GAAqBZ,WAAW,GAAG+e,iBAAnD,EAAsE,CAAtE,CAApF;AACH;AACJ;;AACD,QAAI;AACAmB,MAAAA,YAAY,EAAEA,YADd;AAEAC,MAAAA,YAAY,EAAEA,YAFd;AAGAxf,MAAAA,KAAK,EAAEA,KAHP;AAIAC,MAAAA,GAAG,EAAEA;AAJL,QAKA,KAAKwf,wBAAL,CAA8B5E,QAA9B,EAAwCC,QAAxC,CALJ;AAMA4C,IAAAA,UAAU,GAAG,SAAS1d,KAAT,IAAkB,KAAK,CAAL,KAAWA,KAA7B,GAAqCA,KAArC,GAA6C0d,UAA1D;AACAC,IAAAA,UAAU,GAAG,SAAS1d,GAAT,IAAgB,KAAK,CAAL,KAAWA,GAA3B,GAAiCA,GAAjC,GAAuC0d,UAApD;AACA,WAAO;AACHG,MAAAA,YAAY,EAAExM,UAAU,CAAC4N,UAAX,KAA0BvB,UAA1B,GAAuCD,UADlD;AAEHK,MAAAA,UAAU,EAAEzM,UAAU,CAAC4N,UAAX,KAA0BxB,UAA1B,GAAuCC,UAFhD;AAGH9C,MAAAA,QAAQ,EAAE,SAAS0E,YAAT,IAAyB,KAAK,CAAL,KAAWA,YAApC,GAAmDA,YAAnD,GAAkE1E,QAHzE;AAIHC,MAAAA,QAAQ,EAAE,SAAS0E,YAAT,IAAyB,KAAK,CAAL,KAAWA,YAApC,GAAmDA,YAAnD,GAAkE1E,QAJzE;AAKHrN,MAAAA,QAAQ,EAAEmQ,aALP;AAMHhe,MAAAA,cAAc,EAAE8d,UAAU,KAAKC,UAAf,IAA6B,MAAMD;AANhD,KAAP;AAQH,GA7vCY;;AA8vCb+B,EAAAA,wBAAwB,CAAC5E,QAAD,EAAWC,QAAX,EAAqB;AACzC,QAAIpW,IAAI,GAAG,IAAX;AACA,QAAI4M,UAAU,GAAG5M,IAAI,CAAC9C,WAAtB;;AACA,QAAI2c,cAAc,GAAG7Z,IAAI,CAACL,kBAAL,EAArB;;AACA,QAAI8R,SAAS,GAAGzR,IAAI,CAACqI,iBAAL,EAAhB;;AACA,QAAI1N,WAAW,GAAGqF,IAAI,CAACgU,eAAL,EAAlB;;AACA,QAAInf,OAAO,GAAGmL,IAAI,CAACnC,QAAnB;AACA,QAAIvC,KAAJ;AACA,QAAIC,GAAJ;AACA,QAAIsf,YAAJ;AACA,QAAIC,YAAJ;;AACA,QAAIE,gBAAgB,GAAG,CAACvL,QAAD,EAAWE,QAAX,KAAwB;AAC3C,UAAIsL,kBAAkB,GAAGtoB,IAAI,CAACknB,cAAc,CAACve,KAAf,GAAuBmU,QAAxB,CAA7B;;AACA,UAAIyL,kBAAkB,GAAGvoB,IAAI,CAACknB,cAAc,CAACte,GAAf,GAAqBoU,QAAtB,CAA7B;;AACA,UAAI4K,KAAK,GAAGva,IAAI,CAACwY,8BAAL,CAAoCyC,kBAAkB,GAAGC,kBAAzD,EAA6EvgB,WAA7E,CAAZ;;AACAW,MAAAA,KAAK,GAAG2f,kBAAkB,GAAGV,KAA7B;AACAhf,MAAAA,GAAG,GAAG2f,kBAAkB,GAAGX,KAA3B;AACH,KAND;;AAOA,QAAI,CAACva,IAAI,CAAC5C,cAAN,IAAwB,eAAevI,OAAO,CAACU,QAAnD,EAA6D;AACzD,UAAI4gB,QAAQ,GAAG1E,SAAS,CAACze,GAArB,IAA4B,CAA5B,IAAiCmjB,QAAQ,GAAG1E,SAAS,CAAC9O,UAArB,IAAmC,CAAxE,EAA2E;AACvEqY,QAAAA,gBAAgB,CAACpO,UAAU,CAACC,SAAX,CAAqB,CAArB,CAAD,EAA0BD,UAAU,CAACC,SAAX,CAAqBuJ,QAArB,CAA1B,CAAhB;AACAyE,QAAAA,YAAY,GAAG,CAAf;AACH;;AACD,UAAIzE,QAAQ,GAAG3E,SAAS,CAAC3e,GAArB,IAA4B,CAA5B,IAAiCsjB,QAAQ,GAAG3E,SAAS,CAAC7O,UAArB,IAAmC,CAAxE,EAA2E;AACvEoY,QAAAA,gBAAgB,CAACpO,UAAU,CAACC,SAAX,CAAqBsJ,QAArB,CAAD,EAAiCvJ,UAAU,CAACC,SAAX,CAAqB,CAArB,CAAjC,CAAhB;AACAiO,QAAAA,YAAY,GAAG,CAAf;AACH;AACJ;;AACD,WAAO;AACHxf,MAAAA,KAAK,EAAEke,QAAQ,CAACle,KAAD,CAAR,GAAkBA,KAAlB,GAA0B,IAD9B;AAEHC,MAAAA,GAAG,EAAEie,QAAQ,CAACje,GAAD,CAAR,GAAgBA,GAAhB,GAAsB,IAFxB;AAGHsf,MAAAA,YAAY,EAAEA,YAHX;AAIHC,MAAAA,YAAY,EAAEA;AAJX,KAAP;AAMH,GAhyCY;;AAiyCbK,EAAAA,YAAY,GAAG;AACX,QAAI,KAAKzH,eAAT,EAA0B;AACtB;AACH;;AACD,QAAIrJ,OAAO,GAAG,KAAK6L,sBAAL,CAA4B,KAAKnR,WAAjC,CAAd;;AACA,QAAIrF,MAAM,GAAGtO,MAAM,CAAC,EAAD,EAAK,KAAK8b,OAAV,EAAmB;AAClCkM,MAAAA,YAAY,EAAE/O,OAAO,CAAC+O,YADY;AAElCC,MAAAA,UAAU,EAAEhP,OAAO,CAACgP;AAFc,KAAnB,CAAnB;;AAIA,SAAKnc,WAAL,CAAiB6P,YAAjB,CAA8B,KAAKD,cAAL,CAAoBpN,MAApB,CAA9B;;AACA,QAAI8Z,QAAQ,CAACnP,OAAO,CAACtB,QAAT,CAAZ,EAAgC;AAC5B,UAAIqS,EAAE,GAAG,KAAKle,WAAL,CAAiBwP,gBAAjB,EAAT;;AACA0O,MAAAA,EAAE,CAACzN,QAAH,CAAY;AACR5E,QAAAA,QAAQ,EAAEsB,OAAO,CAACtB;AADV,OAAZ;;AAGA,WAAK7L,WAAL,CAAiBsU,mBAAjB,CAAqC4J,EAArC;AACH;AACJ,GAlzCY;;AAmzCbzC,EAAAA,aAAa,EAAE,YAAW;AACtB,SAAKjB,iBAAL,CAAuB,KAAKrP,iBAAL,EAAvB;;AACA,QAAI,KAAK6E,OAAT,EAAkB;AACd,WAAKhQ,WAAL,CAAiB6P,YAAjB,CAA8B,KAAKD,cAAL,CAAoB,KAAKI,OAAzB,CAA9B;AACH;AACJ,GAxzCY;;AAyzCbb,EAAAA,oBAAoB,GAAG;AACnB,QAAIgP,aAAa,GAAG,CAAC,KAAKxd,QAAL,CAAcwd,aAAd,IAA+B,EAAhC,EAAoClR,GAApC,CAAwCoC,CAAC,IAAIra,kBAAkB,CAAC,IAAD,EAAOqa,CAAP,CAA/D,CAApB;AACA,SAAKkB,qBAAL,GAA6B4N,aAAa,CAAC/E,MAAd,CAAqBgF,CAAC,IAAI,cAAcA,CAAC,CAACriB,aAA1C,CAA7B;AACA,SAAK2Y,oBAAL,GAA4ByJ,aAAa,CAAC/E,MAAd,CAAqBgF,CAAC,IAAI,aAAaA,CAAC,CAACriB,aAAzC,CAA5B;AACH,GA7zCY;;AA8zCbsiB,EAAAA,IAAI,EAAE,UAAS7b,MAAT,EAAiBc,aAAjB,EAAgC;AAClC,QAAIR,IAAI,GAAG,IAAX;AACA,QAAInL,OAAO,GAAG,KAAKgJ,QAAnB;AACAmC,IAAAA,IAAI,CAACQ,aAAL,GAAqBA,aAAa,IAAI;AAClCzK,MAAAA,OAAO,EAAE;AADyB,KAAtC;;AAGAiK,IAAAA,IAAI,CAAC2Y,aAAL;;AACA3Y,IAAAA,IAAI,CAACgW,WAAL,CAAiBtW,MAAjB;AACAM,IAAAA,IAAI,CAACmb,YAAL;;AACAnb,IAAAA,IAAI,CAACgI,gBAAL;;AACAvQ,IAAAA,cAAc,CAACuI,IAAI,CAAC+E,WAAN,CAAd;AACAtN,IAAAA,cAAc,CAACuI,IAAI,CAACkL,WAAN,CAAd;AACAzT,IAAAA,cAAc,CAACuI,IAAI,CAACqW,cAAN,CAAd;;AACArW,IAAAA,IAAI,CAACoH,UAAL,CAAgB3I,MAAhB,CAAuBuB,IAAI,CAACxD,mBAA5B;;AACAwD,IAAAA,IAAI,CAACpC,SAAL;;AACAoC,IAAAA,IAAI,CAACwb,UAAL;;AACA7jB,IAAAA,aAAa,CAACqI,IAAI,CAAC+E,WAAN,EAAmBlQ,OAAO,CAAClD,IAA3B,CAAb;AACAgG,IAAAA,aAAa,CAACqI,IAAI,CAACkL,WAAN,EAAmBrW,OAAO,CAACiB,SAA3B,CAAb;AACA6B,IAAAA,aAAa,CAACqI,IAAI,CAACqW,cAAN,EAAsBxhB,OAAO,CAAClD,IAA9B,CAAb;;AACA,QAAI8pB,YAAY,GAAGzb,IAAI,CAACD,kBAAL,EAAnB;;AACAnI,IAAAA,SAAS,CAACoI,IAAI,CAAC+E,WAAN,EAAmB0W,YAAnB,CAAT;AACA7jB,IAAAA,SAAS,CAACoI,IAAI,CAACkL,WAAN,EAAmBuQ,YAAnB,CAAT;AACAvkB,IAAAA,UAAU,CAAC8I,IAAI,CAAC+E,WAAN,EAAmB,WAAnB,EAAgC/E,IAAI,CAACqI,iBAAL,EAAhC,EAA0DrI,IAAI,CAACxC,YAAL,CAAkB3I,OAAO,CAAC+D,KAAR,CAAcqP,QAAhC,CAA1D,CAAV;AACAjI,IAAAA,IAAI,CAACmL,kBAAL,IAA2BnL,IAAI,CAACmL,kBAAL,CAAwBC,MAAxB,EAA3B;AACApL,IAAAA,IAAI,CAACmL,kBAAL,GAA0B,IAAI/Y,QAAJ,EAA1B;AACAC,IAAAA,IAAI,CAAC8lB,KAAL,CAAW,IAAX,EAAiBnY,IAAI,CAAC+E,WAAL,CAAiBoF,GAAjB,CAAqBxY,IAAI,IAAIA,IAAI,CAAC+pB,mBAAL,EAA7B,CAAjB,EAA2EC,IAA3E,CAAgF,MAAM;AAClF3b,MAAAA,IAAI,CAACmL,kBAAL,CAAwByQ,OAAxB;AACH,KAFD;;AAGA5b,IAAAA,IAAI,CAAC+E,WAAL,CAAiBxN,OAAjB,CAA0B,UAAS5F,IAAT,EAAe;AACrCA,MAAAA,IAAI,CAAC4T,kBAAL,GAA0B,CAA1B;AACA5T,MAAAA,IAAI,CAACqU,cAAL,GAAsB,KAAK,CAA3B;AACArU,MAAAA,IAAI,CAACmT,WAAL,GAAmB,CAAnB;AACH,KAJD;;AAKA5N,IAAAA,UAAU,CAAC8I,IAAI,CAACyN,qBAAL,CAA2BrD,MAA3B,CAAkCpK,IAAI,CAAC4R,oBAAvC,CAAD,EAA+D,MAA/D,CAAV;AACA1a,IAAAA,UAAU,CAAC8I,IAAI,CAACqE,OAAN,EAAe,MAAf,CAAV;AACArE,IAAAA,IAAI,CAAC6b,YAAL,GAAoB7b,IAAI,CAAC8b,gBAAL,MAA2B,EAA/C;AACA9b,IAAAA,IAAI,CAAChE,oBAAL,IAA6BgE,IAAI,CAAC+H,oBAAL,CAA0BtJ,MAA1B,CAAiCuB,IAAI,CAAChE,oBAAtC,CAA7B;AACAgE,IAAAA,IAAI,CAACtD,mBAAL,IAA4BsD,IAAI,CAACuH,cAAL,CAAoB9I,MAApB,CAA2BuB,IAAI,CAACtD,mBAAhC,CAA5B;AACAsD,IAAAA,IAAI,CAAClE,YAAL,IAAqBkE,IAAI,CAACsH,eAAL,CAAqB7I,MAArB,CAA4BuB,IAAI,CAAClE,YAAjC,CAArB;AACAkE,IAAAA,IAAI,CAAC9D,gBAAL,IAAyB8D,IAAI,CAACwH,kBAAL,CAAwB/I,MAAxB,CAA+BuB,IAAI,CAAC9D,gBAApC,CAAzB;;AACA,QAAI8D,IAAI,CAAC5D,mBAAT,EAA8B;AAC1B4D,MAAAA,IAAI,CAAC4H,uBAAL,CAA6BC,KAA7B,CAAmCd,MAAnC,CAA0CtI,MAA1C,CAAiDuB,IAAI,CAAC5D,mBAAL,CAAyByL,KAA1E;;AACA7H,MAAAA,IAAI,CAAC4H,uBAAL,CAA6BC,KAA7B,CAAmCb,QAAnC,CAA4CvI,MAA5C,CAAmDuB,IAAI,CAAC5D,mBAAL,CAAyByL,KAA5E;;AACA7H,MAAAA,IAAI,CAAC4H,uBAAL,CAA6BC,KAA7B,CAAmCZ,QAAnC,CAA4CxI,MAA5C,CAAmDuB,IAAI,CAAC5D,mBAAL,CAAyByL,KAA5E;;AACA7H,MAAAA,IAAI,CAAC4H,uBAAL,CAA6BE,KAA7B,CAAmCf,MAAnC,CAA0CtI,MAA1C,CAAiDuB,IAAI,CAAC5D,mBAAL,CAAyB0L,KAA1E;;AACA9H,MAAAA,IAAI,CAAC4H,uBAAL,CAA6BE,KAA7B,CAAmCd,QAAnC,CAA4CvI,MAA5C,CAAmDuB,IAAI,CAAC5D,mBAAL,CAAyB0L,KAA5E;;AACA9H,MAAAA,IAAI,CAAC4H,uBAAL,CAA6BE,KAA7B,CAAmCb,QAAnC,CAA4CxI,MAA5C,CAAmDuB,IAAI,CAAC5D,mBAAL,CAAyB0L,KAA5E;AACH;;AACD9H,IAAAA,IAAI,CAAC+b,aAAL;;AACAxpB,IAAAA,aAAa,CAACyN,IAAI,CAAC+E,WAAN,CAAb;AACA,KAAClQ,OAAO,CAAC+D,KAAR,CAAcqP,QAAf,IAA2BjI,IAAI,CAACgc,cAAL,EAA3B;AACAzpB,IAAAA,aAAa,CAACyN,IAAI,CAACyN,qBAAN,CAAb;AACAlb,IAAAA,aAAa,CAACyN,IAAI,CAAC4R,oBAAN,CAAb;AACArf,IAAAA,aAAa,CAACyN,IAAI,CAACqE,OAAN,CAAb;AACA9R,IAAAA,aAAa,CAACyN,IAAI,CAAC6b,YAAN,CAAb;;AACA7b,IAAAA,IAAI,CAACic,yBAAL,CAA+Bjc,IAAI,CAAC4R,oBAApC;;AACA5R,IAAAA,IAAI,CAACoE,kBAAL;;AACA,QAAIK,MAAM,GAAGzE,IAAI,CAACoS,oBAAL,GAA4BpS,IAAI,CAACic,yBAAL,CAA+Bjc,IAAI,CAACyN,qBAApC,CAAzC;;AACA,QAAI,CAACzN,IAAI,CAAC9C,WAAL,CAAiBwP,gBAAjB,GAAoC3R,OAApC,EAAL,EAAoD;AAChDiF,MAAAA,IAAI,CAACkc,mBAAL;;AACAzX,MAAAA,MAAM,GAAGzE,IAAI,CAACkF,aAAL,CAAmBT,MAAnB,CAAT;AACH;;AACDA,IAAAA,MAAM,GAAGzE,IAAI,CAACmc,kBAAL,CAAwB1X,MAAxB,CAAT;;AACAzE,IAAAA,IAAI,CAACoc,YAAL,CAAkB3X,MAAlB;AACH,GA93CY;;AA+3Cb4X,EAAAA,eAAe,GAAG;AACd,WAAO,KAAKlR,kBAAZ;AACH,GAj4CY;;AAk4CbmR,EAAAA,gBAAgB,CAACC,KAAD,EAAQ;AACpB,SAAKC,MAAL,GAAcD,KAAd;AACH,GAp4CY;;AAq4CbrU,EAAAA,UAAU,GAAG;AACT,WAAO,KAAKsU,MAAZ;AACH,GAv4CY;;AAw4CbR,EAAAA,cAAc,GAAG;AACb,QAAIS,qBAAJ;AACA,QAAIC,SAAJ;AACA,QAAIC,UAAJ;AACA,QAAI9nB,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAIhD,YAAY,GAAG,KAAK2N,aAAxB;;AACA,QAAIzX,SAAS,CAAC8J,YAAD,CAAb,EAA6B;AACzB4hB,MAAAA,qBAAqB,GAAG,KAAK7Q,aAAL,GAAqB2N,WAArB,CAAiC,eAAe1kB,OAAO,CAACU,QAAvB,GAAkC1D,SAAS,CAAC4jB,kBAAV,CAA6B5a,YAA7B,CAAlC,GAA+EA,YAAhH,CAAxB;AACH;;AACD,QAAI+hB,WAAW,GAAG,KAAKC,oBAAL,CAA0BhoB,OAAO,CAAC+D,KAAR,CAAcgkB,WAAxC,CAAlB;;AACA,QAAIE,eAAe,GAAG,KAAKC,wBAAL,CAA8BloB,OAAO,CAAC+D,KAAR,CAAcqb,mBAA5C,EAAiE2I,WAAjE,CAAtB;;AACA,QAAII,YAAY,GAAGnoB,OAAO,CAAC+D,KAAR,CAAcqkB,QAAd,IAA0B,MAA7C;AACA,QAAIC,YAAY,GAAGroB,OAAO,CAAC+D,KAAR,CAAcukB,YAAd,IAA8B,MAAjD;;AACA,QAAI,CAAC,WAAWH,YAAX,IAA2B,WAAWE,YAAvC,KAAwDN,WAAW,KAAKzoB,MAAxE,IAAkF2oB,eAAe,KAAK3oB,MAAtG,IAAgH,WAAW2oB,eAA/H,EAAgJ;AAC5I,UAAIM,WAAW,GAAGrsB,SAAS,CAAC8D,OAAO,CAAC2U,eAAT,CAAT,GAAqC3U,OAAO,CAAC2U,eAAR,GAA0B3U,OAAO,CAAC+D,KAAR,CAAc+M,cAA7E,GAA8F,KAAK,CAArH;;AACA,UAAI,KAAK7F,aAAT,EAAwB;AACpB4c,QAAAA,SAAS,GAAGD,qBAAZ;AACAE,QAAAA,UAAU,GAAGS,WAAb;AACH,OAHD,MAGO;AACHV,QAAAA,SAAS,GAAGU,WAAZ;AACAT,QAAAA,UAAU,GAAGF,qBAAb;AACH;;AACD,UAAIY,cAAc,GAAG,KAArB;AACA,UAAIC,eAAe,GAAG,KAAtB;;AACA,UAAIZ,SAAJ,EAAe;AACX,YAAI,KAAK3X,WAAL,CAAiByR,IAAjB,CAAsB7kB,IAAI,IAAIA,IAAI,CAAC6T,SAAL,CAAetH,KAAf,GAAuBwe,SAArD,CAAJ,EAAqE;AACjEW,UAAAA,cAAc,GAAG,IAAjB;AACH;AACJ;;AACD,UAAIV,UAAJ,EAAgB;AACZ,YAAI,KAAK5X,WAAL,CAAiByR,IAAjB,CAAsB7kB,IAAI,IAAIA,IAAI,CAAC6T,SAAL,CAAe1L,MAAf,GAAwB6iB,UAAtD,CAAJ,EAAuE;AACnEW,UAAAA,eAAe,GAAG,IAAlB;AACH;AACJ;;AACD,UAAID,cAAc,IAAIC,eAAtB,EAAuC;AACnC,aAAKvY,WAAL,CAAiBxN,OAAjB,CAAyB5F,IAAI,IAAI;AAC7BA,UAAAA,IAAI,CAACiH,KAAL,IAAcjH,IAAI,CAACiH,KAAL,CAAW2kB,UAAX,CAAsBb,SAAtB,EAAiCC,UAAjC,EAA6C9nB,OAAO,CAAC+D,KAArD,CAAd;AACH,SAFD;;AAGArG,QAAAA,aAAa,CAAC,KAAKwS,WAAN,CAAb;AACH;AACJ;AACJ,GAj7CY;;AAk7CbgX,EAAAA,aAAa,EAAEhqB,KAl7CF;;AAm7CbgG,EAAAA,OAAO,GAAG;AACNb,IAAAA,UAAU,CAAC,KAAK6N,WAAN,EAAmB,eAAnB,CAAV;AACH,GAr7CY;;AAs7CbyY,EAAAA,UAAU,CAAC9d,MAAD,EAAS3H,OAAT,EAAkB;AACxB,QAAI0lB,WAAW,GAAGze,SAAS,CAAC7G,MAAV,GAAmB,CAAnB,IAAwB,KAAK,CAAL,KAAW6G,SAAS,CAAC,CAAD,CAA5C,GAAkDA,SAAS,CAAC,CAAD,CAA3D,GAAiE,IAAnF;AACA,SAAK+N,YAAL,CAAkBrN,MAAlB;;AACA,QAAI+d,WAAJ,EAAiB;AACb,WAAKC,mBAAL;;AACA,WAAK3B,aAAL;;AACA,WAAK4B,kBAAL;AACH;;AACD,SAAKjG,iBAAL,CAAuB,KAAKrP,iBAAL,EAAvB;;AACA,SAAK8S,YAAL;AACA,QAAIyC,gBAAgB,GAAG,CAAC,KAAKtgB,aAAN,IAAuBvF,OAA9C;AACA,QAAIlD,OAAO,GAAG,KAAKgJ,QAAnB;AACApG,IAAAA,cAAc,CAAC,KAAKsN,WAAN,CAAd;AACAtN,IAAAA,cAAc,CAAC,KAAKyT,WAAN,CAAd;AACAzT,IAAAA,cAAc,CAAC,KAAK4e,cAAN,CAAd;;AACA,QAAI,KAAKhN,uBAAL,IAAgC,CAAC,KAAK/L,aAA1C,EAAyD;AACrD,WAAKugB,sBAAL;AACH;;AACD5lB,IAAAA,mBAAmB,CAAC,KAAK8M,WAAN,CAAnB;AACA9M,IAAAA,mBAAmB,CAAC,KAAKiT,WAAN,CAAnB;AACAjT,IAAAA,mBAAmB,CAAC,KAAKoe,cAAN,CAAnB;;AACA,QAAI,KAAKvY,YAAT,EAAuB;AACnB,WAAKE,0BAAL;AACH;;AACDlG,IAAAA,mBAAmB,CAAC,KAAKiN,WAAN,EAAmBlQ,OAAO,CAAClD,IAA3B,EAAiCisB,gBAAjC,CAAnB;AACA9lB,IAAAA,mBAAmB,CAAC,KAAKoT,WAAN,EAAmBrW,OAAO,CAACiB,SAA3B,EAAsC8nB,gBAAtC,CAAnB;AACA9lB,IAAAA,mBAAmB,CAAC,KAAKue,cAAN,EAAsBxhB,OAAO,CAAClD,IAA9B,CAAnB;AACAuF,IAAAA,UAAU,CAAC,KAAK6N,WAAN,EAAmB,qBAAnB,EAA0C6Y,gBAA1C,CAAV;;AACA,SAAKnQ,qBAAL,CAA2BrD,MAA3B,CAAkC,KAAKwH,oBAAL,IAA6B,EAA/D,EAAmEra,OAAnE,CAA2E+jB,CAAC,IAAIA,CAAC,CAACwC,cAAF,CAAiBF,gBAAjB,CAAhF;;AACA1mB,IAAAA,UAAU,CAAC,KAAKmN,OAAN,EAAe,gBAAf,EAAiCuZ,gBAAjC,CAAV;AACA5lB,IAAAA,mBAAmB,CAAC,KAAK+M,WAAN,EAAmB6Y,gBAAnB,CAAnB;AACA5lB,IAAAA,mBAAmB,CAAC,KAAKkT,WAAN,EAAmB0S,gBAAnB,CAAnB;;AACA,QAAIA,gBAAJ,EAAsB;AAClB1mB,MAAAA,UAAU,CAAC,KAAKigB,cAAL,IAAuB,EAAxB,EAA4B,iBAA5B,CAAV;AACH;;AACD,SAAK4G,gBAAL;AACA,SAAK5G,cAAL,GAAsB,IAAtB;;AACA,QAAI,CAAC,KAAKja,WAAL,CAAiBwP,gBAAjB,GAAoC3R,OAApC,EAAL,EAAoD;AAChD,WAAKuC,aAAL,GAAqB,KAArB;AACH;;AACD,SAAK+L,uBAAL,GAA+B,KAA/B;;AACA,SAAK2U,qBAAL;AACH,GAh+CY;;AAi+CbA,EAAAA,qBAAqB,EAAEjsB,KAj+CV;;AAk+CbgsB,EAAAA,gBAAgB,GAAG;AACf,QAAI3mB,MAAM,GAAG,YAAb;AACAF,IAAAA,UAAU,CAAC,KAAK6N,WAAN,EAAmB3N,MAAnB,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAKgU,WAAN,EAAmB9T,MAAnB,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAK0a,oBAAN,EAA4Bxa,MAA5B,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAKuW,qBAAN,EAA6BrW,MAA7B,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAKmN,OAAN,EAAejN,MAAf,CAAV;AACH,GAz+CY;;AA0+CbymB,EAAAA,sBAAsB,GAAG;AACrB,QAAIzmB,MAAM,GAAG,kBAAb;AACAF,IAAAA,UAAU,CAAC,KAAK6N,WAAN,EAAmB3N,MAAnB,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAKgU,WAAN,EAAmB9T,MAAnB,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAK0a,oBAAN,EAA4Bxa,MAA5B,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAKuW,qBAAN,EAA6BrW,MAA7B,CAAV;AACAF,IAAAA,UAAU,CAAC,KAAKmN,OAAN,EAAejN,MAAf,CAAV;AACH,GAj/CY;;AAk/Cb6mB,EAAAA,cAAc,EAAE,UAASC,cAAT,EAAyBC,YAAzB,EAAuC;AACnD,SAAK/W,UAAL,CAAgBnJ,IAAhB,CAAqB;AACjB,mBAAakgB;AADI,KAArB;;AAGA,SAAK7W,eAAL,CAAqBrJ,IAArB,CAA0B;AACtB,mBAAaigB;AADS,KAA1B;;AAGA,SAAK1W,kBAAL,CAAwBvJ,IAAxB,CAA6B;AACzB,mBAAakgB;AADY,KAA7B;AAGH,GA5/CY;;AA6/CbC,EAAAA,oBAAoB,CAAC7jB,WAAD,EAAc;AAC9B,QAAIkI,KAAK,GAAGrS,iBAAiB,CAACmK,WAAD,CAA7B;;AACA,QAAI,KAAK,CAAL,KAAWkI,KAAK,CAACF,UAArB,EAAiC;AAC7BE,MAAAA,KAAK,CAACF,UAAN,GAAmB,KAAKmB,YAAL,CAAkBjB,KAAK,CAACF,UAAxB,CAAnB;AACH;;AACD,QAAI,KAAK,CAAL,KAAWE,KAAK,CAACD,QAArB,EAA+B;AAC3BC,MAAAA,KAAK,CAACD,QAAN,GAAiB,KAAKkB,YAAL,CAAkBjB,KAAK,CAACD,QAAxB,CAAjB;AACH;;AACD,WAAO1R,wBAAwB,CAAC2R,KAAD,EAAQ,CAACxP,QAAQ,CAACsH,WAAD,CAAjB,CAA/B;AACH,GAtgDY;;AAugDb8jB,EAAAA,gBAAgB,CAACxpB,OAAD,EAAU;AACtBA,IAAAA,OAAO,CAACoZ,UAAR,GAAqB,KAAKmQ,oBAAL,CAA0BvpB,OAAO,CAACoZ,UAAlC,CAArB;AACApZ,IAAAA,OAAO,CAACsZ,WAAR,GAAsBtZ,OAAO,CAACypB,kBAAR,GAA6B,KAAKF,oBAAL,CAA0BvpB,OAAO,CAACypB,kBAAlC,CAAnD;;AACA,SAAKpO,eAAL,CAAqBrb,OAAO,CAACypB,kBAA7B;AACH,GA3gDY;;AA4gDbC,EAAAA,QAAQ,GAAG;AACP,QAAI1pB,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAItI,QAAQ,GAAG,KAAK6H,cAAL,GAAsBvI,OAAO,CAAC0E,YAA9B,GAA6C1E,OAAO,CAAC2E,SAApE;AACA,QAAI6J,MAAM,GAAG9N,QAAQ,GAAGhE,SAAS,CAACgE,QAAD,CAAZ,GAAyB,UAASiV,IAAT,EAAe;AACzD,aAAOA,IAAP;AACH,KAFD;AAGA,SAAKnH,MAAL,GAAcA,MAAd;AACAxO,IAAAA,OAAO,CAACU,QAAR,GAAmBA,QAAnB;;AACA,SAAK8oB,gBAAL,CAAsBxpB,OAAtB;AACH,GArhDY;;AAshDb2pB,EAAAA,gBAAgB,CAACC,QAAD,EAAW;AACvB,SAAKzQ,WAAL,CAAiBrL,UAAjB,GAA8B,KAAKqL,WAAL,CAAiBhb,GAA/C;AACA,SAAKgb,WAAL,CAAiBpL,UAAjB,GAA8B,KAAKoL,WAAL,CAAiBlb,GAA/C;AACA,SAAK4rB,aAAL,CAAmB,CAAC,IAAD,EAAO,IAAP,CAAnB,EAAiC;AAC7BpjB,MAAAA,KAAK,EAAE,CAAC,CAACmjB,QADoB;AAE7BljB,MAAAA,GAAG,EAAE,CAAC,CAACkjB;AAFsB,KAAjC;AAIH,GA7hDY;;AA8hDbvO,EAAAA,eAAe,CAAC/B,WAAD,EAAcwQ,kBAAd,EAAkC;AAC7C,QAAIlc,KAAK,GAAG,KAAKyL,WAAL,CAAiB9d,iBAAiB,CAAC+d,WAAD,CAAlC,CAAZ;;AACA,QAAIwQ,kBAAJ,EAAwB;AACpB5tB,MAAAA,SAAS,CAAC0R,KAAK,CAACF,UAAP,CAAT,KAAgC,KAAKlF,SAAL,CAAekF,UAAf,GAA4BE,KAAK,CAACF,UAAlE;AACAxR,MAAAA,SAAS,CAAC0R,KAAK,CAACD,QAAP,CAAT,KAA8B,KAAKnF,SAAL,CAAemF,QAAf,GAA0BC,KAAK,CAACD,QAA9D;AACH,KAHD,MAGO;AACH,WAAKnF,SAAL,GAAiBoF,KAAjB;AACH;AACJ,GAtiDY;;AAuiDbmc,EAAAA,aAAa,CAACzQ,WAAD,EAAcwQ,kBAAd,EAAkC;AAC3C,SAAKE,uBAAL;;AACA,SAAK3O,eAAL,CAAqB/B,WAArB,EAAkCwQ,kBAAlC;;AACA,QAAIjkB,QAAQ,GAAG,KAAK0T,WAAL,EAAf;AACA,SAAKJ,WAAL,CAAiBqD,UAAjB,GAA8B,KAAKC,eAAL,CAAqB,KAAKzT,QAA1B,EAAoC;AAC9D8E,MAAAA,UAAU,EAAEjI,QAAQ,CAAC6H,UADyC;AAE9DK,MAAAA,UAAU,EAAElI,QAAQ,CAAC8H;AAFyC,KAApC,EAG3B,KAAK+O,OAHsB,EAGb,KAAKnU,cAHQ,CAA9B;;AAIA,SAAKF,WAAL,CAAiBsU,mBAAjB,CAAqC,KAAKnJ,iBAAL,EAArC;AACH,GAhjDY;;AAijDbyW,EAAAA,oBAAoB,CAACC,KAAD,EAAQC,UAAR,EAAoB;AACpC,WAAO;AACHvoB,MAAAA,IAAI,EAAE,IADH;AAEHgM,MAAAA,KAAK,EAAE,KAAK0L,WAAL,EAFJ;AAGH8Q,MAAAA,MAAM,EAAE,KAHL;AAIHF,MAAAA,KAAK,EAAEA,KAJJ;AAKHC,MAAAA,UAAU,EAAEA;AALT,KAAP;AAOH,GAzjDY;;AA0jDbE,EAAAA,mBAAmB,CAACC,aAAD,EAAgBJ,KAAhB,EAAuBC,UAAvB,EAAmCI,UAAnC,EAA+CC,KAA/C,EAAsD;AACrE,QAAInQ,QAAQ,GAAG,KAAKf,WAAL,EAAf;AACA,WAAO;AACH1X,MAAAA,IAAI,EAAE,IADH;AAEH0oB,MAAAA,aAAa,EAAEA,aAFZ;AAGH1c,MAAAA,KAAK,EAAEyM,QAHJ;AAIH+P,MAAAA,MAAM,EAAE,KAJL;AAKHF,MAAAA,KAAK,EAAEA,KALJ;AAMHC,MAAAA,UAAU,EAAEA,UANT;AAOHI,MAAAA,UAAU,EAAEA,UAPT;AAQHC,MAAAA,KAAK,EAAEA,KARJ;AASHC,MAAAA,UAAU,EAAEpQ,QAAQ,CAAC3M,UATlB;AAUHgd,MAAAA,QAAQ,EAAErQ,QAAQ,CAAC1M;AAVhB,KAAP;AAYH,GAxkDY;;AAykDbgd,EAAAA,aAAa,GAAG;AACZ,QAAIvR,UAAU,GAAG7d,iBAAiB,CAAC,KAAKyN,QAAL,CAAcoQ,UAAf,CAAlC;AACA,QAAIxL,KAAK,GAAG,KAAKmJ,aAAL,GAAqBc,gBAArB,EAAZ;AACA,QAAI+S,mBAAmB,GAAG;AACtBld,MAAAA,UAAU,EAAEjI,iBAAiB,CAAC,KAAKiD,UAAL,CAAgBgF,UAAjB,EAA6BE,KAAK,CAACzP,GAAnC,CADP;AAEtBwP,MAAAA,QAAQ,EAAElI,iBAAiB,CAAC,KAAKiD,UAAL,CAAgBiF,QAAjB,EAA2BC,KAAK,CAAC3P,GAAjC;AAFL,KAA1B;AAIA,WAAO;AACHyP,MAAAA,UAAU,EAAEjI,iBAAiB,CAAC2T,UAAU,CAAC1L,UAAZ,EAAwBkd,mBAAmB,CAACld,UAA5C,CAD1B;AAEHC,MAAAA,QAAQ,EAAElI,iBAAiB,CAAC2T,UAAU,CAACzL,QAAZ,EAAsBid,mBAAmB,CAACjd,QAA1C;AAFxB,KAAP;AAIH,GAplDY;;AAqlDbkd,EAAAA,YAAY,GAAG;AACX,SAAKniB,UAAL,GAAkB,EAAlB;;AACA,QAAI,MAAM6Z,MAAM,CAACC,IAAP,CAAY,KAAKxZ,QAAL,CAAcoQ,UAAd,IAA4B,EAAxC,EAA4C9V,MAAtD,EAA8D;AAC1D,WAAKoF,UAAL,GAAkB,KAAKiiB,aAAL,EAAlB;AACH;AACJ,GA1lDY;;AA2lDbX,EAAAA,uBAAuB,GAAG;AACtB,SAAKhhB,QAAL,CAAcygB,kBAAd,GAAmC,EAAnC;AACH,GA7lDY;;AA8lDbqB,EAAAA,kBAAkB,GAAG;AACjB,QAAIjoB,KAAK,GAAG,KAAKqN,WAAjB;;AACA,QAAIrN,KAAJ,EAAW;AACP,aAAO,KAAKqN,WAAL,CAAiBoF,GAAjB,CAAqBxY,IAAI,IAAIA,IAAI,CAACsT,iBAAlC,EAAqDqR,MAArD,CAA4DsJ,IAAI,IAAI7uB,SAAS,CAAC6uB,IAAD,CAA7E,CAAP;AACH,KAFD,MAEO;AACH,aAAO,EAAP;AACH;AACJ,GArmDY;;AAsmDbC,EAAAA,oBAAoB,CAACpd,KAAD,EAAQ;AACxB,SAAK5E,QAAL,CAAcygB,kBAAd,GAAmC7b,KAAnC;AACH,GAxmDY;;AAymDb0L,EAAAA,WAAW,GAAG;AACV,QAAI2R,IAAI,GAAG9gB,SAAX;AACA,QAAImP,WAAJ;;AACA,QAAI,MAAM2R,IAAI,CAAC3nB,MAAf,EAAuB;AACnB,UAAI4nB,aAAa,GAAG,KAAKC,yBAAL,EAApB;;AACA,UAAIzd,UAAU,GAAGwd,aAAa,CAACpd,UAA/B;AACA,UAAIH,QAAQ,GAAGud,aAAa,CAACnd,UAA7B;;AACA,UAAI,KAAK/E,QAAL,CAAc3M,IAAd,KAAuBC,SAAS,CAAC4c,QAArC,EAA+C;AAC3C,YAAIkS,WAAJ,EAAiBC,SAAjB;;AACA3d,QAAAA,UAAU,GAAG,UAAU0d,WAAW,GAAG1d,UAAxB,KAAuC,KAAK,CAAL,KAAW0d,WAAlD,GAAgEA,WAAhE,GAA8EF,aAAa,CAAC9kB,UAAd,CAAyB,CAAzB,CAA3F;AACAuH,QAAAA,QAAQ,GAAG,UAAU0d,SAAS,GAAG1d,QAAtB,KAAmC,KAAK,CAAL,KAAW0d,SAA9C,GAA0DA,SAA1D,GAAsEH,aAAa,CAAC9kB,UAAd,CAAyB8kB,aAAa,CAAC9kB,UAAd,CAAyB9C,MAAzB,GAAkC,CAA3D,CAAjF;AACA,eAAO;AACHoK,UAAAA,UAAU,EAAEA,UADT;AAEHC,UAAAA,QAAQ,EAAEA,QAFP;AAGHvH,UAAAA,UAAU,EAAEtK,iBAAiB,CAACovB,aAAa,CAAC9kB,UAAf,EAA2BsH,UAA3B,EAAuCC,QAAvC,CAAjB,CAAkEvH;AAH3E,SAAP;AAKH;;AACD,aAAO;AACHsH,QAAAA,UAAU,EAAEA,UADT;AAEHC,QAAAA,QAAQ,EAAEA;AAFP,OAAP;AAIH,KAlBD,MAkBO,IAAIvP,QAAQ,CAAC6sB,IAAI,CAAC,CAAD,CAAL,CAAZ,EAAuB;AAC1B3R,MAAAA,WAAW,GAAG2R,IAAI,CAAC,CAAD,CAAlB;AACH,KAFM,MAEA,IAAI7uB,aAAa,CAAC6uB,IAAI,CAAC,CAAD,CAAL,CAAjB,EAA4B;AAC/B3R,MAAAA,WAAW,GAAG/c,MAAM,CAAC,EAAD,EAAK0uB,IAAI,CAAC,CAAD,CAAT,CAApB;AACH,KAFM,MAEA;AACH3R,MAAAA,WAAW,GAAG,CAAC2R,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAd;AACH;;AACD,QAAIK,WAAW,GAAG,KAAKzB,aAAL,CAAmBvQ,WAAnB,EAAgC2R,IAAI,CAAC,CAAD,CAApC,CAAlB;;AACA,QAAI,CAACK,WAAW,CAACC,WAAjB,EAA8B;AAC1B,WAAKC,YAAL,CAAkB,IAAlB,EAAwBF,WAAxB;AACH;AACJ,GAzoDY;;AA0oDbzB,EAAAA,aAAa,CAACvQ,WAAD,EAAcmS,aAAd,EAA6BC,QAA7B,EAAuCnpB,MAAvC,EAA+C;AACxDkpB,IAAAA,aAAa,GAAGA,aAAa,IAAI,EAAjC;;AACA,QAAIvvB,SAAS,CAACod,WAAD,CAAb,EAA4B;AACxBA,MAAAA,WAAW,GAAG,KAAKiQ,oBAAL,CAA0BjQ,WAA1B,CAAd;AACAA,MAAAA,WAAW,CAAC/W,MAAZ,GAAqBA,MAArB;AACH;;AACD,QAAIopB,cAAc,GAAG,KAAK1B,oBAAL,CAA0ByB,QAA1B,EAAoCnpB,MAApC,CAArB;AACA,QAAI+nB,aAAa,GAAGqB,cAAc,CAAC/d,KAAnC;AACA,KAAC6d,aAAa,CAAChlB,KAAf,IAAwB,KAAKM,aAAL,CAAmB,WAAnB,EAAgC4kB,cAAhC,CAAxB;AACA,QAAIL,WAAW,GAAG;AACdC,MAAAA,WAAW,EAAEI,cAAc,CAACvB,MADd;AAEdwB,MAAAA,eAAe,EAAEH,aAAa,CAACG,eAFjB;AAGdhe,MAAAA,KAAK,EAAE0L,WAAW,IAAIqS,cAAc,CAAC/d;AAHvB,KAAlB;;AAKA,QAAI,CAAC+d,cAAc,CAACvB,MAApB,EAA4B;AACxBluB,MAAAA,SAAS,CAACod,WAAD,CAAT,IAA0B,KAAKyQ,aAAL,CAAmBzQ,WAAnB,EAAgCmS,aAAa,CAAC3B,kBAA9C,CAA1B;;AACA,UAAI,CAAC5tB,SAAS,CAAC,KAAK2vB,oBAAN,CAAd,EAA2C;AACvC,aAAKA,oBAAL,GAA4B;AACxBC,UAAAA,UAAU,EAAExB,aADY;AAExBjuB,UAAAA,IAAI,EAAE,KAAK0F,UAAL,GAAkB1F;AAFA,SAA5B;AAIH;;AACD,WAAKwvB,oBAAL,CAA0B3B,KAA1B,GAAkCwB,QAAlC;AACA,WAAKG,oBAAL,CAA0BtpB,MAA1B,GAAmCA,MAAnC;AACA,WAAKspB,oBAAL,CAA0BE,OAA1B,GAAoC,CAAC,CAACN,aAAa,CAAC/kB,GAApD;AACH;;AACD,WAAO4kB,WAAP;AACH,GArqDY;;AAsqDbU,EAAAA,aAAa,GAAG;AACZ,QAAI9vB,SAAS,CAAC,KAAK2vB,oBAAN,CAAT,IAAwC,CAAC,KAAKA,oBAAL,CAA0BE,OAAvE,EAAgF;AAC5E,UAAIzB,aAAa,GAAG,KAAKuB,oBAAL,CAA0BC,UAA9C;AACA,UAAIJ,QAAQ,GAAG,KAAKG,oBAAL,CAA0B3B,KAAzC;AACA,UAAI3nB,MAAM,GAAG,KAAKspB,oBAAL,CAA0BtpB,MAAvC;AACA,UAAI0pB,qBAAqB,GAAG;AACxBne,QAAAA,UAAU,EAAEwc,aAAa,CAAC5c,UADF;AAExBK,QAAAA,UAAU,EAAEuc,aAAa,CAAC3c,QAFF;AAGxBvH,QAAAA,UAAU,EAAEkkB,aAAa,CAAClkB;AAHF,OAA5B;;AAKA,UAAI8lB,gBAAgB,GAAG,KAAKnqB,UAAL,GAAkB1F,IAAlB,KAA2B,KAAKwvB,oBAAL,CAA0BxvB,IAA5E;;AACA,UAAImuB,KAAK,GAAG0B,gBAAgB,GAAGnvB,MAAM,CAAC,KAAKye,oBAAL,KAA8B,KAAKA,oBAAL,CAA0ByQ,qBAA1B,EAAiD,KAAjD,CAA/B,CAAT,GAAmGE,GAA/H;AACA,UAAI5B,UAAU,GAAG2B,gBAAgB,GAAG,EAAEruB,IAAI,CAACuuB,KAAL,CAAW,KAAK9Q,oBAAL,CAA0B2Q,qBAA1B,KAAoD,KAAK3Q,oBAAL,MAA+B,CAAnF,IAAwF,KAAnG,IAA4G,KAA9G,CAAH,GAA0H6Q,GAA3J;;AACA,UAAIE,YAAY,GAAG,KAAKhC,mBAAL,CAAyBC,aAAzB,EAAwCoB,QAAxC,EAAkDnpB,MAAlD,EAA0DgoB,UAA1D,EAAsEC,KAAtE,CAAnB;;AACA6B,MAAAA,YAAY,CAACjC,MAAb,GAAsB,KAAKkC,8BAAL,CAAoC,MAAM/B,UAAN,GAAmB,KAAnB,GAA2B,MAA/D,EAAuEA,UAAvE,EAAmFgC,eAAzG;;AACA,WAAKxlB,aAAL,CAAmB,SAAnB,EAA8BslB,YAA9B;;AACA,UAAIA,YAAY,CAACjC,MAAjB,EAAyB;AACrB,aAAKoC,2BAAL,CAAiClC,aAAjC;AACH;;AACD,WAAKuB,oBAAL,GAA4B,IAA5B;AACH;AACJ,GA3rDY;;AA4rDbW,EAAAA,2BAA2B,CAAClC,aAAD,EAAgB;AACvC,SAAKuB,oBAAL,GAA4B,IAA5B;;AACA,SAAK9B,aAAL,CAAmBO,aAAnB;;AACA,SAAKkB,YAAL,CAAkB,IAAlB,EAAwBlB,aAAxB;AACH,GAhsDY;;AAisDbgC,EAAAA,8BAA8B,CAACnC,UAAD,EAAaI,UAAb,EAAyB3c,KAAzB,EAAgC;AAC1D,QAAI5N,OAAO,GAAG,KAAKgJ,QAAnB;AACA,QAAI+O,UAAU,GAAG,KAAK1P,WAAtB;AACA,QAAIokB,OAAO,GAAGzsB,OAAO,CAAC0sB,oBAAtB;AACA,QAAIC,cAAc,GAAG/e,KAArB;AACA,QAAI0L,WAAJ;AACA,QAAIsT,YAAY,GAAG,WAAWzC,UAAX,IAAyBI,UAAU,IAAI,CAA1D;AACA,QAAItR,aAAa,GAAGlB,UAAU,CAACF,gBAAX,EAApB;;AACA,QAAIjK,KAAJ,EAAW;AACP0L,MAAAA,WAAW,GAAG,KAAKD,WAAL,CAAiB9d,iBAAiB,CAACqS,KAAD,CAAlC,CAAd;AACA0L,MAAAA,WAAW,GAAG;AACVxL,QAAAA,UAAU,EAAEwL,WAAW,CAAC5L,UADd;AAEVK,QAAAA,UAAU,EAAEuL,WAAW,CAAC3L,QAFd;AAGVvH,QAAAA,UAAU,EAAE6S,aAAa,CAAC7S;AAHhB,OAAd;AAKH;;AACD,QAAIymB,uBAAuB,GAAG,KAAKvR,oBAAL,CAA0BrC,aAA1B,CAA9B;AACA,QAAI6T,sBAAsB,GAAG,KAAKxR,oBAAL,CAA0BhC,WAA1B,CAA7B;;AACA,QAAIpd,SAAS,CAACuwB,OAAD,CAAT,IAAsB,eAAezsB,OAAO,CAAC3D,IAAjD,EAAuD;AACnDowB,MAAAA,OAAO,GAAG1U,UAAU,CAACgV,OAAX,CAAmBN,OAAnB,CAAV;;AACA,UAAInT,WAAW,IAAImT,OAAO,GAAGI,uBAAzB,IAAoDJ,OAAO,IAAIK,sBAAnE,EAA2F;AACvFH,QAAAA,cAAc,GAAGpxB,iBAAiB,CAACwc,UAAU,CAACiV,sBAAX,CAAkCP,OAAlC,EAA2CnT,WAA3C,CAAD,CAAlC;AACAsT,QAAAA,YAAY,GAAG,KAAf;AACH,OAHD,MAGO;AACHA,QAAAA,YAAY,IAAIH,OAAO,GAAGK,sBAA1B;AACH;AACJ,KARD,MAQO;AACH,UAAIG,YAAY,GAAG,KAAK5kB,WAAL,CAAiB4kB,YAApC;AACA,UAAIC,SAAS,GAAG;AACZpf,QAAAA,UAAU,EAAEmL,aAAa,CAAC9a,GADd;AAEZ4P,QAAAA,UAAU,EAAEkL,aAAa,CAAChb,GAFd;AAGZmI,QAAAA,UAAU,EAAE6S,aAAa,CAAC7S;AAHd,OAAhB;AAKAwmB,MAAAA,YAAY,IAAI,KAAKtR,oBAAL,CAA0B4R,SAA1B,IAAuCD,YAAvC,IAAuDH,sBAAvE;AACH;;AACD,WAAO;AACHP,MAAAA,eAAe,EAAE,CAAC,CAACK,YADhB;AAEHD,MAAAA,cAAc,EAAEA;AAFb,KAAP;AAIH,GAxuDY;;AAyuDbQ,EAAAA,iBAAiB,CAACC,KAAD,EAAQ;AACrB,QAAIC,gBAAJ;AACA,QAAIC,UAAJ;;AACA,QAAI,eAAe,KAAKtkB,QAAL,CAAc3M,IAAjC,EAAuC;AACnCixB,MAAAA,UAAU,GAAG,KAAKjlB,WAAL,CAAiBwP,gBAAjB,EAAb;AACAwV,MAAAA,gBAAgB,GAAGD,KAAK,GAAGE,UAAU,CAAClnB,UAAX,CAAsBknB,UAAU,CAAClnB,UAAX,CAAsB9C,MAAtB,GAA+B,CAArD,CAAH,GAA6DgqB,UAAU,CAAClnB,UAAX,CAAsB,CAAtB,CAArF;AACH,KAHD,MAGO;AACHknB,MAAAA,UAAU,GAAG,KAAK3C,aAAL,EAAb;AACA0C,MAAAA,gBAAgB,GAAGD,KAAK,GAAGE,UAAU,CAAC3f,QAAd,GAAyB2f,UAAU,CAAC5f,UAA5D;AACH;;AACD,QAAIqK,UAAU,GAAG,KAAKhB,aAAL,EAAjB;AACA,QAAIwW,YAAY,GAAGxV,UAAU,CAACC,SAAX,CAAqBqV,gBAArB,CAAnB;AACA,QAAI/T,WAAW,GAAG,KAAKA,WAAL,EAAlB;AACA,QAAIkU,gBAAgB,GAAGJ,KAAK,GAAGrV,UAAU,CAACC,SAAX,CAAqBsB,WAAW,CAAC3L,QAAjC,CAAH,GAAgDoK,UAAU,CAACC,SAAX,CAAqBsB,WAAW,CAAC5L,UAAjC,CAA5E;AACA,WAAO5P,IAAI,CAAC0vB,gBAAgB,GAAGD,YAApB,CAAJ,GAAwC9tB,gBAA/C;AACH,GAxvDY;;AAyvDb8Z,EAAAA,WAAW,GAAG;AACV,WAAO,KAAK/Q,SAAZ;AACH,GA3vDY;;AA4vDbilB,EAAAA,YAAY,EAAE,YAAW;AACrB,QAAI/P,MAAM,GAAG,KAAKxN,WAAL,IAAoB,EAAjC;;AACA,QAAI,KAAKlH,QAAL,CAAc3M,IAAd,KAAuBC,SAAS,CAAC4c,QAArC,EAA+C;AAC3C,aAAOvb,oBAAoB,CAAC+f,MAAD,CAA3B;AACH,KAFD,MAEO;AACH,aAAO/f,oBAAoB,CAAC+f,MAAM,CAACnI,MAAP,CAAc,KAAKc,WAAnB,EAAgC,KAAKmL,cAArC,CAAD,CAApB,CAA2EkM,IAA3E,CAAiF,UAASC,CAAT,EAAYC,CAAZ,EAAe;AACnG,eAAOhyB,OAAO,CAAC+xB,CAAD,CAAP,GAAa/xB,OAAO,CAACgyB,CAAD,CAA3B;AACH,OAFM,CAAP;AAGH;AACJ,GArwDY;AAswDblwB,EAAAA,aAAa,EAAE,UAASmN,MAAT,EAAiBgjB,WAAjB,EAA8B;AACzC,QAAI1iB,IAAI,GAAG,IAAX;AACA,QAAInL,OAAO,GAAGmL,IAAI,CAACnC,QAAnB;AACA,QAAI8kB,SAAS,GAAG9tB,OAAO,CAACkB,OAAR,GAAkBlB,OAAO,CAACqJ,KAA1B,GAAkC,CAAlD;AACA,QAAIxG,KAAJ;AACA,QAAIkrB,MAAM,GAAGF,WAAW,GAAG7tB,OAAO,CAAC+D,KAAR,CAAc+M,cAAd,GAA+B,KAAK9Q,OAAO,CAAClD,IAAR,CAAawG,MAApD,GAA6D,CAArF;AACA,QAAI0C,YAAJ;;AACA,QAAIgoB,aAAa,GAAG7iB,IAAI,CAACqI,iBAAL,EAApB;;AACA,QAAIwa,aAAa,CAAC9nB,OAAd,MAA2B,CAAClG,OAAO,CAAC+D,KAAR,CAAc7C,OAA1C,IAAqD,CAACiK,IAAI,CAACwH,kBAA/D,EAAmF;AAC/E,aAAO;AACH1N,QAAAA,MAAM,EAAE6oB,SADL;AAEHzkB,QAAAA,KAAK,EAAEykB,SAFJ;AAGHrqB,QAAAA,CAAC,EAAE,CAHA;AAIHC,QAAAA,CAAC,EAAE;AAJA,OAAP;AAMH;;AACD,QAAIyH,IAAI,CAAC+E,WAAT,EAAsB;AAClBrN,MAAAA,KAAK,GAAGlF,oBAAoB,CAACwN,IAAI,CAAC+E,WAAN,CAA5B;AACH,KAFD,MAEO;AACH/E,MAAAA,IAAI,CAAC+M,YAAL,CAAkBrN,MAAlB;AACAhI,MAAAA,KAAK,GAAGsI,IAAI,CAACuU,0BAAL,CAAgCsO,aAAhC,EAA+C9wB,KAA/C,CAAR;AACA8I,MAAAA,YAAY,GAAGnD,KAAK,CAACmD,YAArB;AACAnD,MAAAA,KAAK,GAAGA,KAAK,CAACA,KAAd;AACH;;AACD,QAAIorB,OAAO,GAAGprB,KAAK,CAACmL,MAAN,CAAc,UAASkgB,SAAT,EAAoBpxB,IAApB,EAA0BwI,KAA1B,EAAiC;AACzD,UAAIvB,KAAK,GAAGoH,IAAI,CAACoC,WAAL,CAAiBzQ,IAAjB,EAAuBkD,OAAO,CAAC+D,KAA/B,EAAsCiqB,aAAtC,EAAqD,KAAK,CAA1D,EAA6DhoB,YAA7D,EAA2EnD,KAA3E,CAAZ;;AACA,UAAIqrB,SAAS,CAAC5qB,MAAV,GAAmBS,KAAK,CAACT,MAA7B,EAAqC;AACjC,eAAOS,KAAP;AACH,OAFD,MAEO;AACH,eAAOmqB,SAAP;AACH;AACJ,KAPa,EAOV/iB,IAAI,CAACoC,WAAL,CAAiB1K,KAAK,CAAC,CAAD,CAAtB,EAA2B7C,OAAO,CAAC+D,KAAnC,EAA0CiqB,aAA1C,EAAyD,KAAK,CAA9D,EAAiEhoB,YAAjE,EAA+EnD,KAA/E,CAPU,CAAd;;AAQA,QAAI8J,IAAI,GAAGxB,IAAI,CAACtE,SAAL,CAAe8F,IAAf,CAAoBshB,OAApB,EAA6B,CAA7B,EAAgC,CAAhC,EAAmCjhB,GAAnC,CAAuC7B,IAAI,CAACiL,eAA5C,EAA6DhN,IAA7D,CAAkE+B,IAAI,CAACgL,YAAvE,EAAqFvM,MAArF,CAA4FuB,IAAI,CAACtE,SAAL,CAAesnB,IAA3G,CAAX;;AACA,QAAIld,GAAG,GAAGtE,IAAI,CAACqE,OAAL,EAAV;AACArE,IAAAA,IAAI,CAAC0F,MAAL;AACA,WAAO;AACH5O,MAAAA,CAAC,EAAEwN,GAAG,CAACxN,CADJ;AAEHC,MAAAA,CAAC,EAAEuN,GAAG,CAACvN,CAFJ;AAGH2F,MAAAA,KAAK,EAAE4H,GAAG,CAAC5H,KAAJ,GAAY0kB,MAHhB;AAIH9oB,MAAAA,MAAM,EAAEgM,GAAG,CAAChM,MAAJ,GAAa8oB;AAJlB,KAAP;AAMH,GA/yDY;AAgzDb1G,EAAAA,mBAAmB,EAAE,YAAW;AAC5B,QAAI,CAAC,KAAKre,QAAL,CAAcjF,KAAd,CAAoB7C,OAAzB,EAAkC;AAC9B;AACH;;AACD,QAAI4D,QAAQ,GAAG,KAAKkE,QAAL,CAAcjF,KAA7B;;AACA,QAAIgkB,WAAW,GAAG,KAAKC,oBAAL,CAA0BljB,QAAQ,CAACijB,WAAnC,CAAlB;;AACA,QAAIE,eAAe,GAAG,KAAKC,wBAAL,CAA8BpjB,QAAQ,CAACsa,mBAAvC,EAA4D2I,WAA5D,CAAtB;;AACA,QAAIqG,iBAAiB,GAAG,WAAWnG,eAAX,IAA8B,aAAaA,eAAnE;AACA,QAAIoG,QAAQ,GAAG;AACXC,MAAAA,aAAa,EAAExpB,QAAQ,CAACwpB,aADb;AAEXC,MAAAA,iBAAiB,EAAEzpB,QAAQ,CAACypB;AAFjB,KAAf;AAIA,QAAIC,aAAJ;;AACA,QAAI3pB,KAAK,GAAG,KAAKqL,WAAL,CAAiBoF,GAAjB,CAAsB,UAASxY,IAAT,EAAe;AAC7C,aAAOA,IAAI,CAAC6T,SAAZ;AACH,KAFW,CAAZ;;AAGA,QAAIvL,IAAI,GAAG,KAAKqpB,QAAL,CAAc5pB,KAAd,CAAX;;AACA,YAAQkjB,WAAR;AACI,WAAKzoB,MAAL;AACI,YAAI8uB,iBAAJ,EAAuB;AACnBI,UAAAA,aAAa,GAAG,IAAhB;AACAppB,UAAAA,IAAI,GAAG,CAAP;AACH;;AACD,aAAKspB,eAAL,CAAqB3G,WAArB,EAAkC3iB,IAAlC,EAAwCP,KAAxC,EAA+CC,QAA/C,EAAyD0pB,aAAzD;;AACA;;AACJ,WAAK,SAAL;AACI,YAAIJ,iBAAJ,EAAuB;AACnBhpB,UAAAA,IAAI,GAAG,CAAP;AACH;;AACD,aAAKspB,eAAL,CAAqB3G,WAArB,EAAkC/pB,IAAI,CAACoH,IAAD,EAAO,CAAP,CAAtC,EAAiDP,KAAjD,EAAwDC,QAAxD;;AACA;;AACJ;AACI,aAAK6pB,sBAAL,CAA4B9pB,KAA5B,EAAmCojB,eAAnC,EAAoD7iB,IAApD,EAA0DipB,QAA1D;;AAfR;AAiBH,GAl1DY;AAm1DbM,EAAAA,sBAAsB,EAAE,UAAS9pB,KAAT,EAAgB+pB,IAAhB,EAAsBxpB,IAAtB,EAA4BipB,QAA5B,EAAsC;AAC1D,QAAIvpB,QAAQ,GAAG,KAAKkE,QAAL,CAAcjF,KAA7B;AACA,QAAI2a,UAAU,GAAG,KAAKxO,WAAtB;;AACA,QAAI,WAAW0e,IAAX,IAAmB,aAAaA,IAApC,EAA0C;AACtC;AACH;;AACD,QAAIxpB,IAAI,GAAG,CAAP,IAAYP,KAAK,CAAC8c,IAAN,CAAY,UAAS1Q,GAAT,EAAc3L,KAAd,EAAqBupB,KAArB,EAA4B;AAChD,UAAI,MAAMvpB,KAAV,EAAiB;AACb,eAAO,KAAP;AACH;;AACD,aAAOhJ,SAAS,CAACwyB,gBAAV,CAA2B7d,GAA3B,EAAgC4d,KAAK,CAACvpB,KAAK,GAAG,CAAT,CAArC,EAAkDR,QAAQ,CAACL,UAA3D,EAAuEK,QAAQ,CAACT,SAAhF,CAAP;AACH,KALW,CAAhB,EAKS;AACL,WAAKqqB,eAAL,CAAqBE,IAArB,EAA2BxpB,IAA3B,EAAiCP,KAAjC,EAAwCwpB,QAAxC;AACH;;AACD,SAAKU,8BAAL,CAAoCrQ,UAApC,EAAgD7Z,KAAhD,EAAuD+pB,IAAvD;;AACA,SAAKI,mBAAL,CAAyBtQ,UAAzB,EAAqC7Z,KAArC,EAA4CC,QAAQ,CAACL,UAArD,EAAiEK,QAAQ,CAACT,SAA1E;AACH,GAn2DY;AAo2DbqqB,EAAAA,eAAe,EAAE,UAASE,IAAT,EAAexpB,IAAf,EAAqBP,KAArB,EAA4BwpB,QAA5B,EAAsCG,aAAtC,EAAqD;AAClE,QAAI9P,UAAU,GAAG,KAAKxO,WAAtB;AACA,QAAIpL,QAAQ,GAAG,KAAKkE,QAAL,CAAcjF,KAA7B;AACA,QAAIgB,KAAK,GAAGspB,QAAQ,CAACC,aAArB;AACA,QAAIW,WAAJ;AACA,QAAI5qB,SAAJ;AACA,QAAIgB,IAAJ;;AACA,YAAQupB,IAAR;AACI,WAAKtvB,MAAL;AACI,YAAI,CAACwF,QAAQ,CAACR,aAAd,EAA6B;AACzBD,UAAAA,SAAS,GAAGU,KAAK,GAAG,CAAR,GAAYhG,KAAZ,GAAoBF,IAAhC;;AACA,cAAIkG,KAAK,GAAG,EAAR,KAAe,CAAnB,EAAsB;AAClBV,YAAAA,SAAS,GAAGpF,MAAZ;AACH;AACJ;;AACDmG,QAAAA,IAAI,GAAGopB,aAAa,GAAGppB,IAAH,GAAU,KAAKqpB,QAAL,CAAc5pB,KAAd,EAAqBE,KAArB,CAA9B;;AACAM,QAAAA,IAAI,GAAG,UAASvI,IAAT,EAAe;AAClB,cAAIoyB,gBAAgB,GAAGpyB,IAAI,CAACyI,mBAAL,EAAvB;;AACA,cAAI,CAAC2pB,gBAAL,EAAuB;AACnB;AACH;;AACDA,UAAAA,gBAAgB,CAACC,MAAjB,CAAwBpqB,KAAxB;AACAjI,UAAAA,IAAI,CAAC4T,kBAAL,GAA0B3L,KAA1B;AACAV,UAAAA,SAAS,KAAKvH,IAAI,CAACqU,cAAL,GAAsB9M,SAA3B,CAAT;AACH,SARD;;AASAc,QAAAA,YAAY,CAACuZ,UAAD,EAAatZ,IAAb,EAAmBC,IAAnB,CAAZ;AACA;;AACJ,WAAK,SAAL;AACI4pB,QAAAA,WAAW,GAAG,KAAKG,kBAAL,CAAwBvqB,KAAxB,EAA+BwpB,QAAQ,CAACE,iBAAxC,CAAd;;AACAlpB,QAAAA,IAAI,GAAG,UAASvI,IAAT,EAAewI,KAAf,EAAsB;AACzB,cAAIA,KAAK,IAAIF,IAAI,GAAG,CAAX,CAAL,GAAqB,CAArB,KAA2B,CAA/B,EAAkC;AAC9BtI,YAAAA,IAAI,CAACmT,WAAL,GAAmBgf,WAAnB;AACH;AACJ,SAJD;;AAKA9pB,QAAAA,YAAY,CAACuZ,UAAD,EAAatZ,IAAI,GAAG,CAApB,EAAuBC,IAAvB,CAAZ;AACA;;AACJ,WAAK,MAAL;AACA,WAAK,OAAL;AACI,YAAI,MAAMD,IAAV,EAAgB;AACZ,eAAKspB,eAAL,CAAqB,SAArB,EAAgCtpB,IAAhC,EAAsCP,KAAtC,EAA6CwpB,QAA7C;AACH,SAFD,MAEO;AACH,eAAKK,eAAL,CAAqBpvB,MAArB,EAA6B8F,IAA7B,EAAmCP,KAAnC,EAA0C;AACtCypB,YAAAA,aAAa,EAAE1pB,eAAe,CAACC,KAAD,EAAQC,QAAR;AADQ,WAA1C;AAGH;;AACD;;AACJ;AACIK,QAAAA,YAAY,CAACuZ,UAAD,EAAatZ,IAAb,CAAZ;AAxCR;AA0CH,GAr5DY;AAs5DbiqB,EAAAA,iBAAiB,EAAEnyB,KAt5DN;AAu5Db+pB,EAAAA,gBAAgB,EAAE/pB,KAv5DL;AAw5DboqB,EAAAA,kBAAkB,EAAEpqB,KAx5DP;AAy5DboyB,EAAAA,QAAQ,EAAEpyB,KAz5DG;AA05DbiP,EAAAA,oBAAoB,EAAEjP,KA15DT;AA25DbyhB,EAAAA,mBAAmB,EAAEzhB,KA35DR;AA45Dbob,EAAAA,kBAAkB,EAAEpb,KA55DP;AA65DbypB,EAAAA,UAAU,EAAEzpB,KA75DC;AA85Db4rB,EAAAA,kBAAkB,EAAE5rB,KA95DP;AA+5DbkqB,EAAAA,yBAAyB,EAAElqB,KA/5Dd;AAg6DboL,EAAAA,iBAAiB,EAAE,YAAW;AAC1B,WAAO,IAAI1L,YAAJ,CAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,CAAP;AACH,GAl6DY;AAm6Dbga,EAAAA,iBAAiB,EAAE,YAAW;AAC1B,QAAImB,UAAU,GAAG,KAAK1P,WAAtB;AACA0P,IAAAA,UAAU,CAACwX,MAAX,CAAkBxX,UAAU,CAACF,gBAAX,EAAlB,EAAiD,KAAKQ,OAAL,IAAgB,EAAjE,EAAqE,KAAKmX,qBAAL,EAArE;AACH,GAt6DY;AAu6DbA,EAAAA,qBAAqB,EAAE,YAAW;AAC9B,QAAIC,kBAAJ,EAAwBC,qBAAxB,EAA+CC,mBAA/C;;AACA,QAAI3vB,OAAO,GAAG,KAAKgJ,QAAnB;AACA,WAAO;AACH9E,MAAAA,YAAY,EAAE,KAAK+G,aADhB;AAEH2kB,MAAAA,cAAc,EAAE,CAAC,KAAKrnB,cAFnB;AAGH2L,MAAAA,QAAQ,EAAElU,OAAO,CAAC6vB,oBAHf;AAIHvuB,MAAAA,cAAc,EAAE,UAAUmuB,kBAAkB,GAAGzvB,OAAO,CAACuB,QAAvC,KAAoD,KAAK,CAAL,KAAWkuB,kBAA/D,GAAoF,KAAK,CAAzF,GAA6FA,kBAAkB,CAAC,CAAD,CAJ5H;AAKHK,MAAAA,KAAK,EAAE,KAAKC,SAAL,EALJ;AAMHC,MAAAA,UAAU,EAAE,UAAUN,qBAAqB,GAAG,UAAUC,mBAAmB,GAAG3vB,OAAO,CAAC+gB,UAAxC,KAAuD,KAAK,CAAL,KAAW4O,mBAAlE,GAAwF,KAAK,CAA7F,GAAiGA,mBAAmB,CAACtmB,KAAvJ,KAAiK,KAAK,CAAL,KAAWqmB,qBAA5K,GAAoMA,qBAApM,GAA4N;AANrO,KAAP;AAQH,GAl7DY;;AAm7Db1gB,EAAAA,cAAc,GAAG;AACb,QAAInE,MAAM,GAAG,KAAKC,kBAAL,EAAb;;AACA,WAAO,CAACD,MAAM,CAACpE,KAAR,EAAeoE,MAAM,CAACnE,GAAtB,EAA2BgnB,IAA3B,CAAgC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAA9C,CAAP;AACH,GAt7DY;;AAu7Db9iB,EAAAA,kBAAkB,EAAE,YAAW;AAC3B,QAAI5G,YAAY,GAAG,KAAK+G,aAAxB;AACA,QAAIJ,MAAM,GAAG,KAAKwN,OAAL,IAAgB,EAA7B;;AACA,QAAI4D,MAAM,GAAG,KAAK5T,WAAL,CAAiBwP,gBAAjB,GAAoCoE,MAAjD;;AACA,QAAIzY,MAAM,GAAGU,YAAY,GAAG,CAAC2G,MAAM,CAAC/L,IAAR,EAAc+L,MAAM,CAACxB,KAAP,GAAewB,MAAM,CAAC7L,KAApC,CAAH,GAAgD,CAAC6L,MAAM,CAAC5F,MAAP,GAAgB4F,MAAM,CAACjM,MAAxB,EAAgCiM,MAAM,CAACnM,GAAvC,CAAzE;AACAud,IAAAA,MAAM,IAAIzY,MAAM,CAACysB,OAAP,EAAV;AACA,WAAO;AACHxpB,MAAAA,KAAK,EAAEjD,MAAM,CAAC,CAAD,CADV;AAEHkD,MAAAA,GAAG,EAAElD,MAAM,CAAC,CAAD;AAFR,KAAP;AAIH,GAj8DY;AAk8Db2b,EAAAA,eAAe,EAAE,YAAW;AACxB,QAAItU,MAAM,GAAG,KAAKC,kBAAL,EAAb;;AACA,QAAI7E,MAAM,GAAG,KAAKkT,WAAL,GAAmB,KAAKA,WAAL,CAAiBlT,MAAjB,IAA2B,EAA9C,GAAmD,EAAhE;AACA,QAAIiqB,YAAY,GAAGjqB,MAAM,CAAC3C,MAA1B;;AACA,QAAIwC,WAAW,GAAGhI,IAAI,CAAC+M,MAAM,CAACpE,KAAP,GAAeoE,MAAM,CAACnE,GAAvB,CAAtB;;AACA,WAAOZ,WAAW,IAAIoqB,YAAY,GAAGjqB,MAAM,CAACiqB,YAAY,GAAG,CAAhB,CAAN,CAAyBC,eAA5B,GAA8C,CAA9D,CAAlB;AACH,GAx8DY;AAy8Db1T,EAAAA,eAAe,EAAE,YAAW;AACxB,WAAO,EAAP;AACH,GA38DY;AA48DbqE,EAAAA,aAAa,EAAE,YAAW;AACtB,WAAO,EAAP;AACH,GA98DY;AA+8DbyG,EAAAA,YAAY,EAAErqB,KA/8DD;AAg9Db2rB,EAAAA,mBAAmB,EAAE3rB,KAh9DR;AAi9DbkzB,EAAAA,cAAc,EAAElzB,KAj9DH;AAk9DbmzB,EAAAA,cAAc,EAAEnzB,KAl9DH;AAm9Db6xB,EAAAA,8BAA8B,EAAE7xB,KAn9DnB;AAo9Db8xB,EAAAA,mBAAmB,EAAE9xB,KAp9DR;AAq9DbozB,EAAAA,eAAe,EAAEpzB,KAr9DJ;AAs9DbsuB,EAAAA,YAAY,EAAEtuB,KAt9DD;AAu9DbqzB,EAAAA,mBAAmB,EAAErzB,KAv9DR;;AAw9DbszB,EAAAA,sBAAsB,CAACC,iBAAD,EAAoB;AACtC,SAAKjF,YAAL,GAAoBiF,iBAApB;AACH,GA19DY;;AA29DblU,EAAAA,mBAAmB,CAACV,aAAD,EAAgB;AAC/B,QAAI6R,IAAJ;;AACA,QAAI,KAAKnlB,cAAT,EAAyB;AACrBmlB,MAAAA,IAAI,GAAG7R,aAAP;AACH,KAFD,MAEO;AACH,UAAI6U,uBAAuB,GAAG,KAAK1nB,QAAL,CAAc0nB,uBAA5C;AACAhD,MAAAA,IAAI,GAAG,SAASgD,uBAAT,IAAoC,KAAK,CAAL,KAAWA,uBAA/C,GAAyEA,uBAAzE,GAAmG,KAAK1nB,QAAL,CAAc5C,UAAxH;AACH;;AACD,WAAOsnB,IAAP;AACH,GAp+DY;;AAq+DbvC,EAAAA,yBAAyB,GAAG;AACxB,WAAO,KAAKnS,cAAL,CAAoB,KAAK3Q,WAAL,CAAiBwP,gBAAjB,EAApB,CAAP;AACH;;AAv+DY,CAAjB","sourcesContent":["/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    smartFormatter as _format,\r\n    formatRange\r\n} from \"./smart_formatter\";\r\nimport {\r\n    patchFontOptions,\r\n    getVizRangeObject,\r\n    getLogExt as getLog,\r\n    raiseToExt as raiseTo,\r\n    valueOf,\r\n    rotateBBox,\r\n    getCategoriesInfo,\r\n    adjustVisualRange,\r\n    getAddFunction,\r\n    convertVisualRangeObject\r\n} from \"../core/utils\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isPlainObject,\r\n    type\r\n} from \"../../core/utils/type\";\r\nimport constants from \"./axes_constants\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    inArray\r\n} from \"../../core/utils/array\";\r\nimport formatHelper from \"../../format_helper\";\r\nimport {\r\n    getParser\r\n} from \"../components/parse_utils\";\r\nimport {\r\n    tickGenerator\r\n} from \"./tick_generator\";\r\nimport {\r\n    Translator2D\r\n} from \"../translators/translator2d\";\r\nimport {\r\n    Range\r\n} from \"../translators/range\";\r\nimport {\r\n    tick\r\n} from \"./tick\";\r\nimport {\r\n    adjust\r\n} from \"../../core/utils/math\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport {\r\n    noop as _noop\r\n} from \"../../core/utils/common\";\r\nimport xyMethods from \"./xy_axes\";\r\nimport * as polarMethods from \"./polar_axes\";\r\nimport createConstantLine from \"./constant_line\";\r\nimport createStrip from \"./strip\";\r\nimport {\r\n    Deferred,\r\n    when\r\n} from \"../../core/utils/deferred\";\r\nimport {\r\n    calculateCanvasMargins,\r\n    measureLabels\r\n} from \"./axes_utils\";\r\nvar convertTicksToValues = constants.convertTicksToValues;\r\nvar _math = Math;\r\nvar _abs = _math.abs;\r\nvar _max = _math.max;\r\nvar _min = _math.min;\r\nvar _isArray = Array.isArray;\r\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\r\nvar MAX_GRID_BORDER_ADHENSION = 4;\r\nvar TOP = constants.top;\r\nvar BOTTOM = constants.bottom;\r\nvar LEFT = constants.left;\r\nvar RIGHT = constants.right;\r\nvar CENTER = constants.center;\r\nvar KEEP = \"keep\";\r\nvar SHIFT = \"shift\";\r\nvar RESET = \"reset\";\r\nvar ROTATE = \"rotate\";\r\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\r\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\r\nvar SCROLL_THRESHOLD = 5;\r\nvar MIN_BAR_MARGIN = 5;\r\nvar MAX_MARGIN_VALUE = .8;\r\nvar dateIntervals = {\r\n    day: 864e5,\r\n    week: 6048e5\r\n};\r\n\r\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\r\n    var _options$workWeek;\r\n    var {\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold\r\n    } = _ref;\r\n    return tickGenerator({\r\n        axisType: options.type,\r\n        dataType: options.dataType,\r\n        logBase: options.logarithmBase,\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold,\r\n        axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\r\n        minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\r\n        numberMultipliers: options.numberMultipliers,\r\n        calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\r\n        allowDecimals: options.allowDecimals,\r\n        endOnTick: options.endOnTick,\r\n        incidentOccurred: incidentOccurred,\r\n        firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\r\n        skipTickGeneration: skipTickGeneration,\r\n        skipCalculationLimits: options.skipCalculationLimits,\r\n        generateExtraTick: options.generateExtraTick,\r\n        minTickInterval: options.minTickInterval,\r\n        rangeIsEmpty: rangeIsEmpty\r\n    })\r\n}\r\n\r\nfunction createMajorTick(axis, renderer, skippedCategory) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, options.tick, options.grid, skippedCategory, false)\r\n}\r\n\r\nfunction createMinorTick(axis, renderer) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, options.minorTick, options.minorGrid)\r\n}\r\n\r\nfunction createBoundaryTick(axis, renderer, isFirst) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, extend({}, options.tick, {\r\n        visible: options.showCustomBoundaryTicks\r\n    }), options.grid, void 0, false, isFirst ? -1 : 1)\r\n}\r\n\r\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\r\n    (elements || []).forEach(e => e[action](actionArgument1, actionArgument2))\r\n}\r\n\r\nfunction initTickCoords(ticks) {\r\n    callAction(ticks, \"initCoords\")\r\n}\r\n\r\nfunction drawTickMarks(ticks, options) {\r\n    callAction(ticks, \"drawMark\", options)\r\n}\r\n\r\nfunction drawGrids(ticks, drawLine) {\r\n    callAction(ticks, \"drawGrid\", drawLine)\r\n}\r\n\r\nfunction updateTicksPosition(ticks, options, animate) {\r\n    callAction(ticks, \"updateTickPosition\", options, animate)\r\n}\r\n\r\nfunction updateGridsPosition(ticks, animate) {\r\n    callAction(ticks, \"updateGridPosition\", animate)\r\n}\r\n\r\nfunction cleanUpInvalidTicks(ticks) {\r\n    var i = ticks.length - 1;\r\n    for (i; i >= 0; i--) {\r\n        if (!removeInvalidTick(ticks, i)) {\r\n            break\r\n        }\r\n    }\r\n    for (i = 0; i < ticks.length; i++) {\r\n        if (removeInvalidTick(ticks, i)) {\r\n            i--\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeInvalidTick(ticks, i) {\r\n    if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\r\n        ticks.splice(i, 1);\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nfunction validateAxisOptions(options) {\r\n    var _labelOptions$minSpac;\r\n    var labelOptions = options.label;\r\n    var position = options.position;\r\n    var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\r\n    var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\r\n    var labelPosition = labelOptions.position;\r\n    if (position !== defaultPosition && position !== secondaryPosition) {\r\n        position = defaultPosition\r\n    }\r\n    if (!labelPosition || \"outside\" === labelPosition) {\r\n        labelPosition = position\r\n    } else if (\"inside\" === labelPosition) {\r\n        labelPosition = {\r\n            [TOP]: BOTTOM,\r\n            [BOTTOM]: TOP,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [position]\r\n    }\r\n    if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\r\n        labelPosition = position\r\n    }\r\n    if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\r\n        labelOptions.alignment = {\r\n            [TOP]: CENTER,\r\n            [BOTTOM]: CENTER,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [labelPosition]\r\n    }\r\n    options.position = position;\r\n    labelOptions.position = labelPosition;\r\n    options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\r\n    labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\r\n    options.type && (options.type = options.type.toLowerCase());\r\n    options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\r\n    options.valueType && (options.valueType = options.valueType.toLowerCase())\r\n}\r\n\r\nfunction getOptimalAngle(boxes, labelOpt) {\r\n    var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\r\n    return angle < 45 ? -45 : -90\r\n}\r\n\r\nfunction updateLabels(ticks, step, func) {\r\n    ticks.forEach((function(tick, index) {\r\n        if (tick.getContentContainer()) {\r\n            if (index % step !== 0) {\r\n                tick.removeLabel()\r\n            } else if (func) {\r\n                func(tick, index)\r\n            }\r\n        }\r\n    }))\r\n}\r\n\r\nfunction getZoomBoundValue(optionValue, dataValue) {\r\n    if (void 0 === optionValue) {\r\n        return dataValue\r\n    } else if (null === optionValue) {\r\n        return\r\n    } else {\r\n        return optionValue\r\n    }\r\n}\r\n\r\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\r\n    var tickGeneratorOptions = extend({}, options, {\r\n        endOnTick: true,\r\n        axisDivisionFactor: axisDivisionFactor,\r\n        skipCalculationLimits: true,\r\n        generateExtraTick: true,\r\n        minTickInterval: minTickInterval\r\n    });\r\n    return function(tickInterval, skipTickGeneration, min, max, breaks) {\r\n        return getTickGenerator(tickGeneratorOptions, _noop, skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({\r\n            min: min,\r\n            max: max,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, screenDelta, tickInterval, isDefined(tickInterval), void 0, void 0, void 0, breaks)\r\n    }\r\n}\r\n\r\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\r\n    return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1\r\n}\r\nexport var Axis = function(renderSettings) {\r\n    this._renderer = renderSettings.renderer;\r\n    this._incidentOccurred = renderSettings.incidentOccurred;\r\n    this._eventTrigger = renderSettings.eventTrigger;\r\n    this._stripsGroup = renderSettings.stripsGroup;\r\n    this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\r\n    this._labelsAxesGroup = renderSettings.labelsAxesGroup;\r\n    this._constantLinesGroup = renderSettings.constantLinesGroup;\r\n    this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\r\n    this._axesContainerGroup = renderSettings.axesContainerGroup;\r\n    this._gridContainerGroup = renderSettings.gridGroup;\r\n    this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\r\n    this._setType(renderSettings.axisType, renderSettings.drawingType);\r\n    this._createAxisGroups();\r\n    this._translator = this._createTranslator();\r\n    this.isArgumentAxis = renderSettings.isArgumentAxis;\r\n    this._viewport = {};\r\n    this._firstDrawing = true;\r\n    this._initRange = {};\r\n    this._getTemplate = renderSettings.getTemplate\r\n};\r\nAxis.prototype = {\r\n    constructor: Axis,\r\n    _drawAxis() {\r\n        var options = this._options;\r\n        if (!options.visible) {\r\n            return\r\n        }\r\n        this._axisElement = this._createAxisElement();\r\n        this._updateAxisElementPosition();\r\n        this._axisElement.attr({\r\n            \"stroke-width\": options.width,\r\n            stroke: options.color,\r\n            \"stroke-opacity\": options.opacity\r\n        }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup)\r\n    },\r\n    _createPathElement(points, attr, sharpDirection) {\r\n        return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection)\r\n    },\r\n    sharp(svgElement) {\r\n        var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\r\n        return svgElement.sharp(this._getSharpParam(), sharpDirection)\r\n    },\r\n    customPositionIsAvailable: () => false,\r\n    getOrthogonalAxis: _noop,\r\n    getCustomPosition: _noop,\r\n    getCustomBoundaryPosition: _noop,\r\n    resolveOverlappingForCustomPositioning: _noop,\r\n    hasNonBoundaryPosition: () => false,\r\n    customPositionIsBoundaryOrthogonalAxis: () => false,\r\n    getResolvedBoundaryPosition() {\r\n        return this.getOptions().position\r\n    },\r\n    getAxisSharpDirection() {\r\n        var position = this.getResolvedBoundaryPosition();\r\n        return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1\r\n    },\r\n    getSharpDirectionByCoords(coords) {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var maxCoord = Math.max(canvas.start, canvas.end);\r\n        return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1\r\n    },\r\n    _getGridLineDrawer: function() {\r\n        var that = this;\r\n        return function(tick, gridStyle) {\r\n            var grid = that._getGridPoints(tick.coords);\r\n            if (grid.points) {\r\n                return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords))\r\n            }\r\n            return null\r\n        }\r\n    },\r\n    _getGridPoints: function(coords) {\r\n        var isHorizontal = this._isHorizontal;\r\n        var tickPositionField = isHorizontal ? \"x\" : \"y\";\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        var borderOptions = this.borderOptions;\r\n        var canvasStart = isHorizontal ? LEFT : TOP;\r\n        var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\r\n        var axisCanvas = this.getCanvas();\r\n        var canvas = {\r\n            left: axisCanvas.left,\r\n            right: axisCanvas.width - axisCanvas.right,\r\n            top: axisCanvas.top,\r\n            bottom: axisCanvas.height - axisCanvas.bottom\r\n        };\r\n        var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\r\n        var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\r\n        var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\r\n        var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\r\n        if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\r\n            return {\r\n                points: null\r\n            }\r\n        }\r\n        return {\r\n            points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\r\n        }\r\n    },\r\n    _getConstantLinePos: function(parsedValue, canvasStart, canvasEnd) {\r\n        var value = this._getTranslatedCoord(parsedValue);\r\n        if (!isDefined(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\r\n            return\r\n        }\r\n        return value\r\n    },\r\n    _getConstantLineGraphicAttributes: function(value) {\r\n        var positionFrom = this._orthogonalPositions.start;\r\n        var positionTo = this._orthogonalPositions.end;\r\n        return {\r\n            points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\r\n        }\r\n    },\r\n    _createConstantLine: function(value, attr) {\r\n        return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()))\r\n    },\r\n    _drawConstantLineLabelText: function(text, x, y, _ref2, group) {\r\n        var {\r\n            font: font,\r\n            cssClass: cssClass\r\n        } = _ref2;\r\n        return this._renderer.text(text, x, y).css(patchFontOptions(extend({}, this._options.label.font, font))).attr({\r\n            align: \"center\",\r\n            class: cssClass\r\n        }).append(group)\r\n    },\r\n    _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value, group) {\r\n        var _text;\r\n        var text = lineLabelOptions.text;\r\n        var options = this._options;\r\n        var labelOptions = options.label;\r\n        this._checkAlignmentConstantLineLabels(lineLabelOptions);\r\n        text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\r\n        var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\r\n        return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group)\r\n    },\r\n    _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {\r\n        var isContinuous = !!(range.minVisible || range.maxVisible);\r\n        var categories = (range.categories || []).reduce((function(result, cat) {\r\n            result.push(cat.valueOf());\r\n            return result\r\n        }), []);\r\n        var start;\r\n        var end;\r\n        var swap;\r\n        var startCategoryIndex;\r\n        var endCategoryIndex;\r\n        if (!isContinuous) {\r\n            if (isDefined(startValue) && isDefined(endValue)) {\r\n                var parsedStartValue = this.parser(startValue);\r\n                var parsedEndValue = this.parser(endValue);\r\n                startCategoryIndex = inArray(isDefined(parsedStartValue) ? parsedStartValue.valueOf() : void 0, categories);\r\n                endCategoryIndex = inArray(isDefined(parsedEndValue) ? parsedEndValue.valueOf() : void 0, categories);\r\n                if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\r\n                    return {\r\n                        from: 0,\r\n                        to: 0,\r\n                        outOfCanvas: true\r\n                    }\r\n                }\r\n                if (startCategoryIndex > endCategoryIndex) {\r\n                    swap = endValue;\r\n                    endValue = startValue;\r\n                    startValue = swap\r\n                }\r\n            }\r\n        }\r\n        if (isDefined(startValue)) {\r\n            startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\r\n            start = this._getTranslatedCoord(startValue, -1)\r\n        } else {\r\n            start = canvasStart\r\n        }\r\n        if (isDefined(endValue)) {\r\n            endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\r\n            end = this._getTranslatedCoord(endValue, 1)\r\n        } else {\r\n            end = canvasEnd\r\n        }\r\n        var stripPosition = start < end ? {\r\n            from: start,\r\n            to: end\r\n        } : {\r\n            from: end,\r\n            to: start\r\n        };\r\n        var visibleArea = this.getVisibleArea();\r\n        if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\r\n            stripPosition.outOfCanvas = true\r\n        }\r\n        return stripPosition\r\n    },\r\n    _getStripGraphicAttributes: function(fromPoint, toPoint) {\r\n        var x;\r\n        var y;\r\n        var width;\r\n        var height;\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        if (this._isHorizontal) {\r\n            x = fromPoint;\r\n            y = _min(positionFrom, positionTo);\r\n            width = toPoint - fromPoint;\r\n            height = _abs(positionFrom - positionTo)\r\n        } else {\r\n            x = _min(positionFrom, positionTo);\r\n            y = fromPoint;\r\n            width = _abs(positionFrom - positionTo);\r\n            height = _abs(fromPoint - toPoint)\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            width: width,\r\n            height: height\r\n        }\r\n    },\r\n    _createStrip: function(attrs) {\r\n        return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height)\r\n    },\r\n    _adjustStripLabels: function() {\r\n        var that = this;\r\n        this._strips.forEach((function(strip) {\r\n            if (strip.label) {\r\n                strip.label.attr(that._getAdjustedStripLabelCoords(strip))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\r\n        var getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\r\n        this._majorTicks.forEach((function(tick) {\r\n            if (tick.label) {\r\n                tick.updateMultilineTextAlignment();\r\n                tick.label.attr(getContainerAttrs(tick))\r\n            } else {\r\n                tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabels: function(offset) {\r\n        var options = this.getOptions();\r\n        var positionsAreConsistent = options.position === options.label.position;\r\n        var maxSize = this._majorTicks.reduce((function(size, tick) {\r\n            if (!tick.getContentContainer()) {\r\n                return size\r\n            }\r\n            var bBox = tick.labelRotationAngle ? rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\r\n            return {\r\n                width: _max(size.width || 0, bBox.width),\r\n                height: _max(size.height || 0, bBox.height),\r\n                offset: _max(size.offset || 0, tick.labelOffset || 0)\r\n            }\r\n        }), {});\r\n        var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\r\n        this._adjustLabelsCoord(offset, maxSize.width);\r\n        return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0)\r\n    },\r\n    _getLabelAdjustedCoord: function(tick, offset, maxWidth) {\r\n        offset = offset || 0;\r\n        var options = this._options;\r\n        var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\r\n        var box = templateBox || rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\r\n        var textAlign = tick.labelAlignment || options.label.alignment;\r\n        var isDiscrete = \"discrete\" === this._options.type;\r\n        var isFlatLabel = tick.labelRotationAngle % 90 === 0;\r\n        var indentFromAxis = options.label.indentFromAxis;\r\n        var labelPosition = options.label.position;\r\n        var axisPosition = this._axisPosition;\r\n        var labelCoords = tick.labelCoords;\r\n        var labelX = labelCoords.x;\r\n        var translateX;\r\n        var translateY;\r\n        if (this._isHorizontal) {\r\n            if (labelPosition === BOTTOM) {\r\n                translateY = axisPosition + indentFromAxis - box.y + offset\r\n            } else {\r\n                translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset\r\n            }\r\n            if (textAlign === RIGHT) {\r\n                translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width\r\n            } else if (textAlign === LEFT) {\r\n                translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x\r\n            } else {\r\n                translateX = labelX - box.x - box.width / 2\r\n            }\r\n        } else {\r\n            translateY = labelCoords.y - box.y - box.height / 2;\r\n            if (labelPosition === LEFT) {\r\n                if (textAlign === LEFT) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth - box.x\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition - indentFromAxis - box.x - box.width\r\n                }\r\n                translateX -= offset\r\n            } else {\r\n                if (textAlign === RIGHT) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition + indentFromAxis - box.x\r\n                }\r\n                translateX += offset\r\n            }\r\n        }\r\n        return {\r\n            translateX: translateX,\r\n            translateY: translateY\r\n        }\r\n    },\r\n    _createAxisConstantLineGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        var constantLinesClass = classSelector + \"constant-lines\";\r\n        var insideGroup = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup1 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup2 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        return {\r\n            inside: insideGroup,\r\n            outside1: outsideGroup1,\r\n            left: outsideGroup1,\r\n            top: outsideGroup1,\r\n            outside2: outsideGroup2,\r\n            right: outsideGroup2,\r\n            bottom: outsideGroup2,\r\n            remove: function() {\r\n                this.inside.remove();\r\n                this.outside1.remove();\r\n                this.outside2.remove()\r\n            },\r\n            clear: function() {\r\n                this.inside.clear();\r\n                this.outside1.clear();\r\n                this.outside2.clear()\r\n            }\r\n        }\r\n    },\r\n    _createAxisGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        this._axisGroup = renderer.g().attr({\r\n            class: classSelector + \"axis\"\r\n        }).enableLinks();\r\n        this._axisStripGroup = renderer.g().attr({\r\n            class: classSelector + \"strips\"\r\n        });\r\n        this._axisGridGroup = renderer.g().attr({\r\n            class: classSelector + \"grid\"\r\n        });\r\n        this._axisElementsGroup = renderer.g().attr({\r\n            class: classSelector + \"elements\"\r\n        });\r\n        this._axisLineGroup = renderer.g().attr({\r\n            class: classSelector + \"line\"\r\n        }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\r\n        this._axisTitleGroup = renderer.g().attr({\r\n            class: classSelector + \"title\"\r\n        }).append(this._axisGroup);\r\n        this._axisConstantLineGroups = {\r\n            above: this._createAxisConstantLineGroups(),\r\n            under: this._createAxisConstantLineGroups()\r\n        };\r\n        this._axisStripLabelGroup = renderer.g().attr({\r\n            class: classSelector + \"axis-labels\"\r\n        })\r\n    },\r\n    _clearAxisGroups: function() {\r\n        this._axisGroup.remove();\r\n        this._axisStripGroup.remove();\r\n        this._axisStripLabelGroup.remove();\r\n        this._axisConstantLineGroups.above.remove();\r\n        this._axisConstantLineGroups.under.remove();\r\n        this._axisGridGroup.remove();\r\n        this._axisTitleGroup.clear();\r\n        if (!this._options.label.template || !this.isRendered()) {\r\n            this._axisElementsGroup.remove();\r\n            this._axisElementsGroup.clear()\r\n        }\r\n        this._axisLineGroup && this._axisLineGroup.clear();\r\n        this._axisStripGroup && this._axisStripGroup.clear();\r\n        this._axisGridGroup && this._axisGridGroup.clear();\r\n        this._axisConstantLineGroups.above.clear();\r\n        this._axisConstantLineGroups.under.clear();\r\n        this._axisStripLabelGroup && this._axisStripLabelGroup.clear()\r\n    },\r\n    _getLabelFormatObject: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        range = range || this._getViewportRange();\r\n        var formatObject = {\r\n            value: value,\r\n            valueText: _format(value, {\r\n                labelOptions: labelOptions,\r\n                ticks: ticks || convertTicksToValues(this._majorTicks),\r\n                tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\r\n                dataType: this._options.dataType,\r\n                logarithmBase: this._options.logarithmBase,\r\n                type: this._options.type,\r\n                showTransition: !this._options.marker.visible,\r\n                point: point\r\n            }) || \"\",\r\n            min: range.minVisible,\r\n            max: range.maxVisible\r\n        };\r\n        if (point) {\r\n            formatObject.point = point\r\n        }\r\n        return formatObject\r\n    },\r\n    formatLabel: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\r\n        return isFunction(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText\r\n    },\r\n    formatHint: function(value, labelOptions, range) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range);\r\n        return isFunction(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0\r\n    },\r\n    formatRange(startValue, endValue, interval) {\r\n        return formatRange(startValue, endValue, interval, this.getOptions())\r\n    },\r\n    _setTickOffset: function() {\r\n        var options = this._options;\r\n        var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\r\n        this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode)\r\n    },\r\n    resetApplyingAnimation: function(isFirstDrawing) {\r\n        this._resetApplyingAnimation = true;\r\n        if (isFirstDrawing) {\r\n            this._firstDrawing = true\r\n        }\r\n    },\r\n    isFirstDrawing() {\r\n        return this._firstDrawing\r\n    },\r\n    getMargins: function() {\r\n        var that = this;\r\n        var {\r\n            position: position,\r\n            offset: offset,\r\n            customPosition: customPosition,\r\n            placeholderSize: placeholderSize,\r\n            grid: grid,\r\n            tick: tick,\r\n            crosshairMargin: crosshairMargin\r\n        } = that._options;\r\n        var isDefinedCustomPositionOption = isDefined(customPosition);\r\n        var boundaryPosition = that.getResolvedBoundaryPosition();\r\n        var canvas = that.getCanvas();\r\n        var cLeft = canvas.left;\r\n        var cTop = canvas.top;\r\n        var cRight = canvas.width - canvas.right;\r\n        var cBottom = canvas.height - canvas.bottom;\r\n        var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\r\n        var constantLineAboveSeries = that._axisConstantLineGroups.above;\r\n        var constantLineUnderSeries = that._axisConstantLineGroups.under;\r\n        var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function(group) {\r\n            var box = group && group.getBBox();\r\n            if (!box || box.isEmpty) {\r\n                return box\r\n            }\r\n            if (that._isHorizontal) {\r\n                box.x = cLeft;\r\n                box.width = cRight - cLeft\r\n            } else {\r\n                box.y = cTop;\r\n                box.height = cBottom - cTop\r\n            }\r\n            return box\r\n        }(that._axisTitleGroup));\r\n        var margins = calculateCanvasMargins(boxes, canvas);\r\n        margins[position] += crosshairMargin;\r\n        if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\r\n            margins[boundaryPosition] = 0\r\n        }\r\n        if (placeholderSize) {\r\n            margins[position] = placeholderSize\r\n        }\r\n        if (edgeMarginCorrection) {\r\n            if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\r\n                margins.right = edgeMarginCorrection\r\n            }\r\n            if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\r\n                margins.bottom = edgeMarginCorrection\r\n            }\r\n        }\r\n        if (!isDefinedCustomPositionOption && isDefined(offset)) {\r\n            var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\r\n            margins[boundaryPosition] -= moveByOffset ? offset : 0\r\n        }\r\n        return margins\r\n    },\r\n    validateUnit: function(unit, idError, parameters) {\r\n        unit = this.parser(unit);\r\n        if (void 0 === unit && idError) {\r\n            this._incidentOccurred(idError, [parameters])\r\n        }\r\n        return unit\r\n    },\r\n    _setType: function(axisType, drawingType) {\r\n        var axisTypeMethods;\r\n        switch (axisType) {\r\n            case \"xyAxes\":\r\n                axisTypeMethods = xyMethods;\r\n                break;\r\n            case \"polarAxes\":\r\n                axisTypeMethods = polarMethods\r\n        }\r\n        extend(this, axisTypeMethods[drawingType])\r\n    },\r\n    _getSharpParam: function() {\r\n        return true\r\n    },\r\n    _disposeBreaksGroup: _noop,\r\n    dispose: function() {\r\n        [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach((function(g) {\r\n            g.dispose()\r\n        }));\r\n        this._strips = this._title = null;\r\n        this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\r\n        this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\r\n        this._axisGroup = this._axisTitleGroup = null;\r\n        this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\r\n        this._renderer = this._options = this._textOptions = this._textFontStyles = null;\r\n        this._translator = null;\r\n        this._majorTicks = this._minorTicks = null;\r\n        this._disposeBreaksGroup();\r\n        this._templatesRendered && this._templatesRendered.reject()\r\n    },\r\n    getOptions: function() {\r\n        return this._options\r\n    },\r\n    setPane: function(pane) {\r\n        this.pane = pane;\r\n        this._options.pane = pane\r\n    },\r\n    setTypes: function(type, axisType, typeSelector) {\r\n        this._options.type = type || this._options.type;\r\n        this._options[typeSelector] = axisType || this._options[typeSelector];\r\n        this._updateTranslator()\r\n    },\r\n    resetTypes: function(typeSelector) {\r\n        this._options.type = this._initTypes.type;\r\n        this._options[typeSelector] = this._initTypes[typeSelector]\r\n    },\r\n    getTranslator: function() {\r\n        return this._translator\r\n    },\r\n    updateOptions: function(options) {\r\n        var that = this;\r\n        var labelOpt = options.label;\r\n        validateAxisOptions(options);\r\n        that._options = options;\r\n        options.tick = options.tick || {};\r\n        options.minorTick = options.minorTick || {};\r\n        options.grid = options.grid || {};\r\n        options.minorGrid = options.minorGrid || {};\r\n        options.title = options.title || {};\r\n        options.marker = options.marker || {};\r\n        that._initTypes = {\r\n            type: options.type,\r\n            argumentType: options.argumentType,\r\n            valueType: options.valueType\r\n        };\r\n        that._setTickOffset();\r\n        that._isHorizontal = options.isHorizontal;\r\n        that.pane = options.pane;\r\n        that.name = options.name;\r\n        that.priority = options.priority;\r\n        that._hasLabelFormat = \"\" !== labelOpt.format && isDefined(labelOpt.format);\r\n        that._textOptions = {\r\n            opacity: labelOpt.opacity,\r\n            align: \"center\",\r\n            class: labelOpt.cssClass\r\n        };\r\n        that._textFontStyles = patchFontOptions(labelOpt.font);\r\n        if (options.type === constants.logarithmic) {\r\n            if (options.logarithmBaseError) {\r\n                that._incidentOccurred(\"E2104\");\r\n                delete options.logarithmBaseError\r\n            }\r\n        }\r\n        that._updateTranslator();\r\n        that._createConstantLines();\r\n        that._strips = (options.strips || []).map(o => createStrip(that, o));\r\n        that._majorTicks = that._minorTicks = null;\r\n        that._firstDrawing = true\r\n    },\r\n    calculateInterval: function(value, prevValue) {\r\n        var options = this._options;\r\n        if (!options || options.type !== constants.logarithmic) {\r\n            return _abs(value - prevValue)\r\n        }\r\n        var {\r\n            allowNegatives: allowNegatives,\r\n            linearThreshold: linearThreshold\r\n        } = new Range(this.getTranslator().getBusinessRange());\r\n        return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold))\r\n    },\r\n    getCanvasRange() {\r\n        var translator = this._translator;\r\n        return {\r\n            startValue: translator.from(translator.translate(\"canvas_position_start\")),\r\n            endValue: translator.from(translator.translate(\"canvas_position_end\"))\r\n        }\r\n    },\r\n    _processCanvas: function(canvas) {\r\n        return canvas\r\n    },\r\n    updateCanvas: function(canvas, canvasRedesign) {\r\n        if (!canvasRedesign) {\r\n            var positions = this._orthogonalPositions = {\r\n                start: !this._isHorizontal ? canvas.left : canvas.top,\r\n                end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\r\n            };\r\n            positions.center = positions.start + (positions.end - positions.start) / 2\r\n        } else {\r\n            this._orthogonalPositions = null\r\n        }\r\n        this._canvas = canvas;\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        this._initAxisPositions()\r\n    },\r\n    getCanvas: function() {\r\n        return this._canvas\r\n    },\r\n    getAxisShift() {\r\n        return this._axisShift || 0\r\n    },\r\n    hideTitle: function() {\r\n        if (this._options.title.text) {\r\n            this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisTitleGroup.clear()\r\n        }\r\n    },\r\n    getTitle: function() {\r\n        return this._title\r\n    },\r\n    hideOuterElements: function() {\r\n        var options = this._options;\r\n        if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\r\n            this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisElementsGroup.clear();\r\n            callAction(this._outsideConstantLines, \"removeLabel\")\r\n        }\r\n    },\r\n    _resolveLogarithmicOptionsForRange(range) {\r\n        var options = this._options;\r\n        if (options.type === constants.logarithmic) {\r\n            range.addRange({\r\n                allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\r\n            });\r\n            if (!isNaN(options.linearThreshold)) {\r\n                range.linearThreshold = options.linearThreshold\r\n            }\r\n        }\r\n    },\r\n    adjustViewport(businessRange) {\r\n        var options = this._options;\r\n        var isDiscrete = options.type === constants.discrete;\r\n        var categories = this._seriesData && this._seriesData.categories || [];\r\n        var wholeRange = this.adjustRange(getVizRangeObject(options.wholeRange));\r\n        var visualRange = this.getViewport() || {};\r\n        var result = new Range(businessRange);\r\n        this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\r\n        var minDefined = isDefined(visualRange.startValue);\r\n        var maxDefined = isDefined(visualRange.endValue);\r\n        if (!isDiscrete) {\r\n            minDefined = minDefined && (!isDefined(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\r\n            maxDefined = maxDefined && (!isDefined(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue)\r\n        }\r\n        var minVisible = minDefined ? visualRange.startValue : result.minVisible;\r\n        var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\r\n        if (!isDiscrete) {\r\n            var _wholeRange$startValu, _wholeRange$endValue;\r\n            result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\r\n            result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max\r\n        } else {\r\n            var categoriesInfo = getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\r\n            categories = categoriesInfo.categories;\r\n            result.categories = categories\r\n        }\r\n        var adjustedVisualRange = adjustVisualRange({\r\n            axisType: options.type,\r\n            dataType: options.dataType,\r\n            base: options.logarithmBase\r\n        }, {\r\n            startValue: minDefined ? visualRange.startValue : void 0,\r\n            endValue: maxDefined ? visualRange.endValue : void 0,\r\n            length: visualRange.length\r\n        }, {\r\n            categories: categories,\r\n            min: wholeRange.startValue,\r\n            max: wholeRange.endValue\r\n        }, {\r\n            categories: categories,\r\n            min: minVisible,\r\n            max: maxVisible\r\n        });\r\n        result.minVisible = adjustedVisualRange.startValue;\r\n        result.maxVisible = adjustedVisualRange.endValue;\r\n        !isDefined(result.min) && (result.min = result.minVisible);\r\n        !isDefined(result.max) && (result.max = result.maxVisible);\r\n        result.addRange({});\r\n        this._resolveLogarithmicOptionsForRange(result);\r\n        return result\r\n    },\r\n    adjustRange(range) {\r\n        range = range || {};\r\n        var isDiscrete = this._options.type === constants.discrete;\r\n        var isLogarithmic = this._options.type === constants.logarithmic;\r\n        var disabledNegatives = false === this._options.allowNegatives;\r\n        if (isLogarithmic) {\r\n            range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\r\n            range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue\r\n        }\r\n        if (!isDiscrete && isDefined(range.startValue) && isDefined(range.endValue) && range.startValue > range.endValue) {\r\n            var tmp = range.endValue;\r\n            range.endValue = range.startValue;\r\n            range.startValue = tmp\r\n        }\r\n        return range\r\n    },\r\n    _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\r\n        var value = this._options.visualRangeUpdateMode;\r\n        var translator = this._translator;\r\n        var range = this._seriesData;\r\n        if (this.isArgumentAxis) {\r\n            if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\r\n                if (range.axisType === constants.discrete) {\r\n                    var categories = range.categories;\r\n                    var newCategories = newRange.categories;\r\n                    var visualRange = this.visualRange();\r\n                    if (categories && newCategories && categories.length && -1 !== newCategories.map(c => c.valueOf()).join(\",\").indexOf(categories.map(c => c.valueOf()).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\r\n                        value = KEEP\r\n                    } else {\r\n                        value = RESET\r\n                    }\r\n                } else {\r\n                    var minPoint = translator.translate(range.min);\r\n                    var minVisiblePoint = translator.translate(viewport.startValue);\r\n                    var maxPoint = translator.translate(range.max);\r\n                    var maxVisiblePoint = translator.translate(viewport.endValue);\r\n                    if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = RESET\r\n                    } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = SHIFT\r\n                    } else {\r\n                        value = KEEP\r\n                    }\r\n                }\r\n            }\r\n        } else if (-1 === [KEEP, RESET].indexOf(value)) {\r\n            if (oppositeValue === KEEP) {\r\n                value = KEEP\r\n            } else {\r\n                value = RESET\r\n            }\r\n        }\r\n        return value\r\n    },\r\n    _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\r\n        var visualRange = this.visualRange();\r\n        if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\r\n            return\r\n        }\r\n        var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\r\n        var viewport = this.getViewport();\r\n        if (!isDefined(viewport.startValue) && !isDefined(viewport.endValue) && !isDefined(viewport.length)) {\r\n            visualRangeUpdateMode = RESET\r\n        } else {\r\n            this._prevDataWasEmpty && (visualRangeUpdateMode = KEEP)\r\n        }\r\n        if (visualRangeUpdateMode === KEEP) {\r\n            this._setVisualRange([visualRange.startValue, visualRange.endValue])\r\n        }\r\n        if (visualRangeUpdateMode === RESET) {\r\n            this._setVisualRange([null, null])\r\n        }\r\n        if (visualRangeUpdateMode === SHIFT) {\r\n            this._setVisualRange({\r\n                length: this.getVisualRangeLength()\r\n            })\r\n        }\r\n    },\r\n    getVisualRangeLength(range) {\r\n        var currentBusinessRange = range || this._translator.getBusinessRange();\r\n        var {\r\n            type: type\r\n        } = this._options;\r\n        var length;\r\n        if (type === constants.logarithmic) {\r\n            length = adjust(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible))\r\n        } else if (type === constants.discrete) {\r\n            var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            length = categoriesInfo.categories.length\r\n        } else {\r\n            length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible\r\n        }\r\n        return length\r\n    },\r\n    getVisualRangeCenter(range, useMerge) {\r\n        var translator = this.getTranslator();\r\n        var businessRange = translator.getBusinessRange();\r\n        var currentBusinessRange = useMerge ? extend(true, {}, businessRange, range || {}) : range || businessRange;\r\n        var {\r\n            type: type,\r\n            logarithmBase: logarithmBase\r\n        } = this._options;\r\n        var center;\r\n        if (!isDefined(currentBusinessRange.minVisible) || !isDefined(currentBusinessRange.maxVisible)) {\r\n            return\r\n        }\r\n        if (type === constants.logarithmic) {\r\n            var {\r\n                allowNegatives: allowNegatives,\r\n                linearThreshold: linearThreshold,\r\n                minVisible: minVisible,\r\n                maxVisible: maxVisible\r\n            } = currentBusinessRange;\r\n            center = raiseTo(adjust(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold)\r\n        } else if (type === constants.discrete) {\r\n            var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\r\n            center = businessRange.categories.indexOf(categoriesInfo.categories[index])\r\n        } else {\r\n            center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2)\r\n        }\r\n        return center\r\n    },\r\n    setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\r\n        var _that$_seriesData$min, _that$_seriesData$max;\r\n        var options = this._options;\r\n        var isDiscrete = options.type === constants.discrete;\r\n        this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\r\n        this._seriesData = new Range(range);\r\n        var dataIsEmpty = this._seriesData.isEmpty();\r\n        this._prevDataWasEmpty = dataIsEmpty;\r\n        this._seriesData.addRange({\r\n            categories: options.categories,\r\n            dataType: options.dataType,\r\n            axisType: options.type,\r\n            base: options.logarithmBase,\r\n            invert: options.inverted\r\n        });\r\n        this._resolveLogarithmicOptionsForRange(this._seriesData);\r\n        if (!isDiscrete) {\r\n            if (!isDefined(this._seriesData.min) && !isDefined(this._seriesData.max)) {\r\n                var visualRange = this.getViewport();\r\n                visualRange && this._seriesData.addRange({\r\n                    min: visualRange.startValue,\r\n                    max: visualRange.endValue\r\n                })\r\n            }\r\n            var synchronizedValue = options.synchronizedValue;\r\n            if (isDefined(synchronizedValue)) {\r\n                this._seriesData.addRange({\r\n                    min: synchronizedValue,\r\n                    max: synchronizedValue\r\n                })\r\n            }\r\n        }\r\n        this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\r\n        this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\r\n        if (!this.isArgumentAxis && options.showZero) {\r\n            this._seriesData.correctValueZeroLevel()\r\n        }\r\n        this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\r\n        this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {\r\n            if (cl.options.extendAxis) {\r\n                var value = cl.getParsedValue();\r\n                dataRange.addRange({\r\n                    [minValueField]: value,\r\n                    [maxValueField]: value\r\n                })\r\n            }\r\n        })\r\n    },\r\n    setGroupSeries: function(series) {\r\n        this._series = series\r\n    },\r\n    getLabelsPosition: function() {\r\n        var options = this._options;\r\n        var position = options.position;\r\n        var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\r\n        var axisPosition = this._axisPosition;\r\n        return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift\r\n    },\r\n    getFormattedValue: function(value, options, point) {\r\n        var labelOptions = this._options.label;\r\n        return isDefined(value) ? this.formatLabel(value, extend(true, {}, labelOptions, options), void 0, point) : null\r\n    },\r\n    _getBoundaryTicks: function(majors, viewPort) {\r\n        var length = majors.length;\r\n        var options = this._options;\r\n        var customBounds = options.customBoundTicks;\r\n        var min = viewPort.minVisible;\r\n        var max = viewPort.maxVisible;\r\n        var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\r\n        var boundaryTicks = [];\r\n        if (options.type === constants.discrete) {\r\n            if (this._tickOffset && 0 !== majors.length) {\r\n                boundaryTicks = [majors[0], majors[majors.length - 1]]\r\n            }\r\n        } else if (customBounds) {\r\n            if (addMinMax.min && isDefined(customBounds[0])) {\r\n                boundaryTicks.push(customBounds[0])\r\n            }\r\n            if (addMinMax.max && isDefined(customBounds[1])) {\r\n                boundaryTicks.push(customBounds[1])\r\n            }\r\n        } else {\r\n            if (addMinMax.min && (0 === length || majors[0] > min)) {\r\n                boundaryTicks.push(min)\r\n            }\r\n            if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\r\n                boundaryTicks.push(max)\r\n            }\r\n        }\r\n        return boundaryTicks\r\n    },\r\n    setPercentLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            this._options.label.format = \"percent\"\r\n        }\r\n    },\r\n    resetAutoLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            delete this._options.label.format\r\n        }\r\n    },\r\n    getMultipleAxesSpacing: function() {\r\n        return this._options.multipleAxesSpacing || 0\r\n    },\r\n    getTicksValues: function() {\r\n        return {\r\n            majorTicksValues: convertTicksToValues(this._majorTicks),\r\n            minorTicksValues: convertTicksToValues(this._minorTicks)\r\n        }\r\n    },\r\n    estimateTickInterval: function(canvas) {\r\n        this.updateCanvas(canvas);\r\n        return this._tickInterval !== this._getTicks(this._getViewportRange(), _noop, true).tickInterval\r\n    },\r\n    setTicks: function(ticks) {\r\n        var majors = ticks.majorTicks || [];\r\n        this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\r\n        this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\r\n        this._isSynchronized = true\r\n    },\r\n    _adjustDivisionFactor: function(val) {\r\n        return val\r\n    },\r\n    _getTicks: function(viewPort, incidentOccurred, skipTickGeneration) {\r\n        var options = this._options;\r\n        var customTicks = options.customTicks;\r\n        var customMinorTicks = options.customMinorTicks;\r\n        return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\r\n            min: viewPort.minVisible,\r\n            max: viewPort.maxVisible,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\r\n            majors: customTicks,\r\n            minors: customMinorTicks\r\n        }, options.minorTickInterval, options.minorTickCount, this._initialBreaks)\r\n    },\r\n    _createTicksAndLabelFormat: function(range, incidentOccurred) {\r\n        var options = this._options;\r\n        var ticks = this._getTicks(range, incidentOccurred, false);\r\n        if (!range.isEmpty() && options.type === constants.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\r\n            options.label.format = formatHelper.getDateFormatByTicks(ticks.ticks)\r\n        }\r\n        return ticks\r\n    },\r\n    getAggregationInfo(useAllAggregatedPoints, range) {\r\n        var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\r\n        var options = this._options;\r\n        var marginOptions = this._marginOptions;\r\n        var businessRange = new Range(this.getTranslator().getBusinessRange()).addRange(range);\r\n        var visualRange = this.getViewport();\r\n        var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\r\n        var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\r\n        var ticks = [];\r\n        if (options.type === constants.discrete && options.aggregateByCategory) {\r\n            return {\r\n                aggregateByCategory: true\r\n            }\r\n        }\r\n        var aggregationInterval = options.aggregationInterval;\r\n        var aggregationGroupWidth = options.aggregationGroupWidth;\r\n        if (!aggregationGroupWidth && marginOptions) {\r\n            if (marginOptions.checkInterval) {\r\n                aggregationGroupWidth = options.axisDivisionFactor\r\n            }\r\n            if (marginOptions.sizePointNormalState) {\r\n                aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor)\r\n            }\r\n        }\r\n        var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\r\n        var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\r\n        var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\r\n        if (options.type !== constants.discrete) {\r\n            var min = useAllAggregatedPoints ? businessRange.min : minVisible;\r\n            var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\r\n            if (isDefined(min) && isDefined(max)) {\r\n                var add = getAddFunction({\r\n                    base: options.logarithmBase,\r\n                    axisType: options.type,\r\n                    dataType: options.dataType\r\n                }, false);\r\n                var start = min;\r\n                var end = max;\r\n                if (!useAllAggregatedPoints) {\r\n                    var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\r\n                    start = add(min, maxMinDistance, -1);\r\n                    end = add(max, maxMinDistance)\r\n                }\r\n                start = start < businessRange.min ? businessRange.min : start;\r\n                end = end > businessRange.max ? businessRange.max : end;\r\n                var breaks = this._getScaleBreaks(options, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, this._series, this.isArgumentAxis);\r\n                var filteredBreaks = this._filterBreaks(breaks, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, options.breakStyle);\r\n                ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks\r\n            }\r\n        }\r\n        this._aggregationInterval = tickInterval;\r\n        return {\r\n            interval: tickInterval,\r\n            ticks: ticks\r\n        }\r\n    },\r\n    getTickInterval() {\r\n        return this._tickInterval\r\n    },\r\n    getAggregationInterval() {\r\n        return this._aggregationInterval\r\n    },\r\n    createTicks: function(canvas) {\r\n        var that = this;\r\n        var renderer = that._renderer;\r\n        var options = that._options;\r\n        if (!canvas) {\r\n            return\r\n        }\r\n        that._isSynchronized = false;\r\n        that.updateCanvas(canvas);\r\n        var range = that._getViewportRange();\r\n        that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\r\n        that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _noop, true).tickInterval;\r\n        var margins = this._calculateValueMargins();\r\n        range.addRange({\r\n            minVisible: margins.minValue,\r\n            maxVisible: margins.maxValue,\r\n            isSpacedMargin: margins.isSpacedMargin\r\n        });\r\n        var ticks = that._createTicksAndLabelFormat(range);\r\n        var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\r\n        if (options.showCustomBoundaryTicks && boundaryTicks.length) {\r\n            that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\r\n            if (boundaryTicks.length > 1) {\r\n                that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)))\r\n            }\r\n        } else {\r\n            that._boundaryTicks = []\r\n        }\r\n        var minors = (ticks.minorTicks || []).filter((function(minor) {\r\n            return !boundaryTicks.some((function(boundary) {\r\n                return valueOf(boundary) === valueOf(minor)\r\n            }))\r\n        }));\r\n        that._tickInterval = ticks.tickInterval;\r\n        that._minorTickInterval = ticks.minorTickInterval;\r\n        var oldMajorTicks = that._majorTicks || [];\r\n        var majorTicksByValues = oldMajorTicks.reduce((r, t) => {\r\n            r[t.value.valueOf()] = t;\r\n            return r\r\n        }, {});\r\n        var sameType = type(ticks.ticks[0]) === type(oldMajorTicks[0] && oldMajorTicks[0].value);\r\n        var skippedCategory = that._getSkippedCategory(ticks.ticks);\r\n        var majorTicks = ticks.ticks.map(v => {\r\n            var tick = majorTicksByValues[v.valueOf()];\r\n            if (tick && sameType) {\r\n                delete majorTicksByValues[v.valueOf()];\r\n                tick.setSkippedCategory(skippedCategory);\r\n                return tick\r\n            } else {\r\n                return createMajorTick(that, renderer, skippedCategory)(v)\r\n            }\r\n        });\r\n        that._majorTicks = majorTicks;\r\n        var oldMinorTicks = that._minorTicks || [];\r\n        that._minorTicks = minors.map((v, i) => {\r\n            var minorTick = oldMinorTicks[i];\r\n            if (minorTick) {\r\n                minorTick.updateValue(v);\r\n                return minorTick\r\n            }\r\n            return createMinorTick(that, renderer)(v)\r\n        });\r\n        that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\r\n        that._ticksToRemove.forEach(t => {\r\n            var _t$label;\r\n            return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle()\r\n        });\r\n        if (ticks.breaks) {\r\n            that._seriesData.breaks = ticks.breaks\r\n        }\r\n        that._reinitTranslator(that._getViewportRange())\r\n    },\r\n    _reinitTranslator: function(range) {\r\n        var translator = this._translator;\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        translator.updateBusinessRange(range)\r\n    },\r\n    _getViewportRange() {\r\n        return this.adjustViewport(this._seriesData)\r\n    },\r\n    setMarginOptions: function(options) {\r\n        this._marginOptions = options\r\n    },\r\n    getMarginOptions() {\r\n        var _this$_marginOptions;\r\n        return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {}\r\n    },\r\n    _calculateRangeInterval: function(interval) {\r\n        var isDateTime = \"datetime\" === this._options.dataType;\r\n        var minArgs = [];\r\n        var addToArgs = function(value) {\r\n            isDefined(value) && minArgs.push(isDateTime ? dateUtils.dateToMilliseconds(value) : value)\r\n        };\r\n        addToArgs(this._tickInterval);\r\n        addToArgs(this._estimatedTickInterval);\r\n        isDefined(interval) && minArgs.push(interval);\r\n        addToArgs(this._aggregationInterval);\r\n        return this._calculateWorkWeekInterval(_min.apply(this, minArgs))\r\n    },\r\n    _calculateWorkWeekInterval(businessInterval) {\r\n        var options = this._options;\r\n        if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\r\n            var workWeek = options.workWeek.length * dateIntervals.day;\r\n            var weekend = dateIntervals.week - workWeek;\r\n            if (workWeek !== businessInterval && weekend < businessInterval) {\r\n                var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\r\n                businessInterval -= weekend * weekendsCount\r\n            } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\r\n                businessInterval = dateIntervals.day\r\n            }\r\n        }\r\n        return businessInterval\r\n    },\r\n    _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\r\n        var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\r\n        return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta))\r\n    },\r\n    _calculateValueMargins(ticks) {\r\n        this._resetMargins();\r\n        var margins = this.getMarginOptions();\r\n        var marginSize = (margins.size || 0) / 2;\r\n        var options = this._options;\r\n        var dataRange = this._getViewportRange();\r\n        var viewPort = this.getViewport();\r\n        var screenDelta = this._getScreenDelta();\r\n        var isDiscrete = -1 !== (options.type || \"\").indexOf(constants.discrete);\r\n        var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\r\n        var translator = this._translator;\r\n        var minValueMargin = options.minValueMargin;\r\n        var maxValueMargin = options.maxValueMargin;\r\n        var minPadding = 0;\r\n        var maxPadding = 0;\r\n        var interval = 0;\r\n        var rangeInterval;\r\n        if (dataRange.stubData || !screenDelta) {\r\n            return {\r\n                startPadding: 0,\r\n                endPadding: 0\r\n            }\r\n        }\r\n        if (this.isArgumentAxis && margins.checkInterval) {\r\n            rangeInterval = this._calculateRangeInterval(dataRange.interval);\r\n            var pxInterval = translator.getInterval(rangeInterval);\r\n            if (isFinite(pxInterval)) {\r\n                interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)))\r\n            } else {\r\n                rangeInterval = 0\r\n            }\r\n        }\r\n        var minPercentPadding;\r\n        var maxPercentPadding;\r\n        var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\r\n        if (valueMarginsEnabled) {\r\n            if (isDefined(minValueMargin)) {\r\n                minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {\r\n                minPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                minPadding = Math.max(marginSize, interval);\r\n                minPadding = Math.min(maxPaddingValue, minPadding)\r\n            }\r\n            if (isDefined(maxValueMargin)) {\r\n                maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {\r\n                maxPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                maxPadding = Math.max(marginSize, interval);\r\n                maxPadding = Math.min(maxPaddingValue, maxPadding)\r\n            }\r\n        }\r\n        var percentStick = margins.percentStick && !this.isArgumentAxis;\r\n        if (percentStick) {\r\n            if (1 === _abs(dataRange.max)) {\r\n                maxPadding = 0\r\n            }\r\n            if (1 === _abs(dataRange.min)) {\r\n                minPadding = 0\r\n            }\r\n        }\r\n        var canvasStartEnd = this._getCanvasStartEnd();\r\n        var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\r\n        var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\r\n        if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\r\n            if (void 0 !== minPercentPadding) {\r\n                minPadding = screenDeltaWithMargins * minPercentPadding\r\n            }\r\n            if (void 0 !== maxPercentPadding) {\r\n                maxPadding = screenDeltaWithMargins * maxPercentPadding\r\n            }\r\n        }\r\n        var minValue;\r\n        var maxValue;\r\n        if (options.type !== constants.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\r\n            var length = ticks.length;\r\n            var firstTickPosition = translator.translate(ticks[0].value);\r\n            var lastTickPosition = translator.translate(ticks[length - 1].value);\r\n            var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\r\n            var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\r\n            var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\r\n            if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\r\n                var commonPadding = maxTickPadding + minTickPadding;\r\n                var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\r\n                if (minTickPadding >= minPadding) {\r\n                    minValue = ticks[0].value\r\n                }\r\n                if (maxTickPadding >= maxPadding) {\r\n                    maxValue = ticks[length - 1].value\r\n                }\r\n                minPadding = _max(minTickPadding, minPadding) / coeff;\r\n                maxPadding = _max(maxTickPadding, maxPadding) / coeff\r\n            }\r\n        }\r\n        minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\r\n        maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\r\n        if (!isDiscrete) {\r\n            if (this._translator.isInverted()) {\r\n                var _minValue, _maxValue;\r\n                minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1)\r\n            } else {\r\n                var _minValue2, _maxValue2;\r\n                minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1)\r\n            }\r\n        }\r\n        var {\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax,\r\n            start: start,\r\n            end: end\r\n        } = this.getCorrectedValuesToZero(minValue, maxValue);\r\n        minPadding = null !== start && void 0 !== start ? start : minPadding;\r\n        maxPadding = null !== end && void 0 !== end ? end : maxPadding;\r\n        return {\r\n            startPadding: translator.isInverted() ? maxPadding : minPadding,\r\n            endPadding: translator.isInverted() ? minPadding : maxPadding,\r\n            minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\r\n            maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\r\n            interval: rangeInterval,\r\n            isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\r\n        }\r\n    },\r\n    getCorrectedValuesToZero(minValue, maxValue) {\r\n        var that = this;\r\n        var translator = that._translator;\r\n        var canvasStartEnd = that._getCanvasStartEnd();\r\n        var dataRange = that._getViewportRange();\r\n        var screenDelta = that._getScreenDelta();\r\n        var options = that._options;\r\n        var start;\r\n        var end;\r\n        var correctedMin;\r\n        var correctedMax;\r\n        var correctZeroLevel = (minPoint, maxPoint) => {\r\n            var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\r\n            var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\r\n            var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\r\n            start = minExpectedPadding / coeff;\r\n            end = maxExpectedPadding / coeff\r\n        };\r\n        if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\r\n            if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\r\n                correctZeroLevel(translator.translate(0), translator.translate(maxValue));\r\n                correctedMin = 0\r\n            }\r\n            if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\r\n                correctZeroLevel(translator.translate(minValue), translator.translate(0));\r\n                correctedMax = 0\r\n            }\r\n        }\r\n        return {\r\n            start: isFinite(start) ? start : null,\r\n            end: isFinite(end) ? end : null,\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax\r\n        }\r\n    },\r\n    applyMargins() {\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        var margins = this._calculateValueMargins(this._majorTicks);\r\n        var canvas = extend({}, this._canvas, {\r\n            startPadding: margins.startPadding,\r\n            endPadding: margins.endPadding\r\n        });\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        if (isFinite(margins.interval)) {\r\n            var br = this._translator.getBusinessRange();\r\n            br.addRange({\r\n                interval: margins.interval\r\n            });\r\n            this._translator.updateBusinessRange(br)\r\n        }\r\n    },\r\n    _resetMargins: function() {\r\n        this._reinitTranslator(this._getViewportRange());\r\n        if (this._canvas) {\r\n            this._translator.updateCanvas(this._processCanvas(this._canvas))\r\n        }\r\n    },\r\n    _createConstantLines() {\r\n        var constantLines = (this._options.constantLines || []).map(o => createConstantLine(this, o));\r\n        this._outsideConstantLines = constantLines.filter(l => \"outside\" === l.labelPosition);\r\n        this._insideConstantLines = constantLines.filter(l => \"inside\" === l.labelPosition)\r\n    },\r\n    draw: function(canvas, borderOptions) {\r\n        var that = this;\r\n        var options = this._options;\r\n        that.borderOptions = borderOptions || {\r\n            visible: false\r\n        };\r\n        that._resetMargins();\r\n        that.createTicks(canvas);\r\n        that.applyMargins();\r\n        that._clearAxisGroups();\r\n        initTickCoords(that._majorTicks);\r\n        initTickCoords(that._minorTicks);\r\n        initTickCoords(that._boundaryTicks);\r\n        that._axisGroup.append(that._axesContainerGroup);\r\n        that._drawAxis();\r\n        that._drawTitle();\r\n        drawTickMarks(that._majorTicks, options.tick);\r\n        drawTickMarks(that._minorTicks, options.minorTick);\r\n        drawTickMarks(that._boundaryTicks, options.tick);\r\n        var drawGridLine = that._getGridLineDrawer();\r\n        drawGrids(that._majorTicks, drawGridLine);\r\n        drawGrids(that._minorTicks, drawGridLine);\r\n        callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\r\n        that._templatesRendered && that._templatesRendered.reject();\r\n        that._templatesRendered = new Deferred;\r\n        when.apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {\r\n            that._templatesRendered.resolve()\r\n        });\r\n        that._majorTicks.forEach((function(tick) {\r\n            tick.labelRotationAngle = 0;\r\n            tick.labelAlignment = void 0;\r\n            tick.labelOffset = 0\r\n        }));\r\n        callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\r\n        callAction(that._strips, \"draw\");\r\n        that._dateMarkers = that._drawDateMarkers() || [];\r\n        that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\r\n        that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\r\n        that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\r\n        that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\r\n        if (that._constantLinesGroup) {\r\n            that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under)\r\n        }\r\n        that._measureTitle();\r\n        measureLabels(that._majorTicks);\r\n        !options.label.template && that._applyWordWrap();\r\n        measureLabels(that._outsideConstantLines);\r\n        measureLabels(that._insideConstantLines);\r\n        measureLabels(that._strips);\r\n        measureLabels(that._dateMarkers);\r\n        that._adjustConstantLineLabels(that._insideConstantLines);\r\n        that._adjustStripLabels();\r\n        var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\r\n        if (!that._translator.getBusinessRange().isEmpty()) {\r\n            that._setLabelsPlacement();\r\n            offset = that._adjustLabels(offset)\r\n        }\r\n        offset = that._adjustDateMarkers(offset);\r\n        that._adjustTitle(offset)\r\n    },\r\n    getTemplatesDef() {\r\n        return this._templatesRendered\r\n    },\r\n    setRenderedState(state) {\r\n        this._drawn = state\r\n    },\r\n    isRendered() {\r\n        return this._drawn\r\n    },\r\n    _applyWordWrap() {\r\n        var convertedTickInterval;\r\n        var textWidth;\r\n        var textHeight;\r\n        var options = this._options;\r\n        var tickInterval = this._tickInterval;\r\n        if (isDefined(tickInterval)) {\r\n            convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval)\r\n        }\r\n        var displayMode = this._validateDisplayMode(options.label.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\r\n        var wordWrapMode = options.label.wordWrap || \"none\";\r\n        var overflowMode = options.label.textOverflow || \"none\";\r\n        if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\r\n            var usefulSpace = isDefined(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\r\n            if (this._isHorizontal) {\r\n                textWidth = convertedTickInterval;\r\n                textHeight = usefulSpace\r\n            } else {\r\n                textWidth = usefulSpace;\r\n                textHeight = convertedTickInterval\r\n            }\r\n            var correctByWidth = false;\r\n            var correctByHeight = false;\r\n            if (textWidth) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {\r\n                    correctByWidth = true\r\n                }\r\n            }\r\n            if (textHeight) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {\r\n                    correctByHeight = true\r\n                }\r\n            }\r\n            if (correctByWidth || correctByHeight) {\r\n                this._majorTicks.forEach(tick => {\r\n                    tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label)\r\n                });\r\n                measureLabels(this._majorTicks)\r\n            }\r\n        }\r\n    },\r\n    _measureTitle: _noop,\r\n    animate() {\r\n        callAction(this._majorTicks, \"animateLabels\")\r\n    },\r\n    updateSize(canvas, animate) {\r\n        var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\r\n        this.updateCanvas(canvas);\r\n        if (updateTitle) {\r\n            this._checkTitleOverflow();\r\n            this._measureTitle();\r\n            this._updateTitleCoords()\r\n        }\r\n        this._reinitTranslator(this._getViewportRange());\r\n        this.applyMargins();\r\n        var animationEnabled = !this._firstDrawing && animate;\r\n        var options = this._options;\r\n        initTickCoords(this._majorTicks);\r\n        initTickCoords(this._minorTicks);\r\n        initTickCoords(this._boundaryTicks);\r\n        if (this._resetApplyingAnimation && !this._firstDrawing) {\r\n            this._resetStartCoordinates()\r\n        }\r\n        cleanUpInvalidTicks(this._majorTicks);\r\n        cleanUpInvalidTicks(this._minorTicks);\r\n        cleanUpInvalidTicks(this._boundaryTicks);\r\n        if (this._axisElement) {\r\n            this._updateAxisElementPosition()\r\n        }\r\n        updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\r\n        updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\r\n        updateTicksPosition(this._boundaryTicks, options.tick);\r\n        callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));\r\n        callAction(this._strips, \"updatePosition\", animationEnabled);\r\n        updateGridsPosition(this._majorTicks, animationEnabled);\r\n        updateGridsPosition(this._minorTicks, animationEnabled);\r\n        if (animationEnabled) {\r\n            callAction(this._ticksToRemove || [], \"fadeOutElements\")\r\n        }\r\n        this.prepareAnimation();\r\n        this._ticksToRemove = null;\r\n        if (!this._translator.getBusinessRange().isEmpty()) {\r\n            this._firstDrawing = false\r\n        }\r\n        this._resetApplyingAnimation = false;\r\n        this._updateLabelsPosition()\r\n    },\r\n    _updateLabelsPosition: _noop,\r\n    prepareAnimation() {\r\n        var action = \"saveCoords\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    _resetStartCoordinates() {\r\n        var action = \"resetCoordinates\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    applyClipRects: function(elementsClipID, canvasClipID) {\r\n        this._axisGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        });\r\n        this._axisStripGroup.attr({\r\n            \"clip-path\": elementsClipID\r\n        });\r\n        this._axisElementsGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        })\r\n    },\r\n    _validateVisualRange(optionValue) {\r\n        var range = getVizRangeObject(optionValue);\r\n        if (void 0 !== range.startValue) {\r\n            range.startValue = this.validateUnit(range.startValue)\r\n        }\r\n        if (void 0 !== range.endValue) {\r\n            range.endValue = this.validateUnit(range.endValue)\r\n        }\r\n        return convertVisualRangeObject(range, !_isArray(optionValue))\r\n    },\r\n    _validateOptions(options) {\r\n        options.wholeRange = this._validateVisualRange(options.wholeRange);\r\n        options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\r\n        this._setVisualRange(options._customVisualRange)\r\n    },\r\n    validate() {\r\n        var options = this._options;\r\n        var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\r\n        var parser = dataType ? getParser(dataType) : function(unit) {\r\n            return unit\r\n        };\r\n        this.parser = parser;\r\n        options.dataType = dataType;\r\n        this._validateOptions(options)\r\n    },\r\n    resetVisualRange(isSilent) {\r\n        this._seriesData.minVisible = this._seriesData.min;\r\n        this._seriesData.maxVisible = this._seriesData.max;\r\n        this.handleZooming([null, null], {\r\n            start: !!isSilent,\r\n            end: !!isSilent\r\n        })\r\n    },\r\n    _setVisualRange(visualRange, allowPartialUpdate) {\r\n        var range = this.adjustRange(getVizRangeObject(visualRange));\r\n        if (allowPartialUpdate) {\r\n            isDefined(range.startValue) && (this._viewport.startValue = range.startValue);\r\n            isDefined(range.endValue) && (this._viewport.endValue = range.endValue)\r\n        } else {\r\n            this._viewport = range\r\n        }\r\n    },\r\n    _applyZooming(visualRange, allowPartialUpdate) {\r\n        this._resetVisualRangeOption();\r\n        this._setVisualRange(visualRange, allowPartialUpdate);\r\n        var viewPort = this.getViewport();\r\n        this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\r\n            minVisible: viewPort.startValue,\r\n            maxVisible: viewPort.endValue\r\n        }, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    getZoomStartEventArg(event, actionType) {\r\n        return {\r\n            axis: this,\r\n            range: this.visualRange(),\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType\r\n        }\r\n    },\r\n    _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\r\n        var newRange = this.visualRange();\r\n        return {\r\n            axis: this,\r\n            previousRange: previousRange,\r\n            range: newRange,\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType,\r\n            zoomFactor: zoomFactor,\r\n            shift: shift,\r\n            rangeStart: newRange.startValue,\r\n            rangeEnd: newRange.endValue\r\n        }\r\n    },\r\n    getZoomBounds() {\r\n        var wholeRange = getVizRangeObject(this._options.wholeRange);\r\n        var range = this.getTranslator().getBusinessRange();\r\n        var secondPriorityRange = {\r\n            startValue: getZoomBoundValue(this._initRange.startValue, range.min),\r\n            endValue: getZoomBoundValue(this._initRange.endValue, range.max)\r\n        };\r\n        return {\r\n            startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\r\n            endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\r\n        }\r\n    },\r\n    setInitRange() {\r\n        this._initRange = {};\r\n        if (0 === Object.keys(this._options.wholeRange || {}).length) {\r\n            this._initRange = this.getZoomBounds()\r\n        }\r\n    },\r\n    _resetVisualRangeOption() {\r\n        this._options._customVisualRange = {}\r\n    },\r\n    getTemplatesGroups() {\r\n        var ticks = this._majorTicks;\r\n        if (ticks) {\r\n            return this._majorTicks.map(tick => tick.templateContainer).filter(item => isDefined(item))\r\n        } else {\r\n            return []\r\n        }\r\n    },\r\n    setCustomVisualRange(range) {\r\n        this._options._customVisualRange = range\r\n    },\r\n    visualRange() {\r\n        var args = arguments;\r\n        var visualRange;\r\n        if (0 === args.length) {\r\n            var adjustedRange = this._getAdjustedBusinessRange();\r\n            var startValue = adjustedRange.minVisible;\r\n            var endValue = adjustedRange.maxVisible;\r\n            if (this._options.type === constants.discrete) {\r\n                var _startValue, _endValue;\r\n                startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\r\n                endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\r\n                return {\r\n                    startValue: startValue,\r\n                    endValue: endValue,\r\n                    categories: getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\r\n                }\r\n            }\r\n            return {\r\n                startValue: startValue,\r\n                endValue: endValue\r\n            }\r\n        } else if (_isArray(args[0])) {\r\n            visualRange = args[0]\r\n        } else if (isPlainObject(args[0])) {\r\n            visualRange = extend({}, args[0])\r\n        } else {\r\n            visualRange = [args[0], args[1]]\r\n        }\r\n        var zoomResults = this.handleZooming(visualRange, args[1]);\r\n        if (!zoomResults.isPrevented) {\r\n            this._visualRange(this, zoomResults)\r\n        }\r\n    },\r\n    handleZooming(visualRange, preventEvents, domEvent, action) {\r\n        preventEvents = preventEvents || {};\r\n        if (isDefined(visualRange)) {\r\n            visualRange = this._validateVisualRange(visualRange);\r\n            visualRange.action = action\r\n        }\r\n        var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\r\n        var previousRange = zoomStartEvent.range;\r\n        !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\r\n        var zoomResults = {\r\n            isPrevented: zoomStartEvent.cancel,\r\n            skipEventRising: preventEvents.skipEventRising,\r\n            range: visualRange || zoomStartEvent.range\r\n        };\r\n        if (!zoomStartEvent.cancel) {\r\n            isDefined(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\r\n            if (!isDefined(this._storedZoomEndParams)) {\r\n                this._storedZoomEndParams = {\r\n                    startRange: previousRange,\r\n                    type: this.getOptions().type\r\n                }\r\n            }\r\n            this._storedZoomEndParams.event = domEvent;\r\n            this._storedZoomEndParams.action = action;\r\n            this._storedZoomEndParams.prevent = !!preventEvents.end\r\n        }\r\n        return zoomResults\r\n    },\r\n    handleZoomEnd() {\r\n        if (isDefined(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\r\n            var previousRange = this._storedZoomEndParams.startRange;\r\n            var domEvent = this._storedZoomEndParams.event;\r\n            var action = this._storedZoomEndParams.action;\r\n            var previousBusinessRange = {\r\n                minVisible: previousRange.startValue,\r\n                maxVisible: previousRange.endValue,\r\n                categories: previousRange.categories\r\n            };\r\n            var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\r\n            var shift = typeIsNotChanged ? adjust(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\r\n            var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\r\n            var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\r\n            zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\r\n            this._eventTrigger(\"zoomEnd\", zoomEndEvent);\r\n            if (zoomEndEvent.cancel) {\r\n                this._restorePreviousVisualRange(previousRange)\r\n            }\r\n            this._storedZoomEndParams = null\r\n        }\r\n    },\r\n    _restorePreviousVisualRange(previousRange) {\r\n        this._storedZoomEndParams = null;\r\n        this._applyZooming(previousRange);\r\n        this._visualRange(this, previousRange)\r\n    },\r\n    checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\r\n        var options = this._options;\r\n        var translator = this._translator;\r\n        var minZoom = options.minVisualRangeLength;\r\n        var correctedRange = range;\r\n        var visualRange;\r\n        var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\r\n        var businessRange = translator.getBusinessRange();\r\n        if (range) {\r\n            visualRange = this.adjustRange(getVizRangeObject(range));\r\n            visualRange = {\r\n                minVisible: visualRange.startValue,\r\n                maxVisible: visualRange.endValue,\r\n                categories: businessRange.categories\r\n            }\r\n        }\r\n        var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\r\n        var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\r\n        if (isDefined(minZoom) || \"discrete\" === options.type) {\r\n            minZoom = translator.convert(minZoom);\r\n            if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\r\n                correctedRange = getVizRangeObject(translator.getRangeByMinZoomValue(minZoom, visualRange));\r\n                isOvercoming = false\r\n            } else {\r\n                isOvercoming &= minZoom > afterVisualRangeLength\r\n            }\r\n        } else {\r\n            var canvasLength = this._translator.canvasLength;\r\n            var fullRange = {\r\n                minVisible: businessRange.min,\r\n                maxVisible: businessRange.max,\r\n                categories: businessRange.categories\r\n            };\r\n            isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength\r\n        }\r\n        return {\r\n            stopInteraction: !!isOvercoming,\r\n            correctedRange: correctedRange\r\n        }\r\n    },\r\n    isExtremePosition(isMax) {\r\n        var extremeDataValue;\r\n        var seriesData;\r\n        if (\"discrete\" === this._options.type) {\r\n            seriesData = this._translator.getBusinessRange();\r\n            extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0]\r\n        } else {\r\n            seriesData = this.getZoomBounds();\r\n            extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue\r\n        }\r\n        var translator = this.getTranslator();\r\n        var extremePoint = translator.translate(extremeDataValue);\r\n        var visualRange = this.visualRange();\r\n        var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\r\n        return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD\r\n    },\r\n    getViewport() {\r\n        return this._viewport\r\n    },\r\n    getFullTicks: function() {\r\n        var majors = this._majorTicks || [];\r\n        if (this._options.type === constants.discrete) {\r\n            return convertTicksToValues(majors)\r\n        } else {\r\n            return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort((function(a, b) {\r\n                return valueOf(a) - valueOf(b)\r\n            }))\r\n        }\r\n    },\r\n    measureLabels: function(canvas, withIndents) {\r\n        var that = this;\r\n        var options = that._options;\r\n        var widthAxis = options.visible ? options.width : 0;\r\n        var ticks;\r\n        var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\r\n        var tickInterval;\r\n        var viewportRange = that._getViewportRange();\r\n        if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\r\n            return {\r\n                height: widthAxis,\r\n                width: widthAxis,\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        }\r\n        if (that._majorTicks) {\r\n            ticks = convertTicksToValues(that._majorTicks)\r\n        } else {\r\n            that.updateCanvas(canvas);\r\n            ticks = that._createTicksAndLabelFormat(viewportRange, _noop);\r\n            tickInterval = ticks.tickInterval;\r\n            ticks = ticks.ticks\r\n        }\r\n        var maxText = ticks.reduce((function(prevLabel, tick, index) {\r\n            var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\r\n            if (prevLabel.length < label.length) {\r\n                return label\r\n            } else {\r\n                return prevLabel\r\n            }\r\n        }), that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\r\n        var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\r\n        var box = text.getBBox();\r\n        text.remove();\r\n        return {\r\n            x: box.x,\r\n            y: box.y,\r\n            width: box.width + indent,\r\n            height: box.height + indent\r\n        }\r\n    },\r\n    _setLabelsPlacement: function() {\r\n        if (!this._options.label.visible) {\r\n            return\r\n        }\r\n        var labelOpt = this._options.label;\r\n        var displayMode = this._validateDisplayMode(labelOpt.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\r\n        var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\r\n        var behavior = {\r\n            rotationAngle: labelOpt.rotationAngle,\r\n            staggeringSpacing: labelOpt.staggeringSpacing\r\n        };\r\n        var notRecastStep;\r\n        var boxes = this._majorTicks.map((function(tick) {\r\n            return tick.labelBBox\r\n        }));\r\n        var step = this._getStep(boxes);\r\n        switch (displayMode) {\r\n            case ROTATE:\r\n                if (ignoreOverlapping) {\r\n                    notRecastStep = true;\r\n                    step = 1\r\n                }\r\n                this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\r\n                break;\r\n            case \"stagger\":\r\n                if (ignoreOverlapping) {\r\n                    step = 2\r\n                }\r\n                this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\r\n                break;\r\n            default:\r\n                this._applyLabelOverlapping(boxes, overlappingMode, step, behavior)\r\n        }\r\n    },\r\n    _applyLabelOverlapping: function(boxes, mode, step, behavior) {\r\n        var labelOpt = this._options.label;\r\n        var majorTicks = this._majorTicks;\r\n        if (\"none\" === mode || \"ignore\" === mode) {\r\n            return\r\n        }\r\n        if (step > 1 && boxes.some((function(box, index, array) {\r\n                if (0 === index) {\r\n                    return false\r\n                }\r\n                return constants.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment)\r\n            }))) {\r\n            this._applyLabelMode(mode, step, boxes, behavior)\r\n        }\r\n        this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\r\n        this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment)\r\n    },\r\n    _applyLabelMode: function(mode, step, boxes, behavior, notRecastStep) {\r\n        var majorTicks = this._majorTicks;\r\n        var labelOpt = this._options.label;\r\n        var angle = behavior.rotationAngle;\r\n        var labelHeight;\r\n        var alignment;\r\n        var func;\r\n        switch (mode) {\r\n            case ROTATE:\r\n                if (!labelOpt.userAlignment) {\r\n                    alignment = angle < 0 ? RIGHT : LEFT;\r\n                    if (angle % 90 === 0) {\r\n                        alignment = CENTER\r\n                    }\r\n                }\r\n                step = notRecastStep ? step : this._getStep(boxes, angle);\r\n                func = function(tick) {\r\n                    var contentContainer = tick.getContentContainer();\r\n                    if (!contentContainer) {\r\n                        return\r\n                    }\r\n                    contentContainer.rotate(angle);\r\n                    tick.labelRotationAngle = angle;\r\n                    alignment && (tick.labelAlignment = alignment)\r\n                };\r\n                updateLabels(majorTicks, step, func);\r\n                break;\r\n            case \"stagger\":\r\n                labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\r\n                func = function(tick, index) {\r\n                    if (index / (step - 1) % 2 !== 0) {\r\n                        tick.labelOffset = labelHeight\r\n                    }\r\n                };\r\n                updateLabels(majorTicks, step - 1, func);\r\n                break;\r\n            case \"auto\":\r\n            case \"_auto\":\r\n                if (2 === step) {\r\n                    this._applyLabelMode(\"stagger\", step, boxes, behavior)\r\n                } else {\r\n                    this._applyLabelMode(ROTATE, step, boxes, {\r\n                        rotationAngle: getOptimalAngle(boxes, labelOpt)\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                updateLabels(majorTicks, step)\r\n        }\r\n    },\r\n    getMarkerTrackers: _noop,\r\n    _drawDateMarkers: _noop,\r\n    _adjustDateMarkers: _noop,\r\n    coordsIn: _noop,\r\n    areCoordsOutsideAxis: _noop,\r\n    _getSkippedCategory: _noop,\r\n    _initAxisPositions: _noop,\r\n    _drawTitle: _noop,\r\n    _updateTitleCoords: _noop,\r\n    _adjustConstantLineLabels: _noop,\r\n    _createTranslator: function() {\r\n        return new Translator2D({}, {}, {})\r\n    },\r\n    _updateTranslator: function() {\r\n        var translator = this._translator;\r\n        translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions())\r\n    },\r\n    _getTranslatorOptions: function() {\r\n        var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\r\n        var options = this._options;\r\n        return {\r\n            isHorizontal: this._isHorizontal,\r\n            shiftZeroValue: !this.isArgumentAxis,\r\n            interval: options.semiDiscreteInterval,\r\n            firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\r\n            stick: this._getStick(),\r\n            breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\r\n        }\r\n    },\r\n    getVisibleArea() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        return [canvas.start, canvas.end].sort((a, b) => a - b)\r\n    },\r\n    _getCanvasStartEnd: function() {\r\n        var isHorizontal = this._isHorizontal;\r\n        var canvas = this._canvas || {};\r\n        var invert = this._translator.getBusinessRange().invert;\r\n        var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\r\n        invert && coords.reverse();\r\n        return {\r\n            start: coords[0],\r\n            end: coords[1]\r\n        }\r\n    },\r\n    _getScreenDelta: function() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\r\n        var breaksLength = breaks.length;\r\n        var screenDelta = _abs(canvas.start - canvas.end);\r\n        return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0)\r\n    },\r\n    _getScaleBreaks: function() {\r\n        return []\r\n    },\r\n    _filterBreaks: function() {\r\n        return []\r\n    },\r\n    _adjustTitle: _noop,\r\n    _checkTitleOverflow: _noop,\r\n    getSpiderTicks: _noop,\r\n    setSpiderTicks: _noop,\r\n    _checkBoundedLabelsOverlapping: _noop,\r\n    _checkShiftedLabels: _noop,\r\n    drawScaleBreaks: _noop,\r\n    _visualRange: _noop,\r\n    _rotateConstantLine: _noop,\r\n    applyVisualRangeSetter(visualRangeSetter) {\r\n        this._visualRange = visualRangeSetter\r\n    },\r\n    getCategoriesSorter(argCategories) {\r\n        var sort;\r\n        if (this.isArgumentAxis) {\r\n            sort = argCategories\r\n        } else {\r\n            var categoriesSortingMethod = this._options.categoriesSortingMethod;\r\n            sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories\r\n        }\r\n        return sort\r\n    },\r\n    _getAdjustedBusinessRange() {\r\n        return this.adjustViewport(this._translator.getBusinessRange())\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}