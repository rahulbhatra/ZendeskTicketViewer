{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/tick.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { Deferred } from \"../../core/utils/deferred\";\n\nfunction getPathStyle(options) {\n  return {\n    stroke: options.color,\n    \"stroke-width\": options.width,\n    \"stroke-opacity\": options.opacity,\n    opacity: 1\n  };\n}\n\nfunction createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {\n  var tickOffset = offset || axis._tickOffset;\n  var lineGroup = axis._axisLineGroup;\n  var elementsGroup = axis._axisElementsGroup;\n  var tickStyle = getPathStyle(tickOptions);\n  var gridStyle = getPathStyle(gridOptions);\n  var emptyStrRegExp = /^\\s+$/;\n  var axisOptions = axis.getOptions();\n  var labelOptions = axisOptions.label;\n  var labelStyle = axis._textOptions;\n\n  function getLabelFontStyle(tick) {\n    var fontStyle = axis._textFontStyles;\n    var customizeColor = labelOptions.customizeColor;\n\n    if (customizeColor && customizeColor.call) {\n      fontStyle = extend({}, axis._textFontStyles, {\n        fill: customizeColor.call(tick, tick)\n      });\n    }\n\n    return fontStyle;\n  }\n\n  function createLabelHint(tick, range) {\n    var labelHint = axis.formatHint(tick.value, labelOptions, range);\n\n    if (isDefined(labelHint) && \"\" !== labelHint) {\n      tick.getContentContainer().setTitle(labelHint);\n    }\n  }\n\n  return function (value) {\n    var tick = {\n      value: value,\n\n      updateValue(newValue) {\n        this.value = value = newValue;\n      },\n\n      initCoords: function () {\n        this.coords = axis._getTranslatedValue(value, tickOffset);\n        this.labelCoords = axis._getTranslatedValue(value);\n      },\n\n      saveCoords() {\n        this._lastStoredCoordinates = {\n          coords: this._storedCoords,\n          labelCoords: this._storedLabelsCoords\n        };\n        this._storedCoords = this.coords;\n        this._storedLabelsCoords = this.templateContainer ? this._getTemplateCoords() : this.labelCoords;\n      },\n\n      resetCoordinates() {\n        if (this._lastStoredCoordinates) {\n          this._storedCoords = this._lastStoredCoordinates.coords;\n          this._storedLabelsCoords = this._lastStoredCoordinates.labelCoords;\n        }\n      },\n\n      drawMark(options) {\n        if (!tickOptions.visible || skippedCategory === value) {\n          return;\n        }\n\n        if (axis.areCoordsOutsideAxis(this.coords)) {\n          return;\n        }\n\n        if (this.mark) {\n          this.mark.append(lineGroup);\n          axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));\n          this.updateTickPosition(options);\n        } else {\n          this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);\n          this.updateTickPosition(options);\n        }\n      },\n\n      setSkippedCategory(category) {\n        skippedCategory = category;\n      },\n\n      _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {\n        if (!lineElement) {\n          return;\n        }\n\n        if (null === settings.points || null === settings.r) {\n          lineElement.remove();\n          return;\n        }\n\n        if (animate && storedSettings && null !== storedSettings.points) {\n          settings.opacity = 1;\n          lineElement.attr(storedSettings);\n          lineElement.animate(settings);\n        } else {\n          settings.opacity = animate ? 0 : 1;\n          lineElement.attr(settings);\n          animate && lineElement.animate({\n            opacity: 1\n          }, {\n            delay: .5,\n            partitionDuration: .5\n          });\n        }\n\n        this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine);\n      },\n\n      updateTickPosition: function (options, animate) {\n        this._updateLine(this.mark, {\n          points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)\n        }, this._storedCoords && {\n          points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)\n        }, animate, false);\n      },\n      drawLabel: function (range, template) {\n        if (this.templateContainer && axis.isRendered()) {\n          this.updateLabelPosition();\n          return;\n        }\n\n        var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);\n\n        if (!labelIsVisible) {\n          if (this.label) {\n            this.removeLabel();\n          }\n\n          return;\n        }\n\n        var templateOption = labelOptions.template;\n        var text = axis.formatLabel(value, labelOptions, range);\n\n        if (this.label) {\n          this.label.attr({\n            text: text,\n            rotate: 0\n          }).append(elementsGroup);\n          createLabelHint(this, range);\n          this.updateLabelPosition();\n          return;\n        }\n\n        if (templateOption) {\n          this.templateContainer = renderer.g().append(elementsGroup);\n          this._templateDef && this._templateDef.reject();\n          this._templateDef = new Deferred();\n          template.render({\n            model: {\n              valueText: text,\n              value: this.value,\n              labelFontStyle: getLabelFontStyle(this),\n              labelStyle: labelStyle\n            },\n            container: this.templateContainer.element,\n            onRendered: () => {\n              this.updateLabelPosition();\n              this._templateDef && this._templateDef.resolve();\n            }\n          });\n        } else if (isDefined(text) && \"\" !== text && !emptyStrRegExp.test(text)) {\n          this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).append(elementsGroup);\n          this.updateLabelPosition();\n          createLabelHint(this, range);\n        }\n\n        var containerForData = this.getContentContainer();\n        containerForData && containerForData.data(\"chart-data-argument\", this.value);\n        this.templateContainer && createLabelHint(this, range);\n      },\n\n      getTemplateDeferred() {\n        return this._templateDef;\n      },\n\n      getContentContainer() {\n        return this.templateContainer || this.label;\n      },\n\n      fadeOutElements() {\n        var startSettings = {\n          opacity: 1\n        };\n        var endSettings = {\n          opacity: 0\n        };\n        var animationSettings = {\n          partitionDuration: .5\n        };\n\n        if (this.getContentContainer()) {\n          this._fadeOutLabel();\n        }\n\n        if (this.grid) {\n          this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings);\n        }\n\n        if (this.mark) {\n          this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings);\n        }\n      },\n\n      _fadeInLabel() {\n        var group = axis._renderer.g().attr({\n          opacity: 0\n        }).append(axis._axisElementsGroup).animate({\n          opacity: 1\n        }, {\n          delay: .5,\n          partitionDuration: .5\n        });\n\n        this.getContentContainer().append(group);\n      },\n\n      _fadeOutLabel() {\n        var group = axis._renderer.g().attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, {\n          partitionDuration: .5\n        }).append(axis._axisElementsGroup).toBackground();\n\n        this.getContentContainer().append(group);\n      },\n\n      _getTemplateCoords() {\n        return axis._getLabelAdjustedCoord(this, (axis._constantLabelOffset || 0) + (tick.labelOffset || 0));\n      },\n\n      updateLabelPosition: function (animate) {\n        var templateContainer = this.templateContainer;\n\n        if (!this.getContentContainer()) {\n          return;\n        }\n\n        if (animate && this._storedLabelsCoords) {\n          if (templateContainer) {\n            templateContainer.attr(this._storedLabelsCoords);\n\n            var lCoords = this._getTemplateCoords();\n\n            templateContainer.animate(lCoords);\n          } else {\n            this.label.attr({\n              x: this._storedLabelsCoords.x,\n              y: this._storedLabelsCoords.y\n            });\n            this.label.animate({\n              x: this.labelCoords.x,\n              y: this.labelCoords.y\n            });\n          }\n        } else {\n          if (templateContainer) {\n            var _lCoords = this._getTemplateCoords();\n\n            templateContainer.attr(_lCoords);\n          } else {\n            this.label.attr({\n              x: this.labelCoords.x,\n              y: this.labelCoords.y\n            });\n          }\n\n          if (animate) {\n            this._fadeInLabel();\n          }\n        }\n      },\n\n      updateMultilineTextAlignment() {\n        if (labelOptions.template || !this.label) {\n          return;\n        }\n\n        this.label.attr({\n          textsAlignment: this.labelAlignment || axis.getOptions().label.alignment\n        });\n      },\n\n      drawGrid: function (drawLine) {\n        if (gridOptions.visible && skippedCategory !== this.value) {\n          if (this.grid) {\n            this.grid.append(axis._axisGridGroup);\n            axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));\n            this.updateGridPosition();\n          } else {\n            this.grid = drawLine(this, gridStyle);\n            this.grid && this.grid.append(axis._axisGridGroup);\n          }\n        }\n      },\n      updateGridPosition: function (animate) {\n        this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true);\n      },\n\n      removeLabel() {\n        var contentContainer = this.getContentContainer();\n        contentContainer && contentContainer.remove();\n        this._templateDef && this._templateDef.reject();\n        this._templateDef = this.templateContainer = this.label = null;\n      }\n\n    };\n    return tick;\n  };\n}\n\nexport { createTick as tick };","map":{"version":3,"sources":["/Users/rahulsharma/node_modules/devextreme/esm/viz/axes/tick.js"],"names":["isDefined","extend","Deferred","getPathStyle","options","stroke","color","width","opacity","createTick","axis","renderer","tickOptions","gridOptions","skippedCategory","skipLabels","offset","tickOffset","_tickOffset","lineGroup","_axisLineGroup","elementsGroup","_axisElementsGroup","tickStyle","gridStyle","emptyStrRegExp","axisOptions","getOptions","labelOptions","label","labelStyle","_textOptions","getLabelFontStyle","tick","fontStyle","_textFontStyles","customizeColor","call","fill","createLabelHint","range","labelHint","formatHint","value","getContentContainer","setTitle","updateValue","newValue","initCoords","coords","_getTranslatedValue","labelCoords","saveCoords","_lastStoredCoordinates","_storedCoords","_storedLabelsCoords","templateContainer","_getTemplateCoords","resetCoordinates","drawMark","visible","areCoordsOutsideAxis","mark","append","sharp","getSharpDirectionByCoords","updateTickPosition","_createPathElement","setSkippedCategory","category","_updateLine","lineElement","settings","storedSettings","animate","isGridLine","points","r","remove","attr","delay","partitionDuration","angle","_rotateTick","_getTickMarkPoints","length","drawLabel","template","isRendered","updateLabelPosition","labelIsVisible","getTranslator","getBusinessRange","isEmpty","removeLabel","templateOption","text","formatLabel","rotate","g","_templateDef","reject","render","model","valueText","labelFontStyle","container","element","onRendered","resolve","test","css","containerForData","data","getTemplateDeferred","fadeOutElements","startSettings","endSettings","animationSettings","_fadeOutLabel","grid","_axisGridGroup","_fadeInLabel","group","_renderer","toBackground","_getLabelAdjustedCoord","_constantLabelOffset","labelOffset","lCoords","x","y","_lCoords","updateMultilineTextAlignment","textsAlignment","labelAlignment","alignment","drawGrid","drawLine","updateGridPosition","_getGridPoints","contentContainer"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/viz/axes/tick.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined\r\n} from \"../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    Deferred\r\n} from \"../../core/utils/deferred\";\r\n\r\nfunction getPathStyle(options) {\r\n    return {\r\n        stroke: options.color,\r\n        \"stroke-width\": options.width,\r\n        \"stroke-opacity\": options.opacity,\r\n        opacity: 1\r\n    }\r\n}\r\n\r\nfunction createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {\r\n    var tickOffset = offset || axis._tickOffset;\r\n    var lineGroup = axis._axisLineGroup;\r\n    var elementsGroup = axis._axisElementsGroup;\r\n    var tickStyle = getPathStyle(tickOptions);\r\n    var gridStyle = getPathStyle(gridOptions);\r\n    var emptyStrRegExp = /^\\s+$/;\r\n    var axisOptions = axis.getOptions();\r\n    var labelOptions = axisOptions.label;\r\n    var labelStyle = axis._textOptions;\r\n\r\n    function getLabelFontStyle(tick) {\r\n        var fontStyle = axis._textFontStyles;\r\n        var customizeColor = labelOptions.customizeColor;\r\n        if (customizeColor && customizeColor.call) {\r\n            fontStyle = extend({}, axis._textFontStyles, {\r\n                fill: customizeColor.call(tick, tick)\r\n            })\r\n        }\r\n        return fontStyle\r\n    }\r\n\r\n    function createLabelHint(tick, range) {\r\n        var labelHint = axis.formatHint(tick.value, labelOptions, range);\r\n        if (isDefined(labelHint) && \"\" !== labelHint) {\r\n            tick.getContentContainer().setTitle(labelHint)\r\n        }\r\n    }\r\n    return function(value) {\r\n        var tick = {\r\n            value: value,\r\n            updateValue(newValue) {\r\n                this.value = value = newValue\r\n            },\r\n            initCoords: function() {\r\n                this.coords = axis._getTranslatedValue(value, tickOffset);\r\n                this.labelCoords = axis._getTranslatedValue(value)\r\n            },\r\n            saveCoords() {\r\n                this._lastStoredCoordinates = {\r\n                    coords: this._storedCoords,\r\n                    labelCoords: this._storedLabelsCoords\r\n                };\r\n                this._storedCoords = this.coords;\r\n                this._storedLabelsCoords = this.templateContainer ? this._getTemplateCoords() : this.labelCoords\r\n            },\r\n            resetCoordinates() {\r\n                if (this._lastStoredCoordinates) {\r\n                    this._storedCoords = this._lastStoredCoordinates.coords;\r\n                    this._storedLabelsCoords = this._lastStoredCoordinates.labelCoords\r\n                }\r\n            },\r\n            drawMark(options) {\r\n                if (!tickOptions.visible || skippedCategory === value) {\r\n                    return\r\n                }\r\n                if (axis.areCoordsOutsideAxis(this.coords)) {\r\n                    return\r\n                }\r\n                if (this.mark) {\r\n                    this.mark.append(lineGroup);\r\n                    axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));\r\n                    this.updateTickPosition(options)\r\n                } else {\r\n                    this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);\r\n                    this.updateTickPosition(options)\r\n                }\r\n            },\r\n            setSkippedCategory(category) {\r\n                skippedCategory = category\r\n            },\r\n            _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {\r\n                if (!lineElement) {\r\n                    return\r\n                }\r\n                if (null === settings.points || null === settings.r) {\r\n                    lineElement.remove();\r\n                    return\r\n                }\r\n                if (animate && storedSettings && null !== storedSettings.points) {\r\n                    settings.opacity = 1;\r\n                    lineElement.attr(storedSettings);\r\n                    lineElement.animate(settings)\r\n                } else {\r\n                    settings.opacity = animate ? 0 : 1;\r\n                    lineElement.attr(settings);\r\n                    animate && lineElement.animate({\r\n                        opacity: 1\r\n                    }, {\r\n                        delay: .5,\r\n                        partitionDuration: .5\r\n                    })\r\n                }\r\n                this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine)\r\n            },\r\n            updateTickPosition: function(options, animate) {\r\n                this._updateLine(this.mark, {\r\n                    points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)\r\n                }, this._storedCoords && {\r\n                    points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)\r\n                }, animate, false)\r\n            },\r\n            drawLabel: function(range, template) {\r\n                if (this.templateContainer && axis.isRendered()) {\r\n                    this.updateLabelPosition();\r\n                    return\r\n                }\r\n                var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);\r\n                if (!labelIsVisible) {\r\n                    if (this.label) {\r\n                        this.removeLabel()\r\n                    }\r\n                    return\r\n                }\r\n                var templateOption = labelOptions.template;\r\n                var text = axis.formatLabel(value, labelOptions, range);\r\n                if (this.label) {\r\n                    this.label.attr({\r\n                        text: text,\r\n                        rotate: 0\r\n                    }).append(elementsGroup);\r\n                    createLabelHint(this, range);\r\n                    this.updateLabelPosition();\r\n                    return\r\n                }\r\n                if (templateOption) {\r\n                    this.templateContainer = renderer.g().append(elementsGroup);\r\n                    this._templateDef && this._templateDef.reject();\r\n                    this._templateDef = new Deferred;\r\n                    template.render({\r\n                        model: {\r\n                            valueText: text,\r\n                            value: this.value,\r\n                            labelFontStyle: getLabelFontStyle(this),\r\n                            labelStyle: labelStyle\r\n                        },\r\n                        container: this.templateContainer.element,\r\n                        onRendered: () => {\r\n                            this.updateLabelPosition();\r\n                            this._templateDef && this._templateDef.resolve()\r\n                        }\r\n                    })\r\n                } else if (isDefined(text) && \"\" !== text && !emptyStrRegExp.test(text)) {\r\n                    this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).append(elementsGroup);\r\n                    this.updateLabelPosition();\r\n                    createLabelHint(this, range)\r\n                }\r\n                var containerForData = this.getContentContainer();\r\n                containerForData && containerForData.data(\"chart-data-argument\", this.value);\r\n                this.templateContainer && createLabelHint(this, range)\r\n            },\r\n            getTemplateDeferred() {\r\n                return this._templateDef\r\n            },\r\n            getContentContainer() {\r\n                return this.templateContainer || this.label\r\n            },\r\n            fadeOutElements() {\r\n                var startSettings = {\r\n                    opacity: 1\r\n                };\r\n                var endSettings = {\r\n                    opacity: 0\r\n                };\r\n                var animationSettings = {\r\n                    partitionDuration: .5\r\n                };\r\n                if (this.getContentContainer()) {\r\n                    this._fadeOutLabel()\r\n                }\r\n                if (this.grid) {\r\n                    this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings)\r\n                }\r\n                if (this.mark) {\r\n                    this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings)\r\n                }\r\n            },\r\n            _fadeInLabel() {\r\n                var group = axis._renderer.g().attr({\r\n                    opacity: 0\r\n                }).append(axis._axisElementsGroup).animate({\r\n                    opacity: 1\r\n                }, {\r\n                    delay: .5,\r\n                    partitionDuration: .5\r\n                });\r\n                this.getContentContainer().append(group)\r\n            },\r\n            _fadeOutLabel() {\r\n                var group = axis._renderer.g().attr({\r\n                    opacity: 1\r\n                }).animate({\r\n                    opacity: 0\r\n                }, {\r\n                    partitionDuration: .5\r\n                }).append(axis._axisElementsGroup).toBackground();\r\n                this.getContentContainer().append(group)\r\n            },\r\n            _getTemplateCoords() {\r\n                return axis._getLabelAdjustedCoord(this, (axis._constantLabelOffset || 0) + (tick.labelOffset || 0))\r\n            },\r\n            updateLabelPosition: function(animate) {\r\n                var templateContainer = this.templateContainer;\r\n                if (!this.getContentContainer()) {\r\n                    return\r\n                }\r\n                if (animate && this._storedLabelsCoords) {\r\n                    if (templateContainer) {\r\n                        templateContainer.attr(this._storedLabelsCoords);\r\n                        var lCoords = this._getTemplateCoords();\r\n                        templateContainer.animate(lCoords)\r\n                    } else {\r\n                        this.label.attr({\r\n                            x: this._storedLabelsCoords.x,\r\n                            y: this._storedLabelsCoords.y\r\n                        });\r\n                        this.label.animate({\r\n                            x: this.labelCoords.x,\r\n                            y: this.labelCoords.y\r\n                        })\r\n                    }\r\n                } else {\r\n                    if (templateContainer) {\r\n                        var _lCoords = this._getTemplateCoords();\r\n                        templateContainer.attr(_lCoords)\r\n                    } else {\r\n                        this.label.attr({\r\n                            x: this.labelCoords.x,\r\n                            y: this.labelCoords.y\r\n                        })\r\n                    }\r\n                    if (animate) {\r\n                        this._fadeInLabel()\r\n                    }\r\n                }\r\n            },\r\n            updateMultilineTextAlignment() {\r\n                if (labelOptions.template || !this.label) {\r\n                    return\r\n                }\r\n                this.label.attr({\r\n                    textsAlignment: this.labelAlignment || axis.getOptions().label.alignment\r\n                })\r\n            },\r\n            drawGrid: function(drawLine) {\r\n                if (gridOptions.visible && skippedCategory !== this.value) {\r\n                    if (this.grid) {\r\n                        this.grid.append(axis._axisGridGroup);\r\n                        axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));\r\n                        this.updateGridPosition()\r\n                    } else {\r\n                        this.grid = drawLine(this, gridStyle);\r\n                        this.grid && this.grid.append(axis._axisGridGroup)\r\n                    }\r\n                }\r\n            },\r\n            updateGridPosition: function(animate) {\r\n                this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true)\r\n            },\r\n            removeLabel() {\r\n                var contentContainer = this.getContentContainer();\r\n                contentContainer && contentContainer.remove();\r\n                this._templateDef && this._templateDef.reject();\r\n                this._templateDef = this.templateContainer = this.label = null\r\n            }\r\n        };\r\n        return tick\r\n    }\r\n}\r\nexport {\r\n    createTick as tick\r\n};\r\n"]},"metadata":{},"sourceType":"module"}