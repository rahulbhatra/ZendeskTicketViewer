{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/helpers/range_data_calculator.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { unique, getAddFunction, getLog } from \"../../core/utils\";\nimport { isDefined, isObject } from \"../../../core/utils/type\";\nimport { noop } from \"../../../core/utils/common\";\nvar DISCRETE = \"discrete\";\nvar {\n  abs: abs,\n  floor: floor,\n  ceil: ceil,\n  min: min\n} = Math;\n\nfunction continuousRangeCalculator(range, minValue, maxValue) {\n  range.min = range.min < minValue ? range.min : minValue;\n  range.max = range.max > maxValue ? range.max : maxValue;\n}\n\nfunction createGetLogFunction(axisType, axis) {\n  if (\"logarithmic\" !== axisType) {\n    return null;\n  }\n\n  var base = axis.getOptions().logarithmBase;\n  return value => {\n    var log = getLog(abs(value), base);\n    var round = log < 0 ? floor : ceil;\n    return round(log);\n  };\n}\n\nfunction getRangeCalculator(axisType, axis, getLog) {\n  var rangeCalculator = continuousRangeCalculator;\n\n  if (axisType === DISCRETE) {\n    rangeCalculator = function (range, minValue, maxValue) {\n      if (minValue !== maxValue) {\n        range.categories.push(maxValue);\n      }\n\n      range.categories.push(minValue);\n    };\n  } else if (axis) {\n    rangeCalculator = function (range, value) {\n      var interval = axis.calculateInterval(value, range.prevValue);\n      var minInterval = range.interval;\n      range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\n      range.prevValue = value;\n      continuousRangeCalculator(range, value, value);\n    };\n  }\n\n  if (getLog) {\n    return (range, minValue, maxValue) => {\n      var minArgs = [];\n      rangeCalculator(range, minValue, maxValue);\n      0 !== minValue && minArgs.push(getLog(minValue));\n      0 !== maxValue && minArgs.push(getLog(maxValue));\n      var linearThreshold = min.apply(null, minArgs);\n      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;\n    };\n  }\n\n  return rangeCalculator;\n}\n\nfunction getInitialRange(axisType, dataType, firstValue) {\n  var range = {\n    axisType: axisType,\n    dataType: dataType\n  };\n\n  if (axisType === DISCRETE) {\n    range.categories = [];\n  } else {\n    range.min = isObject(firstValue) ? firstValue.min : firstValue;\n    range.max = isObject(firstValue) ? firstValue.max : firstValue;\n  }\n\n  return range;\n}\n\nfunction processCategories(range) {\n  if (range.categories) {\n    range.categories = unique(range.categories);\n  }\n\n  return range;\n}\n\nfunction getValueForArgument(point, extraPoint, x, range) {\n  if (extraPoint && isDefined(extraPoint.value)) {\n    var y1 = point.value;\n    var y2 = extraPoint.value;\n    var x1 = point.argument;\n    var x2 = extraPoint.argument;\n    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\n    return \"datetime\" === range.dataType ? new Date(r) : r;\n  } else {\n    return point.value;\n  }\n}\n\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\n  var value = getValueForArgument(point, prevPoint, bound, range);\n  rangeCalculator(range, value, value);\n}\n\nfunction isLineSeries(series) {\n  return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0;\n}\n\nfunction getViewportReducer(series) {\n  var rangeCalculator = getRangeCalculator(series.valueAxisType);\n  var argumentAxis = series.getArgumentAxis();\n  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\n  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : noop;\n\n  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\n    var range = series.getArgumentAxis().getTranslator().getBusinessRange();\n    var add = getAddFunction(range, false);\n    var interval = range.interval;\n\n    if (isFinite(interval) && isDefined(viewport.startValue) && isDefined(viewport.endValue)) {\n      viewport.startValue = add(viewport.startValue, interval, -1);\n      viewport.endValue = add(viewport.endValue, interval);\n    }\n  }\n\n  var viewportFilter = getViewPortFilter(viewport);\n  return function (range, point, index, points) {\n    var argument = point.argument;\n\n    if (!point.hasValue()) {\n      return range;\n    }\n\n    if (viewportFilter(argument)) {\n      if (!range.startCalc) {\n        range.startCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n\n      rangeCalculator(range, point.getMinValue(), point.getMaxValue());\n    } else if (!viewport.categories && isDefined(viewport.startValue) && argument > viewport.startValue) {\n      if (!range.startCalc) {\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n\n      range.endCalc = true;\n      calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);\n    }\n\n    return range;\n  };\n}\n\nfunction getViewPortFilter(viewport) {\n  if (viewport.categories) {\n    var dictionary = viewport.categories.reduce((result, category) => {\n      result[category.valueOf()] = true;\n      return result;\n    }, {});\n    return argument => isDefined(argument) && dictionary[argument.valueOf()];\n  }\n\n  if (!isDefined(viewport.startValue) && !isDefined(viewport.endValue)) {\n    return () => true;\n  }\n\n  if (!isDefined(viewport.endValue)) {\n    return argument => argument >= viewport.startValue;\n  }\n\n  if (!isDefined(viewport.startValue)) {\n    return argument => argument <= viewport.endValue;\n  }\n\n  return argument => argument >= viewport.startValue && argument <= viewport.endValue;\n}\n\nexport default {\n  getViewPortFilter: getViewPortFilter,\n  getArgumentRange: function (series) {\n    var data = series._data || [];\n    var range = {};\n\n    if (data.length) {\n      if (series.argumentAxisType === DISCRETE) {\n        range = {\n          categories: data.map(item => item.argument)\n        };\n      } else {\n        var interval;\n\n        if (data.length > 1) {\n          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\n          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\n          interval = min(i1, i2);\n        }\n\n        range = {\n          min: data[0].argument,\n          max: data[data.length - 1].argument,\n          interval: interval\n        };\n      }\n    }\n\n    return processCategories(range);\n  },\n  getRangeData: function (series) {\n    var points = series.getPoints();\n    var useAggregation = series.useAggregation();\n    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));\n    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\n    var viewportReducer = getViewportReducer(series);\n    var range = points.reduce(function (range, point, index, points) {\n      var argument = point.argument;\n\n      if (!point.isArgumentCorrect()) {\n        return range;\n      }\n\n      argumentCalculator(range.arg, argument, argument);\n\n      if (point.hasValue()) {\n        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\n        viewportReducer(range.viewport, point, index, points);\n      }\n\n      return range;\n    }, {\n      arg: getInitialRange(series.argumentAxisType, series.argumentType, series.getArgumentRangeInitialValue()),\n      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\n      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\n    });\n\n    if (useAggregation) {\n      var argumentRange = this.getArgumentRange(series);\n\n      if (series.argumentAxisType === DISCRETE) {\n        range.arg = argumentRange;\n      } else {\n        var viewport = series.getArgumentAxis().getViewport();\n\n        if (isDefined(viewport.startValue) || isDefined(viewport.length)) {\n          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);\n        }\n\n        if (isDefined(viewport.endValue) || isDefined(viewport.length) && isDefined(viewport.startValue)) {\n          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);\n        }\n      }\n    }\n\n    processCategories(range.arg);\n    processCategories(range.val);\n    return range;\n  },\n  getViewport: function (series) {\n    var points = series.getPoints();\n    var range;\n    var reducer = getViewportReducer(series);\n    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\n    points.some(function (point, index) {\n      reducer(range, point, index, points);\n      return range.endCalc;\n    });\n    return range;\n  },\n  getPointsInViewPort: function (series) {\n    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\n    var valueViewPort = series.getValueAxis().visualRange() || {};\n    var valueViewPortFilter = getViewPortFilter(valueViewPort);\n    var points = series.getPoints();\n\n    var addValue = function (values, point, isEdge) {\n      var minValue = point.getMinValue();\n      var maxValue = point.getMaxValue();\n      var isMinValueInViewPort = valueViewPortFilter(minValue);\n      var isMaxValueInViewPort = valueViewPortFilter(maxValue);\n\n      if (isMinValueInViewPort) {\n        values.push(minValue);\n      }\n\n      if (maxValue !== minValue && isMaxValueInViewPort) {\n        values.push(maxValue);\n      }\n\n      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\n        if (!values.length) {\n          values.push(valueViewPort.startValue);\n        } else {\n          values.push(valueViewPort.endValue);\n        }\n      }\n    };\n\n    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {\n      var point = points[index];\n      var prevPoint = points[index - 1];\n      var nextPoint = points[index + 1];\n\n      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n\n      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n    } : noop;\n    return points.reduce(function (result, point, index) {\n      if (argumentViewPortFilter(point.argument)) {\n        addValue(result[0], point);\n      } else {\n        addEdgePoints(result, points, index);\n      }\n\n      return result;\n    }, [[], []]);\n  }\n};","map":{"version":3,"sources":["/Users/rahulsharma/node_modules/devextreme/esm/viz/series/helpers/range_data_calculator.js"],"names":["unique","getAddFunction","getLog","isDefined","isObject","noop","DISCRETE","abs","floor","ceil","min","Math","continuousRangeCalculator","range","minValue","maxValue","max","createGetLogFunction","axisType","axis","base","getOptions","logarithmBase","value","log","round","getRangeCalculator","rangeCalculator","categories","push","interval","calculateInterval","prevValue","minInterval","minArgs","linearThreshold","apply","getInitialRange","dataType","firstValue","processCategories","getValueForArgument","point","extraPoint","x","y1","y2","x1","argument","x2","r","valueOf","Date","calculateRangeBetweenPoints","prevPoint","bound","isLineSeries","series","type","toLowerCase","indexOf","getViewportReducer","valueAxisType","argumentAxis","getArgumentAxis","viewport","visualRange","calculatePointBetweenPoints","getMarginOptions","checkInterval","getTranslator","getBusinessRange","add","isFinite","startValue","endValue","viewportFilter","getViewPortFilter","index","points","hasValue","startCalc","getMinValue","getMaxValue","endCalc","dictionary","reduce","result","category","getArgumentRange","data","_data","length","argumentAxisType","map","item","i1","i2","getRangeData","getPoints","useAggregation","argumentCalculator","valueRangeCalculator","getValueAxis","viewportReducer","isArgumentCorrect","arg","val","argumentType","getArgumentRangeInitialValue","valueType","getValueRangeInitialValue","argumentRange","getViewport","reducer","some","getPointsInViewPort","argumentViewPortFilter","valueViewPort","valueViewPortFilter","addValue","values","isEdge","isMinValueInViewPort","isMaxValueInViewPort","addEdgePoints","nextPoint"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/viz/series/helpers/range_data_calculator.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    unique,\r\n    getAddFunction,\r\n    getLog\r\n} from \"../../core/utils\";\r\nimport {\r\n    isDefined,\r\n    isObject\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    noop\r\n} from \"../../../core/utils/common\";\r\nvar DISCRETE = \"discrete\";\r\nvar {\r\n    abs: abs,\r\n    floor: floor,\r\n    ceil: ceil,\r\n    min: min\r\n} = Math;\r\n\r\nfunction continuousRangeCalculator(range, minValue, maxValue) {\r\n    range.min = range.min < minValue ? range.min : minValue;\r\n    range.max = range.max > maxValue ? range.max : maxValue\r\n}\r\n\r\nfunction createGetLogFunction(axisType, axis) {\r\n    if (\"logarithmic\" !== axisType) {\r\n        return null\r\n    }\r\n    var base = axis.getOptions().logarithmBase;\r\n    return value => {\r\n        var log = getLog(abs(value), base);\r\n        var round = log < 0 ? floor : ceil;\r\n        return round(log)\r\n    }\r\n}\r\n\r\nfunction getRangeCalculator(axisType, axis, getLog) {\r\n    var rangeCalculator = continuousRangeCalculator;\r\n    if (axisType === DISCRETE) {\r\n        rangeCalculator = function(range, minValue, maxValue) {\r\n            if (minValue !== maxValue) {\r\n                range.categories.push(maxValue)\r\n            }\r\n            range.categories.push(minValue)\r\n        }\r\n    } else if (axis) {\r\n        rangeCalculator = function(range, value) {\r\n            var interval = axis.calculateInterval(value, range.prevValue);\r\n            var minInterval = range.interval;\r\n            range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\r\n            range.prevValue = value;\r\n            continuousRangeCalculator(range, value, value)\r\n        }\r\n    }\r\n    if (getLog) {\r\n        return (range, minValue, maxValue) => {\r\n            var minArgs = [];\r\n            rangeCalculator(range, minValue, maxValue);\r\n            0 !== minValue && minArgs.push(getLog(minValue));\r\n            0 !== maxValue && minArgs.push(getLog(maxValue));\r\n            var linearThreshold = min.apply(null, minArgs);\r\n            range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold\r\n        }\r\n    }\r\n    return rangeCalculator\r\n}\r\n\r\nfunction getInitialRange(axisType, dataType, firstValue) {\r\n    var range = {\r\n        axisType: axisType,\r\n        dataType: dataType\r\n    };\r\n    if (axisType === DISCRETE) {\r\n        range.categories = []\r\n    } else {\r\n        range.min = isObject(firstValue) ? firstValue.min : firstValue;\r\n        range.max = isObject(firstValue) ? firstValue.max : firstValue\r\n    }\r\n    return range\r\n}\r\n\r\nfunction processCategories(range) {\r\n    if (range.categories) {\r\n        range.categories = unique(range.categories)\r\n    }\r\n    return range\r\n}\r\n\r\nfunction getValueForArgument(point, extraPoint, x, range) {\r\n    if (extraPoint && isDefined(extraPoint.value)) {\r\n        var y1 = point.value;\r\n        var y2 = extraPoint.value;\r\n        var x1 = point.argument;\r\n        var x2 = extraPoint.argument;\r\n        var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\r\n        return \"datetime\" === range.dataType ? new Date(r) : r\r\n    } else {\r\n        return point.value\r\n    }\r\n}\r\n\r\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\r\n    var value = getValueForArgument(point, prevPoint, bound, range);\r\n    rangeCalculator(range, value, value)\r\n}\r\n\r\nfunction isLineSeries(series) {\r\n    return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0\r\n}\r\n\r\nfunction getViewportReducer(series) {\r\n    var rangeCalculator = getRangeCalculator(series.valueAxisType);\r\n    var argumentAxis = series.getArgumentAxis();\r\n    var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\r\n    var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : noop;\r\n    if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\r\n        var range = series.getArgumentAxis().getTranslator().getBusinessRange();\r\n        var add = getAddFunction(range, false);\r\n        var interval = range.interval;\r\n        if (isFinite(interval) && isDefined(viewport.startValue) && isDefined(viewport.endValue)) {\r\n            viewport.startValue = add(viewport.startValue, interval, -1);\r\n            viewport.endValue = add(viewport.endValue, interval)\r\n        }\r\n    }\r\n    var viewportFilter = getViewPortFilter(viewport);\r\n    return function(range, point, index, points) {\r\n        var argument = point.argument;\r\n        if (!point.hasValue()) {\r\n            return range\r\n        }\r\n        if (viewportFilter(argument)) {\r\n            if (!range.startCalc) {\r\n                range.startCalc = true;\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n            }\r\n            rangeCalculator(range, point.getMinValue(), point.getMaxValue())\r\n        } else if (!viewport.categories && isDefined(viewport.startValue) && argument > viewport.startValue) {\r\n            if (!range.startCalc) {\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n            }\r\n            range.endCalc = true;\r\n            calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue)\r\n        }\r\n        return range\r\n    }\r\n}\r\n\r\nfunction getViewPortFilter(viewport) {\r\n    if (viewport.categories) {\r\n        var dictionary = viewport.categories.reduce((result, category) => {\r\n            result[category.valueOf()] = true;\r\n            return result\r\n        }, {});\r\n        return argument => isDefined(argument) && dictionary[argument.valueOf()]\r\n    }\r\n    if (!isDefined(viewport.startValue) && !isDefined(viewport.endValue)) {\r\n        return () => true\r\n    }\r\n    if (!isDefined(viewport.endValue)) {\r\n        return argument => argument >= viewport.startValue\r\n    }\r\n    if (!isDefined(viewport.startValue)) {\r\n        return argument => argument <= viewport.endValue\r\n    }\r\n    return argument => argument >= viewport.startValue && argument <= viewport.endValue\r\n}\r\nexport default {\r\n    getViewPortFilter: getViewPortFilter,\r\n    getArgumentRange: function(series) {\r\n        var data = series._data || [];\r\n        var range = {};\r\n        if (data.length) {\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range = {\r\n                    categories: data.map(item => item.argument)\r\n                }\r\n            } else {\r\n                var interval;\r\n                if (data.length > 1) {\r\n                    var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\r\n                    var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\r\n                    interval = min(i1, i2)\r\n                }\r\n                range = {\r\n                    min: data[0].argument,\r\n                    max: data[data.length - 1].argument,\r\n                    interval: interval\r\n                }\r\n            }\r\n        }\r\n        return processCategories(range)\r\n    },\r\n    getRangeData: function(series) {\r\n        var points = series.getPoints();\r\n        var useAggregation = series.useAggregation();\r\n        var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));\r\n        var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\r\n        var viewportReducer = getViewportReducer(series);\r\n        var range = points.reduce((function(range, point, index, points) {\r\n            var argument = point.argument;\r\n            if (!point.isArgumentCorrect()) {\r\n                return range\r\n            }\r\n            argumentCalculator(range.arg, argument, argument);\r\n            if (point.hasValue()) {\r\n                valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\r\n                viewportReducer(range.viewport, point, index, points)\r\n            }\r\n            return range\r\n        }), {\r\n            arg: getInitialRange(series.argumentAxisType, series.argumentType, series.getArgumentRangeInitialValue()),\r\n            val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\r\n            viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\r\n        });\r\n        if (useAggregation) {\r\n            var argumentRange = this.getArgumentRange(series);\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range.arg = argumentRange\r\n            } else {\r\n                var viewport = series.getArgumentAxis().getViewport();\r\n                if (isDefined(viewport.startValue) || isDefined(viewport.length)) {\r\n                    argumentCalculator(range.arg, argumentRange.min, argumentRange.min)\r\n                }\r\n                if (isDefined(viewport.endValue) || isDefined(viewport.length) && isDefined(viewport.startValue)) {\r\n                    argumentCalculator(range.arg, argumentRange.max, argumentRange.max)\r\n                }\r\n            }\r\n        }\r\n        processCategories(range.arg);\r\n        processCategories(range.val);\r\n        return range\r\n    },\r\n    getViewport: function(series) {\r\n        var points = series.getPoints();\r\n        var range;\r\n        var reducer = getViewportReducer(series);\r\n        range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\r\n        points.some((function(point, index) {\r\n            reducer(range, point, index, points);\r\n            return range.endCalc\r\n        }));\r\n        return range\r\n    },\r\n    getPointsInViewPort: function(series) {\r\n        var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\r\n        var valueViewPort = series.getValueAxis().visualRange() || {};\r\n        var valueViewPortFilter = getViewPortFilter(valueViewPort);\r\n        var points = series.getPoints();\r\n        var addValue = function(values, point, isEdge) {\r\n            var minValue = point.getMinValue();\r\n            var maxValue = point.getMaxValue();\r\n            var isMinValueInViewPort = valueViewPortFilter(minValue);\r\n            var isMaxValueInViewPort = valueViewPortFilter(maxValue);\r\n            if (isMinValueInViewPort) {\r\n                values.push(minValue)\r\n            }\r\n            if (maxValue !== minValue && isMaxValueInViewPort) {\r\n                values.push(maxValue)\r\n            }\r\n            if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\r\n                if (!values.length) {\r\n                    values.push(valueViewPort.startValue)\r\n                } else {\r\n                    values.push(valueViewPort.endValue)\r\n                }\r\n            }\r\n        };\r\n        var addEdgePoints = isLineSeries(series) ? function(result, points, index) {\r\n            var point = points[index];\r\n            var prevPoint = points[index - 1];\r\n            var nextPoint = points[index + 1];\r\n            if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n            if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n        } : noop;\r\n        return points.reduce((function(result, point, index) {\r\n            if (argumentViewPortFilter(point.argument)) {\r\n                addValue(result[0], point)\r\n            } else {\r\n                addEdgePoints(result, points, index)\r\n            }\r\n            return result\r\n        }), [\r\n            [],\r\n            []\r\n        ])\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}