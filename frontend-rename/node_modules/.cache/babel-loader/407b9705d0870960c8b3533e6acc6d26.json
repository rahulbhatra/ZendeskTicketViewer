{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/scatter_series.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend as _extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport { each as _each } from \"../../core/utils/iterator\";\nimport rangeCalculator from \"./helpers/range_data_calculator\";\nimport { isDefined as _isDefined, isString as _isString } from \"../../core/utils/type\";\nimport { map as _map, normalizeEnum as _normalizeEnum, convertXYToPolar } from \"../core/utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nvar math = Math;\nvar _abs = math.abs;\nvar _sqrt = math.sqrt;\nvar _max = math.max;\nvar DEFAULT_TRACKER_WIDTH = 12;\nvar DEFAULT_DURATION = 400;\nvar HIGH_ERROR = \"highError\";\nvar LOW_ERROR = \"lowError\";\nvar VARIANCE = \"variance\";\nvar STANDARD_DEVIATION = \"stddeviation\";\nvar STANDARD_ERROR = \"stderror\";\nvar PERCENT = \"percent\";\nvar FIXED = \"fixed\";\nvar UNDEFINED = \"undefined\";\nvar DISCRETE = \"discrete\";\nvar LOGARITHMIC = \"logarithmic\";\nvar DATETIME = \"datetime\";\nvar chart = {};\nvar polar = {};\n\nfunction sum(array) {\n  var result = 0;\n\n  _each(array, function (_, value) {\n    result += value;\n  });\n\n  return result;\n}\n\nfunction isErrorBarTypeCorrect(type) {\n  return -1 !== inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR]);\n}\n\nfunction variance(array, expectedValue) {\n  return sum(_map(array, function (value) {\n    return (value - expectedValue) * (value - expectedValue);\n  })) / array.length;\n}\n\nfunction calculateAvgErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var valueField = series.getValueFields()[0];\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    var fusionData = data.reduce(function (result, item) {\n      if (_isDefined(item[lowValueField])) {\n        result[0] += item[valueField] - item[lowValueField];\n        result[1]++;\n      }\n\n      if (_isDefined(item[highValueField])) {\n        result[2] += item[highValueField] - item[valueField];\n        result[3]++;\n      }\n\n      return result;\n    }, [0, 0, 0, 0]);\n\n    if (fusionData[1]) {\n      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];\n    }\n\n    if (fusionData[2]) {\n      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];\n    }\n  }\n\n  return result;\n}\n\nfunction calculateSumErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    result[lowValueField] = 0;\n    result[highValueField] = 0;\n    result = data.reduce(function (result, item) {\n      result[lowValueField] += item[lowValueField];\n      result[highValueField] += item[highValueField];\n      return result;\n    }, result);\n  }\n\n  return result;\n}\n\nfunction getMinMaxAggregator(compare) {\n  return (_ref, series) => {\n    var {\n      intervalStart: intervalStart,\n      intervalEnd: intervalEnd,\n      data: data\n    } = _ref;\n    var valueField = series.getValueFields()[0];\n    var targetData = data[0];\n    targetData = data.reduce((result, item) => {\n      var value = item[valueField];\n\n      if (null === result[valueField]) {\n        result = item;\n      }\n\n      if (null !== value && compare(value, result[valueField])) {\n        return item;\n      }\n\n      return result;\n    }, targetData);\n    return _extend({}, targetData, {\n      [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n    });\n  };\n}\n\nfunction checkFields(data, fieldsToCheck, skippedFields) {\n  var allFieldsIsValid = true;\n\n  for (var field in fieldsToCheck) {\n    var isArgument = \"argument\" === field;\n\n    if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\n      var selector = fieldsToCheck[field];\n\n      if (!isArgument) {\n        skippedFields[selector] = (skippedFields[selector] || 0) + 1;\n      }\n\n      allFieldsIsValid = false;\n    }\n  }\n\n  return allFieldsIsValid;\n}\n\nvar baseScatterMethods = {\n  _defaultDuration: DEFAULT_DURATION,\n  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\n  _applyStyle: _noop,\n  _updateOptions: _noop,\n  _parseStyle: _noop,\n  _prepareSegment: _noop,\n  _drawSegment: _noop,\n  _appendInGroup: function () {\n    this._group.append(this._extGroups.seriesGroup);\n  },\n  _createLegendState: function (styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\n        direction: \"right\"\n      }) : void 0\n    };\n  },\n  _applyElementsClipRect: function (settings) {\n    settings[\"clip-path\"] = this._paneClipRectID;\n  },\n  _applyMarkerClipRect: function (settings) {\n    settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null;\n  },\n  _createGroup: function (groupName, parent, target, settings) {\n    var group = parent[groupName] = parent[groupName] || this._renderer.g();\n\n    target && group.append(target);\n    settings && group.attr(settings);\n  },\n  _applyClearingSettings: function (settings) {\n    settings.opacity = null;\n    settings.scale = null;\n\n    if (this._options.rotated) {\n      settings.translateX = null;\n    } else {\n      settings.translateY = null;\n    }\n  },\n  _createGroups: function () {\n    this._createGroup(\"_markersGroup\", this, this._group);\n\n    this._createGroup(\"_labelsGroup\", this);\n  },\n  _setMarkerGroupSettings: function () {\n    var settings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\n\n    settings.class = \"dxc-markers\";\n    settings.opacity = 1;\n\n    this._applyMarkerClipRect(settings);\n\n    this._markersGroup.attr(settings);\n  },\n  getVisibleArea: function () {\n    return this._visibleArea;\n  },\n  areErrorBarsVisible: function () {\n    var errorBarOptions = this._options.valueErrorBar;\n    return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField));\n  },\n\n  groupPointsByCoords(rotated) {\n    var cat = [];\n\n    _each(this.getVisiblePoints(), function (_, p) {\n      var pointCoord = parseInt(rotated ? p.vy : p.vx);\n\n      if (!cat[pointCoord]) {\n        cat[pointCoord] = p;\n      } else {\n        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];\n      }\n    });\n\n    return cat;\n  },\n\n  _createErrorBarGroup: function (animationEnabled) {\n    var errorBarOptions = this._options.valueErrorBar;\n    var settings;\n\n    if (this.areErrorBarsVisible()) {\n      settings = {\n        class: \"dxc-error-bars\",\n        stroke: errorBarOptions.color,\n        \"stroke-width\": errorBarOptions.lineWidth,\n        opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\n        \"stroke-linecap\": \"square\",\n        sharp: true,\n        \"clip-path\": this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID\n      };\n\n      this._createGroup(\"_errorBarGroup\", this, this._group, settings);\n    }\n  },\n  _setGroupsSettings: function (animationEnabled) {\n    this._setMarkerGroupSettings();\n\n    this._setLabelGroupSettings(animationEnabled);\n\n    this._createErrorBarGroup(animationEnabled);\n  },\n  _getCreatingPointOptions: function () {\n    var defaultPointOptions;\n    var creatingPointOptions = this._predefinedPointOptions;\n    var normalStyle;\n\n    if (!creatingPointOptions) {\n      defaultPointOptions = this._getPointOptions();\n      this._predefinedPointOptions = creatingPointOptions = _extend(true, {\n        styles: {}\n      }, defaultPointOptions);\n      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\n      creatingPointOptions.styles = creatingPointOptions.styles || {};\n      creatingPointOptions.styles.normal = {\n        \"stroke-width\": normalStyle[\"stroke-width\"],\n        r: normalStyle.r,\n        opacity: normalStyle.opacity\n      };\n    }\n\n    return creatingPointOptions;\n  },\n  _getPointOptions: function () {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label);\n  },\n  _getOptionsForPoint: function () {\n    return this._options.point;\n  },\n  _parsePointStyle: function (style, defaultColor, defaultBorderColor, defaultSize) {\n    var border = style.border || {};\n    var sizeValue = void 0 !== style.size ? style.size : defaultSize;\n    return {\n      fill: style.color || defaultColor,\n      stroke: border.color || defaultBorderColor,\n      \"stroke-width\": border.visible ? border.width : 0,\n      r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\n    };\n  },\n  _createPointStyles: function (pointOptions) {\n    var mainPointColor = pointOptions.color || this._options.mainSeriesColor;\n    var containerColor = this._options.containerBackgroundColor;\n\n    var normalStyle = this._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\n\n    normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\n    return {\n      normal: normalStyle,\n      hover: this._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\n      selection: this._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\n    };\n  },\n  _checkData: function (data, skippedFields, fieldsToCheck) {\n    fieldsToCheck = fieldsToCheck || {\n      value: this.getValueFields()[0]\n    };\n    fieldsToCheck.argument = this.getArgumentField();\n    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;\n  },\n\n  getArgumentRangeInitialValue() {\n    var points = this.getPoints();\n\n    if (this.useAggregation() && points.length) {\n      var _points$0$aggregation, _points$aggregationIn;\n\n      return {\n        min: null === (_points$0$aggregation = points[0].aggregationInfo) || void 0 === _points$0$aggregation ? void 0 : _points$0$aggregation.intervalStart,\n        max: null === (_points$aggregationIn = points[points.length - 1].aggregationInfo) || void 0 === _points$aggregationIn ? void 0 : _points$aggregationIn.intervalEnd\n      };\n    }\n\n    return;\n  },\n\n  getValueRangeInitialValue: function () {\n    return;\n  },\n  _getRangeData: function () {\n    return rangeCalculator.getRangeData(this);\n  },\n  _getPointDataSelector: function () {\n    var valueField = this.getValueFields()[0];\n    var argumentField = this.getArgumentField();\n    var tagField = this.getTagField();\n    var areErrorBarsVisible = this.areErrorBarsVisible();\n    var lowValueField;\n    var highValueField;\n\n    if (areErrorBarsVisible) {\n      var errorBarOptions = this._options.valueErrorBar;\n      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\n      highValueField = errorBarOptions.highValueField || HIGH_ERROR;\n    }\n\n    return data => {\n      var pointData = {\n        value: this._processEmptyValue(data[valueField]),\n        argument: data[argumentField],\n        tag: data[tagField],\n        data: data\n      };\n\n      if (areErrorBarsVisible) {\n        pointData.lowError = data[lowValueField];\n        pointData.highError = data[highValueField];\n      }\n\n      return pointData;\n    };\n  },\n  _errorBarsEnabled: function () {\n    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;\n  },\n  _drawPoint: function (options) {\n    var point = options.point;\n\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\n\n      this._drawnPoints.push(point);\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _animateComplete: function () {\n    var animationSettings = {\n      duration: this._defaultDuration\n    };\n    this._labelsGroup && this._labelsGroup.animate({\n      opacity: 1\n    }, animationSettings);\n    this._errorBarGroup && this._errorBarGroup.animate({\n      opacity: this._options.valueErrorBar.opacity || 1\n    }, animationSettings);\n  },\n  _animate: function () {\n    var that = this;\n    var lastPointIndex = that._drawnPoints.length - 1;\n\n    _each(that._drawnPoints || [], function (i, p) {\n      p.animate(i === lastPointIndex ? function () {\n        that._animateComplete();\n      } : void 0, {\n        translateX: p.x,\n        translateY: p.y\n      });\n    });\n  },\n\n  _getIntervalCenter(intervalStart, intervalEnd) {\n    var argAxis = this.getArgumentAxis();\n    return \"discrete\" !== argAxis.getOptions().type ? argAxis.getVisualRangeCenter({\n      minVisible: intervalStart,\n      maxVisible: intervalEnd\n    }, true) : intervalStart;\n  },\n\n  _defaultAggregator: \"avg\",\n  _aggregators: {\n    avg(_ref2, series) {\n      var {\n        data: data,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd\n      } = _ref2;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce((result, item) => {\n        var value = item[valueField];\n\n        if (_isDefined(value)) {\n          result[0] += value;\n          result[1]++;\n        } else if (null === value) {\n          result[2]++;\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      return calculateAvgErrorBars({\n        [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      }, data, series);\n    },\n\n    sum(_ref3, series) {\n      var {\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd,\n        data: data\n      } = _ref3;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce((result, item) => {\n        var value = item[valueField];\n\n        if (void 0 !== value) {\n          result[0] += value;\n        }\n\n        if (null === value) {\n          result[1]++;\n        } else if (void 0 === value) {\n          result[2]++;\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      var value = aggregationResult[0];\n\n      if (aggregationResult[1] === data.length) {\n        value = null;\n      }\n\n      if (aggregationResult[2] === data.length) {\n        return;\n      }\n\n      return calculateSumErrorBars({\n        [valueField]: value,\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      }, data, series);\n    },\n\n    count(_ref4, series) {\n      var {\n        data: data,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd\n      } = _ref4;\n      var valueField = series.getValueFields()[0];\n      return {\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),\n        [valueField]: data.filter(i => void 0 !== i[valueField]).length\n      };\n    },\n\n    min: getMinMaxAggregator((a, b) => a < b),\n    max: getMinMaxAggregator((a, b) => a > b)\n  },\n  _endUpdateData: function () {\n    delete this._predefinedPointOptions;\n  },\n  getArgumentField: function () {\n    return this._options.argumentField || \"arg\";\n  },\n  getValueFields: function () {\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n    var valueFields = [options.valueField || \"val\"];\n    var lowValueField;\n    var highValueField;\n\n    if (errorBarsOptions) {\n      lowValueField = errorBarsOptions.lowValueField;\n      highValueField = errorBarsOptions.highValueField;\n      _isString(lowValueField) && valueFields.push(lowValueField);\n      _isString(highValueField) && valueFields.push(highValueField);\n    }\n\n    return valueFields;\n  },\n  _calculateErrorBars: function (data) {\n    if (!this.areErrorBarsVisible()) {\n      return;\n    }\n\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n\n    var errorBarType = _normalizeEnum(errorBarsOptions.type);\n\n    var floatErrorValue = parseFloat(errorBarsOptions.value);\n    var valueField = this.getValueFields()[0];\n    var value;\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n    var valueArray;\n    var valueArrayLength;\n    var meanValue;\n    var processDataItem;\n\n    var addSubError = function (_i, item) {\n      value = item.value;\n      item.lowError = value - floatErrorValue;\n      item.highError = value + floatErrorValue;\n    };\n\n    switch (errorBarType) {\n      case FIXED:\n        processDataItem = addSubError;\n        break;\n\n      case PERCENT:\n        processDataItem = function (_, item) {\n          value = item.value;\n          var error = value * floatErrorValue / 100;\n          item.lowError = value - error;\n          item.highError = value + error;\n        };\n\n        break;\n\n      case UNDEFINED:\n        processDataItem = function (_, item) {\n          item.lowError = item.data[lowValueField];\n          item.highError = item.data[highValueField];\n        };\n\n        break;\n\n      default:\n        valueArray = _map(data, function (item) {\n          return _isDefined(item.data[valueField]) ? item.data[valueField] : null;\n        });\n        valueArrayLength = valueArray.length;\n        floatErrorValue = floatErrorValue || 1;\n\n        switch (errorBarType) {\n          case VARIANCE:\n            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n            break;\n\n          case STANDARD_DEVIATION:\n            meanValue = sum(valueArray) / valueArrayLength;\n            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\n\n            processDataItem = function (_, item) {\n              item.lowError = meanValue - floatErrorValue;\n              item.highError = meanValue + floatErrorValue;\n            };\n\n            break;\n\n          case STANDARD_ERROR:\n            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n        }\n\n    }\n\n    processDataItem && _each(data, processDataItem);\n  },\n  _patchMarginOptions: function (options) {\n    var pointOptions = this._getCreatingPointOptions();\n\n    var styles = pointOptions.styles;\n    var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {\n      return _max(max, 2 * style.r + style[\"stroke-width\"]);\n    }, 0);\n    options.size = pointOptions.visible ? maxSize : 0;\n    options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\n    return options;\n  },\n  usePointsToDefineAutoHiding: () => true\n};\nchart = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    var that = this;\n    var trackers;\n    var trackersGroup;\n    var segments = that._segments || [];\n    var rotated = that._options.rotated;\n\n    if (!that.isVisible()) {\n      return;\n    }\n\n    if (segments.length) {\n      trackers = that._trackers = that._trackers || [];\n      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\n        fill: \"gray\",\n        opacity: .001,\n        stroke: \"gray\",\n        class: \"dxc-trackers\"\n      })).attr({\n        \"clip-path\": this._paneClipRectID || null\n      }).append(that._group);\n\n      _each(segments, function (i, segment) {\n        if (!trackers[i]) {\n          trackers[i] = that._drawTrackerElement(segment).data({\n            \"chart-data-series\": that\n          }).append(trackersGroup);\n        } else {\n          that._updateTrackerElement(segment, trackers[i]);\n        }\n      });\n    }\n\n    that._trackersTranslator = that.groupPointsByCoords(rotated);\n  },\n\n  _checkAxisVisibleAreaCoord(isArgument, coord) {\n    var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;\n  },\n\n  checkSeriesViewportCoord(axis, coord) {\n    return this.getPoints().length && this.isVisible();\n  },\n\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var points = this.getVisiblePoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n\n  _getNearestPoints: (point, nextPoint) => [point, nextPoint],\n  _getBezierPoints: () => [],\n\n  _getNearestPointsByCoord(coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var allPoints = that.getPoints();\n\n    var bezierPoints = that._getBezierPoints();\n\n    var nearestPoints = [];\n\n    if (allPoints.length > 1) {\n      allPoints.forEach((point, i) => {\n        var nextPoint = allPoints[i + 1];\n\n        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {\n          nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints));\n        }\n      });\n    } else {\n      nearestPoints.push([allPoints[0], allPoints[0]]);\n    }\n\n    return nearestPoints;\n  },\n\n  getNeighborPoint: function (x, y) {\n    var pCoord = this._options.rotated ? y : x;\n    var nCoord = pCoord;\n    var cat = this._trackersTranslator;\n    var point = null;\n    var minDistance;\n    var oppositeCoord = this._options.rotated ? x : y;\n    var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\n\n    if (this.isVisible() && cat) {\n      point = cat[pCoord];\n\n      do {\n        point = cat[nCoord] || cat[pCoord];\n        pCoord--;\n        nCoord++;\n      } while ((pCoord >= 0 || nCoord < cat.length) && !point);\n\n      if (Array.isArray(point)) {\n        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\n\n        _each(point, function (i, p) {\n          var distance = _abs(p[oppositeCoordName] - oppositeCoord);\n\n          if (minDistance >= distance) {\n            minDistance = distance;\n            point = p;\n          }\n        });\n      }\n    }\n\n    return point;\n  },\n  _applyVisibleArea: function () {\n    var rotated = this._options.rotated;\n    var visibleX = (rotated ? this.getValueAxis() : this.getArgumentAxis()).getVisibleArea();\n    var visibleY = (rotated ? this.getArgumentAxis() : this.getValueAxis()).getVisibleArea();\n    this._visibleArea = {\n      minX: visibleX[0],\n      maxX: visibleX[1],\n      minY: visibleY[0],\n      maxY: visibleY[1]\n    };\n  },\n\n  getPointCenterByArg(arg) {\n    var point = this.getPointsByArg(arg)[0];\n    return point ? point.getCenterCoord() : void 0;\n  }\n\n});\npolar = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    chart.drawTrackers.call(this);\n    var cat = this._trackersTranslator;\n    var index;\n\n    if (!this.isVisible()) {\n      return;\n    }\n\n    _each(cat, function (i, category) {\n      if (category) {\n        index = i;\n        return false;\n      }\n    });\n\n    cat[index + 360] = cat[index];\n  },\n  getNeighborPoint: function (x, y) {\n    var pos = convertXYToPolar(this.getValueAxis().getCenter(), x, y);\n    return chart.getNeighborPoint.call(this, pos.phi, pos.r);\n  },\n  _applyVisibleArea: function () {\n    var canvas = this.getValueAxis().getCanvas();\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n\n  getSeriesPairCoord(params, isArgument) {\n    var coords = null;\n    var paramName = isArgument ? \"argument\" : \"radius\";\n    var points = this.getVisiblePoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {\n        x: p.x,\n        y: p.y\n      } : void 0;\n\n      if (_isDefined(tmpPoint)) {\n        coords = tmpPoint;\n        break;\n      }\n    }\n\n    return coords;\n  }\n\n});\nexport { chart, polar };","map":{"version":3,"sources":["/Users/rahulsharma/node_modules/devextreme/esm/viz/series/scatter_series.js"],"names":["extend","_extend","inArray","each","_each","rangeCalculator","isDefined","_isDefined","isString","_isString","map","_map","normalizeEnum","_normalizeEnum","convertXYToPolar","noop","_noop","math","Math","_abs","abs","_sqrt","sqrt","_max","max","DEFAULT_TRACKER_WIDTH","DEFAULT_DURATION","HIGH_ERROR","LOW_ERROR","VARIANCE","STANDARD_DEVIATION","STANDARD_ERROR","PERCENT","FIXED","UNDEFINED","DISCRETE","LOGARITHMIC","DATETIME","chart","polar","sum","array","result","_","value","isErrorBarTypeCorrect","type","variance","expectedValue","length","calculateAvgErrorBars","data","series","errorBarsOptions","getOptions","valueErrorBar","valueField","getValueFields","lowValueField","highValueField","areErrorBarsVisible","fusionData","reduce","item","calculateSumErrorBars","getMinMaxAggregator","compare","_ref","intervalStart","intervalEnd","targetData","getArgumentField","_getIntervalCenter","checkFields","fieldsToCheck","skippedFields","allFieldsIsValid","field","isArgument","selector","baseScatterMethods","_defaultDuration","_defaultTrackerWidth","_applyStyle","_updateOptions","_parseStyle","_prepareSegment","_drawSegment","_appendInGroup","_group","append","_extGroups","seriesGroup","_createLegendState","styleOptions","defaultColor","fill","color","hatching","direction","_applyElementsClipRect","settings","_paneClipRectID","_applyMarkerClipRect","_forceClipping","_createGroup","groupName","parent","target","group","_renderer","g","attr","_applyClearingSettings","opacity","scale","_options","rotated","translateX","translateY","_createGroups","_setMarkerGroupSettings","_createPointStyles","_getMarkerGroupOptions","normal","class","_markersGroup","getVisibleArea","_visibleArea","errorBarOptions","_errorBarsEnabled","displayMode","groupPointsByCoords","cat","getVisiblePoints","p","pointCoord","parseInt","vy","vx","Array","isArray","push","_createErrorBarGroup","animationEnabled","stroke","lineWidth","sharp","_widePaneClipRectID","_setGroupsSettings","_setLabelGroupSettings","_getCreatingPointOptions","defaultPointOptions","creatingPointOptions","_predefinedPointOptions","normalStyle","_getPointOptions","styles","r","_parsePointOptions","_preparePointOptions","label","_getOptionsForPoint","point","_parsePointStyle","style","defaultBorderColor","defaultSize","border","sizeValue","size","visible","width","pointOptions","mainPointColor","mainSeriesColor","containerColor","containerBackgroundColor","visibility","hover","hoverStyle","selection","selectionStyle","_checkData","argument","getArgumentRangeInitialValue","points","getPoints","useAggregation","_points$0$aggregation","_points$aggregationIn","min","aggregationInfo","getValueRangeInitialValue","_getRangeData","getRangeData","_getPointDataSelector","argumentField","tagField","getTagField","pointData","_processEmptyValue","tag","lowError","highError","valueAxisType","valueType","_drawPoint","options","isInVisibleArea","clearVisibility","draw","groups","hasAnimation","firstDrawing","_drawnPoints","setInvisibility","_animateComplete","animationSettings","duration","_labelsGroup","animate","_errorBarGroup","_animate","that","lastPointIndex","i","x","y","argAxis","getArgumentAxis","getVisualRangeCenter","minVisible","maxVisible","_defaultAggregator","_aggregators","avg","_ref2","aggregationResult","_ref3","count","_ref4","filter","a","b","_endUpdateData","valueFields","_calculateErrorBars","errorBarType","floatErrorValue","parseFloat","valueArray","valueArrayLength","meanValue","processDataItem","addSubError","_i","error","_patchMarginOptions","maxSize","sizePointNormalState","usePointsToDefineAutoHiding","drawTrackers","trackers","trackersGroup","segments","_segments","isVisible","_trackers","_trackersGroup","segment","_drawTrackerElement","_updateTrackerElement","_trackersTranslator","_checkAxisVisibleAreaCoord","coord","axis","getValueAxis","visibleArea","checkSeriesViewportCoord","getSeriesPairCoord","oppositeCoord","isOpposite","coordName","oppositeCoordName","tmpCoord","_getNearestPoints","nextPoint","_getBezierPoints","_getNearestPointsByCoord","allPoints","bezierPoints","nearestPoints","forEach","getNeighborPoint","pCoord","nCoord","minDistance","distance","_applyVisibleArea","visibleX","visibleY","minX","maxX","minY","maxY","getPointCenterByArg","arg","getPointsByArg","getCenterCoord","call","index","category","pos","getCenter","phi","canvas","getCanvas","left","right","top","height","bottom","params","coords","paramName","tmpPoint","valueOf"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/viz/series/scatter_series.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    extend as _extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    inArray\r\n} from \"../../core/utils/array\";\r\nimport {\r\n    each as _each\r\n} from \"../../core/utils/iterator\";\r\nimport rangeCalculator from \"./helpers/range_data_calculator\";\r\nimport {\r\n    isDefined as _isDefined,\r\n    isString as _isString\r\n} from \"../../core/utils/type\";\r\nimport {\r\n    map as _map,\r\n    normalizeEnum as _normalizeEnum,\r\n    convertXYToPolar\r\n} from \"../core/utils\";\r\nimport {\r\n    noop as _noop\r\n} from \"../../core/utils/common\";\r\nvar math = Math;\r\nvar _abs = math.abs;\r\nvar _sqrt = math.sqrt;\r\nvar _max = math.max;\r\nvar DEFAULT_TRACKER_WIDTH = 12;\r\nvar DEFAULT_DURATION = 400;\r\nvar HIGH_ERROR = \"highError\";\r\nvar LOW_ERROR = \"lowError\";\r\nvar VARIANCE = \"variance\";\r\nvar STANDARD_DEVIATION = \"stddeviation\";\r\nvar STANDARD_ERROR = \"stderror\";\r\nvar PERCENT = \"percent\";\r\nvar FIXED = \"fixed\";\r\nvar UNDEFINED = \"undefined\";\r\nvar DISCRETE = \"discrete\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar DATETIME = \"datetime\";\r\nvar chart = {};\r\nvar polar = {};\r\n\r\nfunction sum(array) {\r\n    var result = 0;\r\n    _each(array, (function(_, value) {\r\n        result += value\r\n    }));\r\n    return result\r\n}\r\n\r\nfunction isErrorBarTypeCorrect(type) {\r\n    return -1 !== inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR])\r\n}\r\n\r\nfunction variance(array, expectedValue) {\r\n    return sum(_map(array, (function(value) {\r\n        return (value - expectedValue) * (value - expectedValue)\r\n    }))) / array.length\r\n}\r\n\r\nfunction calculateAvgErrorBars(result, data, series) {\r\n    var errorBarsOptions = series.getOptions().valueErrorBar;\r\n    var valueField = series.getValueFields()[0];\r\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n    if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\r\n        var fusionData = data.reduce((function(result, item) {\r\n            if (_isDefined(item[lowValueField])) {\r\n                result[0] += item[valueField] - item[lowValueField];\r\n                result[1]++\r\n            }\r\n            if (_isDefined(item[highValueField])) {\r\n                result[2] += item[highValueField] - item[valueField];\r\n                result[3]++\r\n            }\r\n            return result\r\n        }), [0, 0, 0, 0]);\r\n        if (fusionData[1]) {\r\n            result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1]\r\n        }\r\n        if (fusionData[2]) {\r\n            result[highValueField] = result[valueField] + fusionData[2] / fusionData[3]\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction calculateSumErrorBars(result, data, series) {\r\n    var errorBarsOptions = series.getOptions().valueErrorBar;\r\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n    if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\r\n        result[lowValueField] = 0;\r\n        result[highValueField] = 0;\r\n        result = data.reduce((function(result, item) {\r\n            result[lowValueField] += item[lowValueField];\r\n            result[highValueField] += item[highValueField];\r\n            return result\r\n        }), result)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction getMinMaxAggregator(compare) {\r\n    return (_ref, series) => {\r\n        var {\r\n            intervalStart: intervalStart,\r\n            intervalEnd: intervalEnd,\r\n            data: data\r\n        } = _ref;\r\n        var valueField = series.getValueFields()[0];\r\n        var targetData = data[0];\r\n        targetData = data.reduce((result, item) => {\r\n            var value = item[valueField];\r\n            if (null === result[valueField]) {\r\n                result = item\r\n            }\r\n            if (null !== value && compare(value, result[valueField])) {\r\n                return item\r\n            }\r\n            return result\r\n        }, targetData);\r\n        return _extend({}, targetData, {\r\n            [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n        })\r\n    }\r\n}\r\n\r\nfunction checkFields(data, fieldsToCheck, skippedFields) {\r\n    var allFieldsIsValid = true;\r\n    for (var field in fieldsToCheck) {\r\n        var isArgument = \"argument\" === field;\r\n        if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\r\n            var selector = fieldsToCheck[field];\r\n            if (!isArgument) {\r\n                skippedFields[selector] = (skippedFields[selector] || 0) + 1\r\n            }\r\n            allFieldsIsValid = false\r\n        }\r\n    }\r\n    return allFieldsIsValid\r\n}\r\nvar baseScatterMethods = {\r\n    _defaultDuration: DEFAULT_DURATION,\r\n    _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\r\n    _applyStyle: _noop,\r\n    _updateOptions: _noop,\r\n    _parseStyle: _noop,\r\n    _prepareSegment: _noop,\r\n    _drawSegment: _noop,\r\n    _appendInGroup: function() {\r\n        this._group.append(this._extGroups.seriesGroup)\r\n    },\r\n    _createLegendState: function(styleOptions, defaultColor) {\r\n        return {\r\n            fill: styleOptions.color || defaultColor,\r\n            hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\r\n                direction: \"right\"\r\n            }) : void 0\r\n        }\r\n    },\r\n    _applyElementsClipRect: function(settings) {\r\n        settings[\"clip-path\"] = this._paneClipRectID\r\n    },\r\n    _applyMarkerClipRect: function(settings) {\r\n        settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null\r\n    },\r\n    _createGroup: function(groupName, parent, target, settings) {\r\n        var group = parent[groupName] = parent[groupName] || this._renderer.g();\r\n        target && group.append(target);\r\n        settings && group.attr(settings)\r\n    },\r\n    _applyClearingSettings: function(settings) {\r\n        settings.opacity = null;\r\n        settings.scale = null;\r\n        if (this._options.rotated) {\r\n            settings.translateX = null\r\n        } else {\r\n            settings.translateY = null\r\n        }\r\n    },\r\n    _createGroups: function() {\r\n        this._createGroup(\"_markersGroup\", this, this._group);\r\n        this._createGroup(\"_labelsGroup\", this)\r\n    },\r\n    _setMarkerGroupSettings: function() {\r\n        var settings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\r\n        settings.class = \"dxc-markers\";\r\n        settings.opacity = 1;\r\n        this._applyMarkerClipRect(settings);\r\n        this._markersGroup.attr(settings)\r\n    },\r\n    getVisibleArea: function() {\r\n        return this._visibleArea\r\n    },\r\n    areErrorBarsVisible: function() {\r\n        var errorBarOptions = this._options.valueErrorBar;\r\n        return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField))\r\n    },\r\n    groupPointsByCoords(rotated) {\r\n        var cat = [];\r\n        _each(this.getVisiblePoints(), (function(_, p) {\r\n            var pointCoord = parseInt(rotated ? p.vy : p.vx);\r\n            if (!cat[pointCoord]) {\r\n                cat[pointCoord] = p\r\n            } else {\r\n                Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p]\r\n            }\r\n        }));\r\n        return cat\r\n    },\r\n    _createErrorBarGroup: function(animationEnabled) {\r\n        var errorBarOptions = this._options.valueErrorBar;\r\n        var settings;\r\n        if (this.areErrorBarsVisible()) {\r\n            settings = {\r\n                class: \"dxc-error-bars\",\r\n                stroke: errorBarOptions.color,\r\n                \"stroke-width\": errorBarOptions.lineWidth,\r\n                opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\r\n                \"stroke-linecap\": \"square\",\r\n                sharp: true,\r\n                \"clip-path\": this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID\r\n            };\r\n            this._createGroup(\"_errorBarGroup\", this, this._group, settings)\r\n        }\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        this._setMarkerGroupSettings();\r\n        this._setLabelGroupSettings(animationEnabled);\r\n        this._createErrorBarGroup(animationEnabled)\r\n    },\r\n    _getCreatingPointOptions: function() {\r\n        var defaultPointOptions;\r\n        var creatingPointOptions = this._predefinedPointOptions;\r\n        var normalStyle;\r\n        if (!creatingPointOptions) {\r\n            defaultPointOptions = this._getPointOptions();\r\n            this._predefinedPointOptions = creatingPointOptions = _extend(true, {\r\n                styles: {}\r\n            }, defaultPointOptions);\r\n            normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\r\n            creatingPointOptions.styles = creatingPointOptions.styles || {};\r\n            creatingPointOptions.styles.normal = {\r\n                \"stroke-width\": normalStyle[\"stroke-width\"],\r\n                r: normalStyle.r,\r\n                opacity: normalStyle.opacity\r\n            }\r\n        }\r\n        return creatingPointOptions\r\n    },\r\n    _getPointOptions: function() {\r\n        return this._parsePointOptions(this._preparePointOptions(), this._options.label)\r\n    },\r\n    _getOptionsForPoint: function() {\r\n        return this._options.point\r\n    },\r\n    _parsePointStyle: function(style, defaultColor, defaultBorderColor, defaultSize) {\r\n        var border = style.border || {};\r\n        var sizeValue = void 0 !== style.size ? style.size : defaultSize;\r\n        return {\r\n            fill: style.color || defaultColor,\r\n            stroke: border.color || defaultBorderColor,\r\n            \"stroke-width\": border.visible ? border.width : 0,\r\n            r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\r\n        }\r\n    },\r\n    _createPointStyles: function(pointOptions) {\r\n        var mainPointColor = pointOptions.color || this._options.mainSeriesColor;\r\n        var containerColor = this._options.containerBackgroundColor;\r\n        var normalStyle = this._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\r\n        normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\r\n        return {\r\n            normal: normalStyle,\r\n            hover: this._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\r\n            selection: this._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\r\n        }\r\n    },\r\n    _checkData: function(data, skippedFields, fieldsToCheck) {\r\n        fieldsToCheck = fieldsToCheck || {\r\n            value: this.getValueFields()[0]\r\n        };\r\n        fieldsToCheck.argument = this.getArgumentField();\r\n        return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value\r\n    },\r\n    getArgumentRangeInitialValue() {\r\n        var points = this.getPoints();\r\n        if (this.useAggregation() && points.length) {\r\n            var _points$0$aggregation, _points$aggregationIn;\r\n            return {\r\n                min: null === (_points$0$aggregation = points[0].aggregationInfo) || void 0 === _points$0$aggregation ? void 0 : _points$0$aggregation.intervalStart,\r\n                max: null === (_points$aggregationIn = points[points.length - 1].aggregationInfo) || void 0 === _points$aggregationIn ? void 0 : _points$aggregationIn.intervalEnd\r\n            }\r\n        }\r\n        return\r\n    },\r\n    getValueRangeInitialValue: function() {\r\n        return\r\n    },\r\n    _getRangeData: function() {\r\n        return rangeCalculator.getRangeData(this)\r\n    },\r\n    _getPointDataSelector: function() {\r\n        var valueField = this.getValueFields()[0];\r\n        var argumentField = this.getArgumentField();\r\n        var tagField = this.getTagField();\r\n        var areErrorBarsVisible = this.areErrorBarsVisible();\r\n        var lowValueField;\r\n        var highValueField;\r\n        if (areErrorBarsVisible) {\r\n            var errorBarOptions = this._options.valueErrorBar;\r\n            lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\r\n            highValueField = errorBarOptions.highValueField || HIGH_ERROR\r\n        }\r\n        return data => {\r\n            var pointData = {\r\n                value: this._processEmptyValue(data[valueField]),\r\n                argument: data[argumentField],\r\n                tag: data[tagField],\r\n                data: data\r\n            };\r\n            if (areErrorBarsVisible) {\r\n                pointData.lowError = data[lowValueField];\r\n                pointData.highError = data[highValueField]\r\n            }\r\n            return pointData\r\n        }\r\n    },\r\n    _errorBarsEnabled: function() {\r\n        return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME\r\n    },\r\n    _drawPoint: function(options) {\r\n        var point = options.point;\r\n        if (point.isInVisibleArea()) {\r\n            point.clearVisibility();\r\n            point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\r\n            this._drawnPoints.push(point)\r\n        } else {\r\n            point.setInvisibility()\r\n        }\r\n    },\r\n    _animateComplete: function() {\r\n        var animationSettings = {\r\n            duration: this._defaultDuration\r\n        };\r\n        this._labelsGroup && this._labelsGroup.animate({\r\n            opacity: 1\r\n        }, animationSettings);\r\n        this._errorBarGroup && this._errorBarGroup.animate({\r\n            opacity: this._options.valueErrorBar.opacity || 1\r\n        }, animationSettings)\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastPointIndex = that._drawnPoints.length - 1;\r\n        _each(that._drawnPoints || [], (function(i, p) {\r\n            p.animate(i === lastPointIndex ? function() {\r\n                that._animateComplete()\r\n            } : void 0, {\r\n                translateX: p.x,\r\n                translateY: p.y\r\n            })\r\n        }))\r\n    },\r\n    _getIntervalCenter(intervalStart, intervalEnd) {\r\n        var argAxis = this.getArgumentAxis();\r\n        return \"discrete\" !== argAxis.getOptions().type ? argAxis.getVisualRangeCenter({\r\n            minVisible: intervalStart,\r\n            maxVisible: intervalEnd\r\n        }, true) : intervalStart\r\n    },\r\n    _defaultAggregator: \"avg\",\r\n    _aggregators: {\r\n        avg(_ref2, series) {\r\n            var {\r\n                data: data,\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd\r\n            } = _ref2;\r\n            if (!data.length) {\r\n                return\r\n            }\r\n            var valueField = series.getValueFields()[0];\r\n            var aggregationResult = data.reduce((result, item) => {\r\n                var value = item[valueField];\r\n                if (_isDefined(value)) {\r\n                    result[0] += value;\r\n                    result[1]++\r\n                } else if (null === value) {\r\n                    result[2]++\r\n                }\r\n                return result\r\n            }, [0, 0, 0]);\r\n            return calculateAvgErrorBars({\r\n                [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n            }, data, series)\r\n        },\r\n        sum(_ref3, series) {\r\n            var {\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd,\r\n                data: data\r\n            } = _ref3;\r\n            if (!data.length) {\r\n                return\r\n            }\r\n            var valueField = series.getValueFields()[0];\r\n            var aggregationResult = data.reduce((result, item) => {\r\n                var value = item[valueField];\r\n                if (void 0 !== value) {\r\n                    result[0] += value\r\n                }\r\n                if (null === value) {\r\n                    result[1]++\r\n                } else if (void 0 === value) {\r\n                    result[2]++\r\n                }\r\n                return result\r\n            }, [0, 0, 0]);\r\n            var value = aggregationResult[0];\r\n            if (aggregationResult[1] === data.length) {\r\n                value = null\r\n            }\r\n            if (aggregationResult[2] === data.length) {\r\n                return\r\n            }\r\n            return calculateSumErrorBars({\r\n                [valueField]: value,\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n            }, data, series)\r\n        },\r\n        count(_ref4, series) {\r\n            var {\r\n                data: data,\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd\r\n            } = _ref4;\r\n            var valueField = series.getValueFields()[0];\r\n            return {\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),\r\n                [valueField]: data.filter(i => void 0 !== i[valueField]).length\r\n            }\r\n        },\r\n        min: getMinMaxAggregator((a, b) => a < b),\r\n        max: getMinMaxAggregator((a, b) => a > b)\r\n    },\r\n    _endUpdateData: function() {\r\n        delete this._predefinedPointOptions\r\n    },\r\n    getArgumentField: function() {\r\n        return this._options.argumentField || \"arg\"\r\n    },\r\n    getValueFields: function() {\r\n        var options = this._options;\r\n        var errorBarsOptions = options.valueErrorBar;\r\n        var valueFields = [options.valueField || \"val\"];\r\n        var lowValueField;\r\n        var highValueField;\r\n        if (errorBarsOptions) {\r\n            lowValueField = errorBarsOptions.lowValueField;\r\n            highValueField = errorBarsOptions.highValueField;\r\n            _isString(lowValueField) && valueFields.push(lowValueField);\r\n            _isString(highValueField) && valueFields.push(highValueField)\r\n        }\r\n        return valueFields\r\n    },\r\n    _calculateErrorBars: function(data) {\r\n        if (!this.areErrorBarsVisible()) {\r\n            return\r\n        }\r\n        var options = this._options;\r\n        var errorBarsOptions = options.valueErrorBar;\r\n        var errorBarType = _normalizeEnum(errorBarsOptions.type);\r\n        var floatErrorValue = parseFloat(errorBarsOptions.value);\r\n        var valueField = this.getValueFields()[0];\r\n        var value;\r\n        var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n        var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n        var valueArray;\r\n        var valueArrayLength;\r\n        var meanValue;\r\n        var processDataItem;\r\n        var addSubError = function(_i, item) {\r\n            value = item.value;\r\n            item.lowError = value - floatErrorValue;\r\n            item.highError = value + floatErrorValue\r\n        };\r\n        switch (errorBarType) {\r\n            case FIXED:\r\n                processDataItem = addSubError;\r\n                break;\r\n            case PERCENT:\r\n                processDataItem = function(_, item) {\r\n                    value = item.value;\r\n                    var error = value * floatErrorValue / 100;\r\n                    item.lowError = value - error;\r\n                    item.highError = value + error\r\n                };\r\n                break;\r\n            case UNDEFINED:\r\n                processDataItem = function(_, item) {\r\n                    item.lowError = item.data[lowValueField];\r\n                    item.highError = item.data[highValueField]\r\n                };\r\n                break;\r\n            default:\r\n                valueArray = _map(data, (function(item) {\r\n                    return _isDefined(item.data[valueField]) ? item.data[valueField] : null\r\n                }));\r\n                valueArrayLength = valueArray.length;\r\n                floatErrorValue = floatErrorValue || 1;\r\n                switch (errorBarType) {\r\n                    case VARIANCE:\r\n                        floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\r\n                        processDataItem = addSubError;\r\n                        break;\r\n                    case STANDARD_DEVIATION:\r\n                        meanValue = sum(valueArray) / valueArrayLength;\r\n                        floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\r\n                        processDataItem = function(_, item) {\r\n                            item.lowError = meanValue - floatErrorValue;\r\n                            item.highError = meanValue + floatErrorValue\r\n                        };\r\n                        break;\r\n                    case STANDARD_ERROR:\r\n                        floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\r\n                        processDataItem = addSubError\r\n                }\r\n        }\r\n        processDataItem && _each(data, processDataItem)\r\n    },\r\n    _patchMarginOptions: function(options) {\r\n        var pointOptions = this._getCreatingPointOptions();\r\n        var styles = pointOptions.styles;\r\n        var maxSize = [styles.normal, styles.hover, styles.selection].reduce((function(max, style) {\r\n            return _max(max, 2 * style.r + style[\"stroke-width\"])\r\n        }), 0);\r\n        options.size = pointOptions.visible ? maxSize : 0;\r\n        options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\r\n        return options\r\n    },\r\n    usePointsToDefineAutoHiding: () => true\r\n};\r\nchart = _extend({}, baseScatterMethods, {\r\n    drawTrackers: function() {\r\n        var that = this;\r\n        var trackers;\r\n        var trackersGroup;\r\n        var segments = that._segments || [];\r\n        var rotated = that._options.rotated;\r\n        if (!that.isVisible()) {\r\n            return\r\n        }\r\n        if (segments.length) {\r\n            trackers = that._trackers = that._trackers || [];\r\n            trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\r\n                fill: \"gray\",\r\n                opacity: .001,\r\n                stroke: \"gray\",\r\n                class: \"dxc-trackers\"\r\n            })).attr({\r\n                \"clip-path\": this._paneClipRectID || null\r\n            }).append(that._group);\r\n            _each(segments, (function(i, segment) {\r\n                if (!trackers[i]) {\r\n                    trackers[i] = that._drawTrackerElement(segment).data({\r\n                        \"chart-data-series\": that\r\n                    }).append(trackersGroup)\r\n                } else {\r\n                    that._updateTrackerElement(segment, trackers[i])\r\n                }\r\n            }))\r\n        }\r\n        that._trackersTranslator = that.groupPointsByCoords(rotated)\r\n    },\r\n    _checkAxisVisibleAreaCoord(isArgument, coord) {\r\n        var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord\r\n    },\r\n    checkSeriesViewportCoord(axis, coord) {\r\n        return this.getPoints().length && this.isVisible()\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var points = this.getVisiblePoints();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    _getNearestPoints: (point, nextPoint) => [point, nextPoint],\r\n    _getBezierPoints: () => [],\r\n    _getNearestPointsByCoord(coord, isArgument) {\r\n        var that = this;\r\n        var rotated = that.getOptions().rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = isOpposite ? \"vy\" : \"vx\";\r\n        var allPoints = that.getPoints();\r\n        var bezierPoints = that._getBezierPoints();\r\n        var nearestPoints = [];\r\n        if (allPoints.length > 1) {\r\n            allPoints.forEach((point, i) => {\r\n                var nextPoint = allPoints[i + 1];\r\n                if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {\r\n                    nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints))\r\n                }\r\n            })\r\n        } else {\r\n            nearestPoints.push([allPoints[0], allPoints[0]])\r\n        }\r\n        return nearestPoints\r\n    },\r\n    getNeighborPoint: function(x, y) {\r\n        var pCoord = this._options.rotated ? y : x;\r\n        var nCoord = pCoord;\r\n        var cat = this._trackersTranslator;\r\n        var point = null;\r\n        var minDistance;\r\n        var oppositeCoord = this._options.rotated ? x : y;\r\n        var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\r\n        if (this.isVisible() && cat) {\r\n            point = cat[pCoord];\r\n            do {\r\n                point = cat[nCoord] || cat[pCoord];\r\n                pCoord--;\r\n                nCoord++\r\n            } while ((pCoord >= 0 || nCoord < cat.length) && !point);\r\n            if (Array.isArray(point)) {\r\n                minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\r\n                _each(point, (function(i, p) {\r\n                    var distance = _abs(p[oppositeCoordName] - oppositeCoord);\r\n                    if (minDistance >= distance) {\r\n                        minDistance = distance;\r\n                        point = p\r\n                    }\r\n                }))\r\n            }\r\n        }\r\n        return point\r\n    },\r\n    _applyVisibleArea: function() {\r\n        var rotated = this._options.rotated;\r\n        var visibleX = (rotated ? this.getValueAxis() : this.getArgumentAxis()).getVisibleArea();\r\n        var visibleY = (rotated ? this.getArgumentAxis() : this.getValueAxis()).getVisibleArea();\r\n        this._visibleArea = {\r\n            minX: visibleX[0],\r\n            maxX: visibleX[1],\r\n            minY: visibleY[0],\r\n            maxY: visibleY[1]\r\n        }\r\n    },\r\n    getPointCenterByArg(arg) {\r\n        var point = this.getPointsByArg(arg)[0];\r\n        return point ? point.getCenterCoord() : void 0\r\n    }\r\n});\r\npolar = _extend({}, baseScatterMethods, {\r\n    drawTrackers: function() {\r\n        chart.drawTrackers.call(this);\r\n        var cat = this._trackersTranslator;\r\n        var index;\r\n        if (!this.isVisible()) {\r\n            return\r\n        }\r\n        _each(cat, (function(i, category) {\r\n            if (category) {\r\n                index = i;\r\n                return false\r\n            }\r\n        }));\r\n        cat[index + 360] = cat[index]\r\n    },\r\n    getNeighborPoint: function(x, y) {\r\n        var pos = convertXYToPolar(this.getValueAxis().getCenter(), x, y);\r\n        return chart.getNeighborPoint.call(this, pos.phi, pos.r)\r\n    },\r\n    _applyVisibleArea: function() {\r\n        var canvas = this.getValueAxis().getCanvas();\r\n        this._visibleArea = {\r\n            minX: canvas.left,\r\n            maxX: canvas.width - canvas.right,\r\n            minY: canvas.top,\r\n            maxY: canvas.height - canvas.bottom\r\n        }\r\n    },\r\n    getSeriesPairCoord(params, isArgument) {\r\n        var coords = null;\r\n        var paramName = isArgument ? \"argument\" : \"radius\";\r\n        var points = this.getVisiblePoints();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {\r\n                x: p.x,\r\n                y: p.y\r\n            } : void 0;\r\n            if (_isDefined(tmpPoint)) {\r\n                coords = tmpPoint;\r\n                break\r\n            }\r\n        }\r\n        return coords\r\n    }\r\n});\r\nexport {\r\n    chart,\r\n    polar\r\n};\r\n"]},"metadata":{},"sourceType":"module"}