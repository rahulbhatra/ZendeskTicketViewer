{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/xy_axes.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { Range } from \"../translators/range\";\nimport formatHelper from \"../../format_helper\";\nimport dateUtils from \"../../core/utils/date\";\nimport { extend } from \"../../core/utils/extend\";\nimport { generateDateBreaks } from \"./datetime_breaks\";\nimport { noop } from \"../../core/utils/common\";\nimport { getLog, patchFontOptions, getCosAndSin } from \"../core/utils\";\nimport { isDefined } from \"../../core/utils/type\";\nimport constants from \"./axes_constants\";\nvar getNextDateUnit = dateUtils.getNextDateUnit;\nvar correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning;\nvar _math = Math;\nvar _max = _math.max;\nvar TOP = constants.top;\nvar BOTTOM = constants.bottom;\nvar LEFT = constants.left;\nvar RIGHT = constants.right;\nvar CENTER = constants.center;\nvar SCALE_BREAK_OFFSET = 3;\nvar RANGE_RATIO = .3;\nvar WAVED_LINE_CENTER = 2;\nvar WAVED_LINE_TOP = 0;\nvar WAVED_LINE_BOTTOM = 4;\nvar WAVED_LINE_LENGTH = 24;\nvar TICKS_CORRECTIONS = {\n  left: -1,\n  top: -1,\n  right: 0,\n  bottom: 0,\n  center: -.5\n};\n\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\n  var dateUnitInterval;\n  var i;\n\n  if (\"week\" === tickInterval) {\n    tickInterval = \"day\";\n  }\n\n  if (\"quarter\" === tickInterval) {\n    tickInterval = \"month\";\n  }\n\n  if (datesDifferences[tickInterval]) {\n    for (i = 0; i < dateUtils.dateUnitIntervals.length; i++) {\n      dateUnitInterval = dateUtils.dateUnitIntervals[i];\n\n      if (datesDifferences[dateUnitInterval]) {\n        datesDifferences[dateUnitInterval] = false;\n        datesDifferences.count--;\n      }\n\n      if (dateUnitInterval === tickInterval) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sortingBreaks(breaks) {\n  return breaks.sort(function (a, b) {\n    return a.from - b.from;\n  });\n}\n\nfunction getMarkerDates(min, max, markerInterval) {\n  var origMin = min;\n  var dates;\n  min = correctDateWithUnitBeginning(min, markerInterval);\n  max = correctDateWithUnitBeginning(max, markerInterval);\n  dates = dateUtils.getSequenceByInterval(min, max, markerInterval);\n\n  if (dates.length && origMin > dates[0]) {\n    dates = dates.slice(1);\n  }\n\n  return dates;\n}\n\nfunction getStripHorizontalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"right\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getStripVerticalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"bottom\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getMarkerInterval(tickInterval) {\n  var markerInterval = getNextDateUnit(tickInterval);\n\n  if (\"quarter\" === markerInterval) {\n    markerInterval = getNextDateUnit(markerInterval);\n  }\n\n  return markerInterval;\n}\n\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\n  var format = markerInterval;\n  var datesDifferences = prevDate && dateUtils.getDatesDifferences(prevDate, curDate);\n\n  if (prevDate && \"year\" !== tickInterval) {\n    prepareDatesDifferences(datesDifferences, tickInterval);\n    format = formatHelper.getDateFormatByDifferences(datesDifferences);\n  }\n\n  return format;\n}\n\nfunction getMaxSide(act, boxes) {\n  return boxes.reduce(function (prevValue, box) {\n    return _max(prevValue, act(box));\n  }, 0);\n}\n\nfunction getDistanceByAngle(bBox, rotationAngle) {\n  rotationAngle = _math.abs(rotationAngle);\n  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\n  var a = rotationAngle * (_math.PI / 180);\n\n  if (a >= _math.atan(bBox.height / bBox.width)) {\n    return bBox.height / _math.abs(_math.sin(a));\n  } else {\n    return bBox.width;\n  }\n}\n\nfunction getMaxConstantLinePadding(constantLines) {\n  return constantLines.reduce(function (padding, options) {\n    return _max(padding, options.paddingTopBottom);\n  }, 0);\n}\n\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\n  return constantLines.some(function (options) {\n    return options.label.verticalAlignment === alignment;\n  }) && labelHeight || 0;\n}\n\nfunction getLeftMargin(bBox) {\n  return _math.abs(bBox.x) || 0;\n}\n\nfunction getRightMargin(bBox) {\n  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;\n}\n\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\n  var i;\n  var length;\n  var maxRange = null;\n  var ranges = [];\n  var curValue;\n  var prevValue;\n  var curRange;\n\n  for (i = 1, length = points.length; i < length; i++) {\n    curValue = points[i];\n    prevValue = points[i - 1];\n    curRange = getRange(curValue, prevValue);\n\n    if (edgePoints.indexOf(curValue) >= 0) {\n      if (!maxRange || curRange > maxRange.length) {\n        maxRange = {\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        };\n      }\n    } else {\n      if (maxRange && curRange < maxRange.length) {\n        ranges.push(maxRange);\n      } else {\n        ranges.push({\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        });\n      }\n\n      maxRange = null;\n    }\n  }\n\n  if (maxRange) {\n    ranges.push(maxRange);\n  }\n\n  return ranges;\n}\n\nfunction generateAutoBreaks(_ref, series, _ref2) {\n  var {\n    logarithmBase: logarithmBase,\n    type: type,\n    maxAutoBreakCount: maxAutoBreakCount\n  } = _ref;\n  var {\n    minVisible: minVisible,\n    maxVisible: maxVisible\n  } = _ref2;\n  var breaks = [];\n  var getRange = \"logarithmic\" === type ? (min, max) => getLog(max / min, logarithmBase) : (min, max) => max - min;\n  var visibleRange = getRange(minVisible, maxVisible);\n  var points = series.reduce((result, s) => {\n    var points = s.getPointsInViewPort();\n    result[0] = result[0].concat(points[0]);\n    result[1] = result[1].concat(points[1]);\n    return result;\n  }, [[], []]);\n  var sortedAllPoints = points[0].concat(points[1]).sort((a, b) => b - a);\n  var edgePoints = points[1].filter(p => points[0].indexOf(p) < 0);\n  var minDiff = RANGE_RATIO * visibleRange;\n  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort((a, b) => b.length - a.length);\n  var epsilon = _math.min.apply(null, ranges.map(r => r.length)) / 1e3;\n\n  var _maxAutoBreakCount = isDefined(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\n\n  for (var i = 0; i < _maxAutoBreakCount; i++) {\n    if (ranges[i].length >= minDiff) {\n      if (visibleRange <= ranges[i].length) {\n        break;\n      }\n\n      visibleRange -= ranges[i].length;\n\n      if (visibleRange > epsilon || visibleRange < -epsilon) {\n        breaks.push({\n          from: ranges[i].start,\n          to: ranges[i].end\n        });\n        minDiff = RANGE_RATIO * visibleRange;\n      }\n    } else {\n      break;\n    }\n  }\n\n  sortingBreaks(breaks);\n  return breaks;\n}\n\nexport default {\n  linear: {\n    _getStep: function (boxes, rotationAngle) {\n      var spacing = this._options.label.minSpacing;\n      var func = this._isHorizontal ? function (box) {\n        return box.width + spacing;\n      } : function (box) {\n        return box.height;\n      };\n      var maxLabelLength = getMaxSide(func, boxes);\n\n      if (rotationAngle) {\n        maxLabelLength = getDistanceByAngle({\n          width: maxLabelLength,\n          height: this._getMaxLabelHeight(boxes, 0)\n        }, rotationAngle);\n      }\n\n      return constants.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength);\n    },\n    _getMaxLabelHeight: function (boxes, spacing) {\n      return getMaxSide(function (box) {\n        return box.height;\n      }, boxes) + spacing;\n    },\n    _validateOverlappingMode: function (mode, displayMode) {\n      if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\n        return constants.validateOverlappingMode(mode);\n      }\n\n      return mode;\n    },\n    _validateDisplayMode: function (mode) {\n      return this._isHorizontal ? mode : \"standard\";\n    },\n    getMarkerTrackers: function () {\n      return this._markerTrackers;\n    },\n    _getSharpParam: function (opposite) {\n      return this._isHorizontal ^ opposite ? \"h\" : \"v\";\n    },\n    _createAxisElement: function () {\n      return this._renderer.path([], \"line\");\n    },\n    _updateAxisElementPosition: function () {\n      var axisCoord = this._axisPosition;\n\n      var canvas = this._getCanvasStartEnd();\n\n      this._axisElement.attr({\n        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\n      });\n    },\n    _getTranslatedCoord: function (value, offset) {\n      return this._translator.translate(value, offset);\n    },\n\n    _initAxisPositions() {\n      if (this.customPositionIsAvailable()) {\n        this._customBoundaryPosition = this.getCustomBoundaryPosition();\n      }\n\n      if (!this.customPositionIsAvailable() || this.customPositionIsBoundary()) {\n        this._axisPosition = this.getPredefinedPosition(this.getResolvedBoundaryPosition());\n      } else {\n        this._axisPosition = this.getCustomPosition();\n      }\n    },\n\n    _getTickMarkPoints(coords, length, tickOptions) {\n      var isHorizontal = this._isHorizontal;\n      var tickOrientation = this._options.tickOrientation;\n      var labelPosition = this._options.label.position;\n      var tickStartCoord;\n\n      if (isDefined(tickOrientation)) {\n        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length;\n      } else {\n        var shift = tickOptions.shift || 0;\n\n        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\n          shift = -shift;\n        }\n\n        tickStartCoord = shift + this.getTickStartPositionShift(length);\n      }\n\n      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];\n    },\n\n    getTickStartPositionShift(length) {\n      var width = this._options.width;\n      var position = this.getResolvedBoundaryPosition();\n      return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1);\n    },\n\n    _getTitleCoords: function () {\n      var horizontal = this._isHorizontal;\n      var x = this._axisPosition;\n      var y = this._axisPosition;\n      var align = this._options.title.alignment;\n\n      var canvas = this._getCanvasStartEnd();\n\n      var fromStartToEnd = horizontal || this._options.position === LEFT;\n      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\n      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\n      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\n\n      if (horizontal) {\n        x = coord;\n      } else {\n        y = coord;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _drawTitleText: function (group, coords) {\n      var options = this._options;\n      var titleOptions = options.title;\n      var attrs = {\n        opacity: titleOptions.opacity,\n        align: titleOptions.alignment,\n        class: titleOptions.cssClass\n      };\n\n      if (!titleOptions.text || !group) {\n        return;\n      }\n\n      coords = coords || this._getTitleCoords();\n\n      if (!this._isHorizontal) {\n        attrs.rotate = options.position === LEFT ? 270 : 90;\n      }\n\n      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(patchFontOptions(titleOptions.font)).attr(attrs).append(group);\n\n      this._checkTitleOverflow(text);\n\n      return text;\n    },\n    _updateTitleCoords: function () {\n      this._title && this._title.element.attr(this._getTitleCoords());\n    },\n    _drawTitle: function () {\n      var title = this._drawTitleText(this._axisTitleGroup);\n\n      if (title) {\n        this._title = {\n          element: title\n        };\n      }\n    },\n    _measureTitle: function () {\n      if (this._title) {\n        if (this._title.bBox && !this._title.originalSize) {\n          this._title.originalSize = this._title.bBox;\n        }\n\n        this._title.bBox = this._title.element.getBBox();\n      }\n    },\n    _drawDateMarker: function (date, options, range) {\n      var markerOptions = this._options.marker;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n      var pathElement;\n\n      if (null === options.x) {\n        return;\n      }\n\n      if (!options.withoutStick) {\n        pathElement = this._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\n          \"stroke-width\": markerOptions.width,\n          stroke: markerOptions.color,\n          \"stroke-opacity\": markerOptions.opacity,\n          sharp: \"h\"\n        }).append(this._axisElementsGroup);\n      }\n\n      var text = String(this.formatLabel(date, options.labelOptions, range));\n      return {\n        date: date,\n        x: options.x,\n        y: options.y,\n        cropped: options.withoutStick,\n        label: this._renderer.text(text, options.x, options.y).css(patchFontOptions(markerOptions.label.font)).append(this._axisElementsGroup),\n        line: pathElement,\n\n        getContentContainer() {\n          return this.label;\n        },\n\n        getEnd: function () {\n          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);\n        },\n        setTitle: function () {\n          this.title = text;\n        },\n        hideLabel: function () {\n          this.label.dispose();\n          this.label = null;\n          this.title = text;\n        },\n        hide: function () {\n          if (pathElement) {\n            pathElement.dispose();\n            pathElement = null;\n          }\n\n          this.label.dispose();\n          this.label = null;\n          this.hidden = true;\n        }\n      };\n    },\n    _drawDateMarkers: function () {\n      var that = this;\n      var options = that._options;\n      var translator = that._translator;\n\n      var viewport = that._getViewportRange();\n\n      var minBound = viewport.minVisible;\n      var dateMarkers = [];\n      var dateMarker;\n\n      function draw(markerDate, format, withoutStick) {\n        return that._drawDateMarker(markerDate, {\n          x: translator.translate(markerDate),\n          y: markersAreaTop,\n          labelOptions: that._getLabelFormatOptions(format),\n          withoutStick: withoutStick\n        }, viewport);\n      }\n\n      if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\n        return [];\n      }\n\n      var markersAreaTop = that._axisPosition + options.marker.topIndent;\n      var tickInterval = dateUtils.getDateUnitInterval(this._tickInterval);\n      var markerInterval = getMarkerInterval(tickInterval);\n      var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\n\n      if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\n        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {\n          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\n          marker && markers.push(marker);\n          return markers;\n        }, []);\n\n        if (minBound < markerDates[0]) {\n          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\n          dateMarker && dateMarkers.unshift(dateMarker);\n        }\n      }\n\n      return dateMarkers;\n    },\n    _adjustDateMarkers: function (offset) {\n      offset = offset || 0;\n      var that = this;\n      var markerOptions = this._options.marker;\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var dateMarkers = this._dateMarkers;\n\n      if (!dateMarkers.length) {\n        return offset;\n      }\n\n      if (dateMarkers[0].cropped) {\n        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\n          dateMarkers[0].hideLabel();\n        }\n      }\n\n      var prevDateMarker;\n      dateMarkers.forEach(function (marker, i, markers) {\n        if (marker.cropped) {\n          return;\n        }\n\n        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\n          marker.hideLabel();\n        } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\n          prevDateMarker = marker;\n        } else {\n          marker.hide();\n        }\n      });\n\n      this._dateMarkers.forEach(function (marker) {\n        if (marker.label) {\n          var labelBBox = marker.labelBBox;\n          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\n          marker.label.attr({\n            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\n            translateY: dy + offset\n          });\n        }\n\n        if (marker.line) {\n          marker.line.attr({\n            translateY: offset\n          });\n        }\n      });\n\n      that._initializeMarkersTrackers(offset);\n\n      return offset + markerOptions.topIndent + markerOptions.separatorHeight;\n    },\n    _checkMarkersPosition: function (invert, dateMarker, prevDateMarker) {\n      if (void 0 === prevDateMarker) {\n        return true;\n      }\n\n      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();\n    },\n    _initializeMarkersTrackers: function (offset) {\n      var separatorHeight = this._options.marker.separatorHeight;\n      var renderer = this._renderer;\n\n      var businessRange = this._translator.getBusinessRange();\n\n      var canvas = this._getCanvasStartEnd();\n\n      var group = this._axisElementsGroup;\n      this._markerTrackers = this._dateMarkers.filter(function (marker) {\n        return !marker.hidden;\n      }).map(function (marker, i, markers) {\n        var nextMarker = markers[i + 1] || {\n          x: canvas.end,\n          date: businessRange.max\n        };\n        var x = marker.x;\n        var y = marker.y + offset;\n        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\n          \"stroke-width\": 1,\n          stroke: \"grey\",\n          fill: \"grey\",\n          opacity: 1e-4\n        }).append(group);\n        markerTracker.data(\"range\", {\n          startValue: marker.date,\n          endValue: nextMarker.date\n        });\n\n        if (marker.title) {\n          markerTracker.setTitle(marker.title);\n        }\n\n        return markerTracker;\n      });\n    },\n    _getLabelFormatOptions: function (formatString) {\n      var markerLabelOptions = this._markerLabelOptions;\n\n      if (!markerLabelOptions) {\n        this._markerLabelOptions = markerLabelOptions = extend(true, {}, this._options.marker.label);\n      }\n\n      if (!isDefined(this._options.marker.label.format)) {\n        markerLabelOptions.format = formatString;\n      }\n\n      return markerLabelOptions;\n    },\n    _adjustConstantLineLabels: function (constantLines) {\n      var that = this;\n      var axisPosition = that._options.position;\n      var canvas = that.getCanvas();\n      var canvasLeft = canvas.left;\n      var canvasRight = canvas.width - canvas.right;\n      var canvasTop = canvas.top;\n      var canvasBottom = canvas.height - canvas.bottom;\n      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\n      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\n      var maxLabel = 0;\n      constantLines.forEach(function (item) {\n        var isHorizontal = that._isHorizontal;\n        var linesOptions = item.options;\n        var paddingTopBottom = linesOptions.paddingTopBottom;\n        var paddingLeftRight = linesOptions.paddingLeftRight;\n        var labelOptions = linesOptions.label;\n        var labelVerticalAlignment = labelOptions.verticalAlignment;\n        var labelHorizontalAlignment = labelOptions.horizontalAlignment;\n        var labelIsInside = \"inside\" === labelOptions.position;\n        var label = item.label;\n        var box = item.labelBBox;\n        var translateX;\n        var translateY;\n\n        if (null === label || box.isEmpty) {\n          return;\n        }\n\n        if (isHorizontal) {\n          if (labelIsInside) {\n            if (labelHorizontalAlignment === LEFT) {\n              translateX = item.coord - paddingLeftRight - box.x - box.width;\n            } else {\n              translateX = item.coord + paddingLeftRight - box.x;\n            }\n\n            switch (labelVerticalAlignment) {\n              case CENTER:\n                translateY = verticalCenter - box.y - box.height / 2;\n                break;\n\n              case BOTTOM:\n                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\n                break;\n\n              default:\n                translateY = canvasTop + paddingTopBottom - box.y;\n            }\n          } else {\n            if (axisPosition === labelVerticalAlignment) {\n              maxLabel = _max(maxLabel, box.height + paddingTopBottom);\n            }\n\n            translateX = item.coord - box.x - box.width / 2;\n\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = canvasBottom + paddingTopBottom - box.y;\n            } else {\n              translateY = canvasTop - paddingTopBottom - box.y - box.height;\n            }\n          }\n        } else if (labelIsInside) {\n          if (labelVerticalAlignment === BOTTOM) {\n            translateY = item.coord + paddingTopBottom - box.y;\n          } else {\n            translateY = item.coord - paddingTopBottom - box.y - box.height;\n          }\n\n          switch (labelHorizontalAlignment) {\n            case CENTER:\n              translateX = horizontalCenter - box.x - box.width / 2;\n              break;\n\n            case RIGHT:\n              translateX = canvasRight - paddingLeftRight - box.x - box.width;\n              break;\n\n            default:\n              translateX = canvasLeft + paddingLeftRight - box.x;\n          }\n        } else {\n          if (axisPosition === labelHorizontalAlignment) {\n            maxLabel = _max(maxLabel, box.width + paddingLeftRight);\n          }\n\n          translateY = item.coord - box.y - box.height / 2;\n\n          if (labelHorizontalAlignment === RIGHT) {\n            translateX = canvasRight + paddingLeftRight - box.x;\n          } else {\n            translateX = canvasLeft - paddingLeftRight - box.x - box.width;\n          }\n        }\n\n        label.attr({\n          translateX: translateX,\n          translateY: translateY\n        });\n      });\n      return maxLabel;\n    },\n    _drawConstantLinesForEstimating: function (constantLines) {\n      var that = this;\n      var renderer = this._renderer;\n      var group = renderer.g();\n      constantLines.forEach(function (options) {\n        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\n          align: \"center\"\n        });\n      });\n      return group.append(renderer.root);\n    },\n    _estimateLabelHeight: function (bBox, labelOptions) {\n      var height = bBox.height;\n      var drawingType = labelOptions.drawingType;\n\n      if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        height = 2 * height + labelOptions.staggeringSpacing;\n      }\n\n      if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        var sinCos = getCosAndSin(labelOptions.rotationAngle);\n        height = height * sinCos.cos + bBox.width * sinCos.sin;\n      }\n\n      return height && (height + labelOptions.indentFromAxis || 0) || 0;\n    },\n    estimateMargins: function (canvas) {\n      this.updateCanvas(canvas);\n\n      var range = this._getViewportRange();\n\n      var ticksData = this._createTicksAndLabelFormat(range);\n\n      var ticks = ticksData.ticks;\n      var tickInterval = ticksData.tickInterval;\n      var options = this._options;\n\n      var constantLineOptions = this._outsideConstantLines.filter(l => l.labelOptions.visible).map(l => l.options);\n\n      var rootElement = this._renderer.root;\n      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\n      var labelValue = labelIsVisible && this.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\n\n      var labelElement = labelIsVisible && this._renderer.text(labelValue, 0, 0).css(this._textFontStyles).attr(this._textOptions).append(rootElement);\n\n      var titleElement = this._drawTitleText(rootElement, {\n        x: 0,\n        y: 0\n      });\n\n      var constantLinesLabelsElement = this._drawConstantLinesForEstimating(constantLineOptions);\n\n      var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var titleBox = titleElement && titleElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var constantLinesBox = constantLinesLabelsElement.getBBox();\n      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\n\n      var labelHeight = this._estimateLabelHeight(labelBox, options.label);\n\n      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\n      var height = labelHeight + titleHeight;\n      var margins = {\n        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\n        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\n        top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\n        bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\n      };\n      labelElement && labelElement.remove();\n      titleElement && titleElement.remove();\n      constantLinesLabelsElement && constantLinesLabelsElement.remove();\n      return margins;\n    },\n    _checkAlignmentConstantLineLabels: function (labelOptions) {\n      var position = labelOptions.position;\n      var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\n      var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\n\n      if (this._isHorizontal) {\n        if (\"outside\" === position) {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = CENTER;\n        } else {\n          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        }\n      } else if (\"outside\" === position) {\n        verticalAlignment = CENTER;\n        horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n      } else {\n        verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n        horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;\n      }\n\n      labelOptions.verticalAlignment = verticalAlignment;\n      labelOptions.horizontalAlignment = horizontalAlignment;\n    },\n    _getConstantLineLabelsCoords: function (value, lineLabelOptions) {\n      var x = value;\n      var y = value;\n\n      if (this._isHorizontal) {\n        y = this._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"];\n      } else {\n        x = this._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"];\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getAdjustedStripLabelCoords: function (strip) {\n      var stripOptions = strip.options;\n      var paddingTopBottom = stripOptions.paddingTopBottom;\n      var paddingLeftRight = stripOptions.paddingLeftRight;\n      var horizontalAlignment = stripOptions.label.horizontalAlignment;\n      var verticalAlignment = stripOptions.label.verticalAlignment;\n      var box = strip.labelBBox;\n      var labelHeight = box.height;\n      var labelWidth = box.width;\n      var labelCoords = strip.labelCoords;\n      var y = labelCoords.y - box.y;\n      var x = labelCoords.x - box.x;\n\n      if (verticalAlignment === TOP) {\n        y += paddingTopBottom;\n      } else if (verticalAlignment === CENTER) {\n        y -= labelHeight / 2;\n      } else if (verticalAlignment === BOTTOM) {\n        y -= paddingTopBottom + labelHeight;\n      }\n\n      if (horizontalAlignment === LEFT) {\n        x += paddingLeftRight;\n      } else if (horizontalAlignment === CENTER) {\n        x -= labelWidth / 2;\n      } else if (horizontalAlignment === RIGHT) {\n        x -= paddingLeftRight + labelWidth;\n      }\n\n      return {\n        translateX: x,\n        translateY: y\n      };\n    },\n    _adjustTitle: function (offset) {\n      offset = offset || 0;\n\n      if (!this._title) {\n        return;\n      }\n\n      var options = this._options;\n      var position = options.position;\n      var margin = options.title.margin;\n      var title = this._title;\n      var boxTitle = title.bBox;\n      var x = boxTitle.x;\n      var y = boxTitle.y;\n      var width = boxTitle.width;\n      var height = boxTitle.height;\n      var axisPosition = this._axisPosition;\n      var loCoord = axisPosition - margin - offset;\n      var hiCoord = axisPosition + margin + offset;\n      var params = {};\n\n      if (this._isHorizontal) {\n        if (position === TOP) {\n          params.translateY = loCoord - (y + height);\n        } else {\n          params.translateY = hiCoord - y;\n        }\n      } else if (position === LEFT) {\n        params.translateX = loCoord - (x + width);\n      } else {\n        params.translateX = hiCoord - x;\n      }\n\n      title.element.attr(params);\n    },\n    _checkTitleOverflow: function (titleElement) {\n      if (!this._title && !titleElement) {\n        return;\n      }\n\n      var canvasLength = this._getScreenDelta();\n\n      var title = titleElement ? {\n        bBox: titleElement.getBBox(),\n        element: titleElement\n      } : this._title;\n      var titleOptions = this._options.title;\n      var boxTitle = title.bBox;\n\n      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\n        title.element.setMaxSize(canvasLength, void 0, {\n          wordWrap: titleOptions.wordWrap || \"none\",\n          textOverflow: titleOptions.textOverflow || \"ellipsis\"\n        });\n        this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap;\n      } else {\n        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\n        !this._wrapped && moreThanOriginalSize && title.element.restoreText();\n      }\n    },\n    coordsIn: function (x, y) {\n      var canvas = this.getCanvas();\n      var isHorizontal = this._options.isHorizontal;\n      var position = this._options.position;\n      var coord = isHorizontal ? y : x;\n\n      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\n        return false;\n      }\n\n      if (isHorizontal && position === constants.top || !isHorizontal && position === constants.left) {\n        return coord < canvas[position];\n      }\n\n      return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position];\n    },\n    _boundaryTicksVisibility: {\n      min: true,\n      max: true\n    },\n\n    adjust() {\n      var seriesData = this._seriesData;\n\n      var viewport = this._series.filter(s => s.isVisible()).reduce((range, s) => {\n        var seriesRange = s.getViewport();\n        range.min = isDefined(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\n        range.max = isDefined(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\n\n        if (s.showZero) {\n          range = new Range(range);\n          range.correctValueZeroLevel();\n        }\n\n        return range;\n      }, {});\n\n      if (isDefined(viewport.min) && isDefined(viewport.max)) {\n        seriesData.minVisible = viewport.min;\n        seriesData.maxVisible = viewport.max;\n      }\n\n      seriesData.userBreaks = this._getScaleBreaks(this._options, {\n        minVisible: seriesData.minVisible,\n        maxVisible: seriesData.maxVisible\n      }, this._series, this.isArgumentAxis);\n\n      this._translator.updateBusinessRange(this._getViewportRange());\n    },\n\n    hasWrap() {\n      return this._wrapped;\n    },\n\n    getAxisPosition() {\n      return this._axisPosition;\n    },\n\n    _getStick: function () {\n      return !this._options.valueMarginsEnabled;\n    },\n    _getStripLabelCoords: function (from, to, stripLabelOptions) {\n      var orthogonalPositions = this._orthogonalPositions;\n      var isHorizontal = this._isHorizontal;\n      var horizontalAlignment = stripLabelOptions.horizontalAlignment;\n      var verticalAlignment = stripLabelOptions.verticalAlignment;\n      var x;\n      var y;\n\n      if (isHorizontal) {\n        if (horizontalAlignment === CENTER) {\n          x = from + (to - from) / 2;\n        } else if (horizontalAlignment === LEFT) {\n          x = from;\n        } else if (horizontalAlignment === RIGHT) {\n          x = to;\n        }\n\n        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];\n      } else {\n        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\n\n        if (verticalAlignment === TOP) {\n          y = from;\n        } else if (verticalAlignment === CENTER) {\n          y = to + (from - to) / 2;\n        } else if (verticalAlignment === BOTTOM) {\n          y = to;\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getTranslatedValue: function (value, offset) {\n      var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\n\n      var pos2 = this._axisPosition;\n      var isHorizontal = this._isHorizontal;\n      return {\n        x: isHorizontal ? pos1 : pos2,\n        y: isHorizontal ? pos2 : pos1\n      };\n    },\n    areCoordsOutsideAxis: function (coords) {\n      var coord = this._isHorizontal ? coords.x : coords.y;\n      var visibleArea = this.getVisibleArea();\n\n      if (coord < visibleArea[0] || coord > visibleArea[1]) {\n        return true;\n      }\n\n      return false;\n    },\n    _getSkippedCategory: function (ticks) {\n      var skippedCategory;\n\n      if (this._options.type === constants.discrete && this._tickOffset && 0 !== ticks.length) {\n        skippedCategory = ticks[ticks.length - 1];\n      }\n\n      return skippedCategory;\n    },\n    _filterBreaks: function (breaks, viewport, breakStyle) {\n      var minVisible = viewport.minVisible;\n      var maxVisible = viewport.maxVisible;\n      var breakSize = breakStyle ? breakStyle.width : 0;\n      return breaks.reduce(function (result, currentBreak) {\n        var from = currentBreak.from;\n        var to = currentBreak.to;\n        var lastResult = result[result.length - 1];\n        var newBreak;\n\n        if (!isDefined(from) || !isDefined(to)) {\n          return result;\n        }\n\n        if (from > to) {\n          to = [from, from = to][0];\n        }\n\n        if (result.length && from < lastResult.to) {\n          if (to > lastResult.to) {\n            lastResult.to = to > maxVisible ? maxVisible : to;\n\n            if (lastResult.gapSize) {\n              lastResult.gapSize = void 0;\n              lastResult.cumulativeWidth += breakSize;\n            }\n          }\n        } else if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\n          from = from >= minVisible ? from : minVisible;\n          to = to <= maxVisible ? to : maxVisible;\n\n          if (to - from < maxVisible - minVisible) {\n            var _lastResult$cumulativ;\n\n            newBreak = {\n              from: from,\n              to: to,\n              cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\n            };\n\n            if (currentBreak.gapSize) {\n              var _lastResult$cumulativ2;\n\n              newBreak.gapSize = dateUtils.convertMillisecondsToDateUnits(to - from);\n              newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0;\n            }\n\n            result.push(newBreak);\n          }\n        }\n\n        return result;\n      }, []);\n    },\n    _getScaleBreaks: function (axisOptions, viewport, series, isArgumentAxis) {\n      var that = this;\n      var breaks = (axisOptions.breaks || []).map(function (b) {\n        return {\n          from: that.parser(b.startValue),\n          to: that.parser(b.endValue)\n        };\n      });\n\n      if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\n        breaks = breaks.concat(generateDateBreaks(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));\n      }\n\n      if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\n        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));\n      }\n\n      return sortingBreaks(breaks);\n    },\n    _drawBreak: function (translatedEnd, positionFrom, positionTo, width, options, group) {\n      var breakStart = translatedEnd - (!this._translator.isInverted() ? width + 1 : 0);\n      var attr = {\n        \"stroke-width\": 1,\n        stroke: options.borderColor,\n        sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\n      };\n      var spaceAttr = {\n        stroke: options.color,\n        \"stroke-width\": width\n      };\n      var getPoints = this._isHorizontal ? rotateLine : function (p) {\n        return p;\n      };\n      var drawer = getLineDrawer(this._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\n      drawer(width / 2, spaceAttr);\n      drawer(0, attr);\n      drawer(width, attr);\n    },\n    _createBreakClipRect: function (from, to) {\n      var canvas = this._canvas;\n      var clipWidth = to - from;\n      var clipRect;\n\n      if (this._isHorizontal) {\n        clipRect = this._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);\n      } else {\n        clipRect = this._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);\n      }\n\n      this._breaksElements = this._breaksElements || [];\n\n      this._breaksElements.push(clipRect);\n\n      return clipRect.id;\n    },\n    _createBreaksGroup: function (clipFrom, clipTo) {\n      var group = this._renderer.g().attr({\n        class: this._axisCssPrefix + \"breaks\",\n        \"clip-path\": this._createBreakClipRect(clipFrom, clipTo)\n      }).append(this._scaleBreaksGroup);\n\n      this._breaksElements = this._breaksElements || [];\n\n      this._breaksElements.push(group);\n\n      return group;\n    },\n    _disposeBreaksGroup: function () {\n      (this._breaksElements || []).forEach(function (clipRect) {\n        clipRect.dispose();\n      });\n      this._breaksElements = null;\n    },\n    drawScaleBreaks: function (customCanvas) {\n      var that = this;\n      var options = that._options;\n      var breakStyle = options.breakStyle;\n      var position = options.position;\n      var positionFrom;\n      var positionTo;\n      var breaks = that._translator.getBusinessRange().breaks || [];\n      var additionGroup;\n      var additionBreakFrom;\n      var additionBreakTo;\n\n      that._disposeBreaksGroup();\n\n      if (!(breaks && breaks.length)) {\n        return;\n      }\n\n      var breakOptions = {\n        color: that._options.containerColor,\n        borderColor: breakStyle.color,\n        isHorizontal: that._isHorizontal,\n        isWaved: \"straight\" !== breakStyle.line.toLowerCase()\n      };\n\n      if (customCanvas) {\n        positionFrom = customCanvas.start;\n        positionTo = customCanvas.end;\n      } else {\n        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\n        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0);\n      }\n\n      var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\n\n      if (that._axisShift && options.visible) {\n        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\n        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\n        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);\n      }\n\n      breaks.forEach(function (br) {\n        if (!br.gapSize) {\n          var breakCoord = that._getTranslatedCoord(br.to);\n\n          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\n\n          if (that._axisShift && options.visible) {\n            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);\n          }\n        }\n      });\n    },\n    _getSpiderCategoryOption: noop,\n    shift: function (margins) {\n      var options = this._options;\n      var isHorizontal = options.isHorizontal;\n      var axesSpacing = this.getMultipleAxesSpacing();\n      var constantLinesGroups = this._axisConstantLineGroups;\n\n      function shiftGroup(side, group) {\n        var attr = {\n          translateX: 0,\n          translateY: 0\n        };\n        var shift = margins[side] ? margins[side] + axesSpacing : 0;\n        attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\n        (group[side] || group).attr(attr);\n        return shift;\n      }\n\n      this._axisShift = shiftGroup(options.position, this._axisGroup);\n      shiftGroup(options.position, this._axisElementsGroup);\n      (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(side => {\n        shiftGroup(side, constantLinesGroups.above);\n        shiftGroup(side, constantLinesGroups.under);\n      });\n    },\n\n    getCustomPosition(position) {\n      var orthogonalAxis = this.getOrthogonalAxis();\n      var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\n      var offset = this.getOptions().offset;\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var orthogonalAxisType = orthogonalAxis.getOptions().type;\n      var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\n      var currentPosition;\n\n      if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\n        validPosition = void 0;\n      }\n\n      if (this.positionIsBoundary(resolvedPosition)) {\n        currentPosition = this.getPredefinedPosition(resolvedPosition);\n      } else if (!isDefined(validPosition)) {\n        currentPosition = this.getPredefinedPosition(this.getOptions().position);\n      } else {\n        currentPosition = orthogonalTranslator.to(validPosition, -1);\n      }\n\n      if (isFinite(currentPosition) && isFinite(offset)) {\n        currentPosition += offset;\n      }\n\n      return currentPosition;\n    },\n\n    getCustomBoundaryPosition(position) {\n      var {\n        customPosition: customPosition,\n        offset: offset\n      } = this.getOptions();\n      var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\n      var orthogonalAxis = this.getOrthogonalAxis();\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\n\n      if (!isDefined(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\n        return;\n      }\n\n      var currentPosition = this.getCustomPosition(resolvedPosition);\n\n      if (!isDefined(currentPosition)) {\n        return this.getResolvedBoundaryPosition();\n      } else if (isDefined(customPosition)) {\n        if (currentPosition <= visibleArea.min) {\n          return this._isHorizontal ? TOP : LEFT;\n        } else if (currentPosition >= visibleArea.max) {\n          return this._isHorizontal ? BOTTOM : RIGHT;\n        }\n      } else if (isDefined(offset)) {\n        if (currentPosition <= this._orthogonalPositions.start) {\n          return this._isHorizontal ? TOP : LEFT;\n        } else if (currentPosition >= this._orthogonalPositions.end) {\n          return this._isHorizontal ? BOTTOM : RIGHT;\n        }\n      }\n\n      return currentPosition;\n    },\n\n    getResolvedPositionOption() {\n      var _options$customPositi;\n\n      var options = this.getOptions();\n      return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position;\n    },\n\n    customPositionIsAvailable() {\n      var options = this.getOptions();\n      return isDefined(this.getOrthogonalAxis()) && (isDefined(options.customPosition) || isFinite(options.offset));\n    },\n\n    hasNonBoundaryPosition() {\n      return this.customPositionIsAvailable() && !this.customPositionIsBoundary();\n    },\n\n    getResolvedBoundaryPosition() {\n      return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position;\n    },\n\n    customPositionEqualsToPredefined() {\n      return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position;\n    },\n\n    customPositionIsBoundary() {\n      return this.positionIsBoundary(this._customBoundaryPosition);\n    },\n\n    positionIsBoundary: position => [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0,\n\n    getPredefinedPosition(position) {\n      var _this$_orthogonalPosi;\n\n      return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"];\n    },\n\n    resolveOverlappingForCustomPositioning(oppositeAxes) {\n      var that = this;\n\n      if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(a => a.hasNonBoundaryPosition())) {\n        return;\n      }\n\n      var overlappingObj = {\n        axes: [],\n        ticks: []\n      };\n      oppositeAxes.filter(orthogonalAxis => orthogonalAxis.pane === that.pane).forEach(orthogonalAxis => {\n        for (var i = 0; i < that._majorTicks.length; i++) {\n          var tick = that._majorTicks[i];\n          var label = tick.label;\n\n          if (label) {\n            if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\n              overlappingObj.axes.push(orthogonalAxis);\n\n              that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis);\n            }\n\n            for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\n              var oppositeTick = orthogonalAxis._majorTicks[j];\n              var oppositeLabel = oppositeTick.label;\n\n              if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\n                overlappingObj.ticks.push(tick);\n\n                that._shiftThroughAxisOverlappedTick(tick);\n\n                i = that._majorTicks.length;\n                break;\n              }\n            }\n          }\n\n          if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\n            if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\n              tick.mark.attr({\n                translateY: 0\n              });\n            } else if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\n              tick.mark.attr({\n                translateX: 0\n              });\n            }\n          }\n        }\n      });\n    },\n\n    _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {\n      var labelBBox = label.getBBox();\n      var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\n      var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\n      var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\n      var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\n      var translateCoordName = this._isHorizontal ? \"translateX\" : \"translateY\";\n      var defaultOrthogonalAxisLabelPosition = this._isHorizontal ? LEFT : TOP;\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (this._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\n      var labelSize = this._isHorizontal ? labelBBox.width : labelBBox.height;\n      var outsidePart = orthogonalAxisPosition - labelCoord;\n      var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\n      var attr = {};\n      attr[translateCoordName] = translate;\n\n      if (outsidePart > 0 && insidePart > 0) {\n        if (insidePart - outsidePart > 1) {\n          attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent;\n        } else if (outsidePart - insidePart > 1) {\n          attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent;\n        } else {\n          attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent);\n        }\n\n        label.attr(attr);\n      }\n    },\n\n    _shiftThroughAxisOverlappedTick(tick) {\n      var _tick$mark;\n\n      var label = tick.label;\n\n      if (!label) {\n        return;\n      }\n\n      var labelBBox = label.getBBox();\n      var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\n      var axisPosition = this.getAxisPosition();\n      var labelOptions = this.getOptions().label;\n      var labelIndent = labelOptions.indentFromAxis;\n      var labelPosition = labelOptions.position;\n      var defaultLabelPosition = this._isHorizontal ? TOP : LEFT;\n      var translateCoordName = this._isHorizontal ? \"translateY\" : \"translateX\";\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (this._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\n      var labelSize = this._isHorizontal ? labelBBox.height : labelBBox.width;\n      var attr = {};\n      attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\n      label.attr(attr);\n\n      if (tick.mark) {\n        var markerSize = this._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\n        var dir = labelPosition === defaultLabelPosition ? 1 : -1;\n        attr[translateCoordName] = dir * (markerSize - 1);\n        tick.mark.attr(attr);\n      }\n    },\n\n    _detectElementsOverlapping(element1, element2) {\n      if (!element1 || !element2) {\n        return false;\n      }\n\n      var bBox1 = element1.getBBox();\n      var x1 = bBox1.x + element1.attr(\"translateX\");\n      var y1 = bBox1.y + element1.attr(\"translateY\");\n      var bBox2 = element2.getBBox();\n      var x2 = bBox2.x + element2.attr(\"translateX\");\n      var y2 = bBox2.y + element2.attr(\"translateY\");\n      return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height);\n    }\n\n  }\n};\n\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\n  var elementType = isWaved ? \"bezier\" : \"line\";\n  var group = renderer.g().append(root);\n  return function (offset, attr) {\n    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);\n  };\n}\n\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\n  if (!isWaved) {\n    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];\n  }\n\n  breakStart += offset;\n  var currentPosition;\n  var topPoint = breakStart + WAVED_LINE_TOP;\n  var centerPoint = breakStart + WAVED_LINE_CENTER;\n  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\n  var points = [[positionFrom, centerPoint]];\n\n  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\n    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);\n  }\n\n  return [].concat.apply([], points);\n}\n\nfunction rotateLine(lineCoords) {\n  var points = [];\n  var i;\n\n  for (i = 0; i < lineCoords.length; i += 2) {\n    points.push(lineCoords[i + 1]);\n    points.push(lineCoords[i]);\n  }\n\n  return points;\n}","map":{"version":3,"sources":["/Users/rahulsharma/node_modules/devextreme/esm/viz/axes/xy_axes.js"],"names":["Range","formatHelper","dateUtils","extend","generateDateBreaks","noop","getLog","patchFontOptions","getCosAndSin","isDefined","constants","getNextDateUnit","correctDateWithUnitBeginning","_math","Math","_max","max","TOP","top","BOTTOM","bottom","LEFT","left","RIGHT","right","CENTER","center","SCALE_BREAK_OFFSET","RANGE_RATIO","WAVED_LINE_CENTER","WAVED_LINE_TOP","WAVED_LINE_BOTTOM","WAVED_LINE_LENGTH","TICKS_CORRECTIONS","prepareDatesDifferences","datesDifferences","tickInterval","dateUnitInterval","i","dateUnitIntervals","length","count","sortingBreaks","breaks","sort","a","b","from","getMarkerDates","min","markerInterval","origMin","dates","getSequenceByInterval","slice","getStripHorizontalAlignmentPosition","alignment","position","getStripVerticalAlignmentPosition","getMarkerInterval","getMarkerFormat","curDate","prevDate","format","getDatesDifferences","getDateFormatByDifferences","getMaxSide","act","boxes","reduce","prevValue","box","getDistanceByAngle","bBox","rotationAngle","abs","PI","atan","height","width","sin","getMaxConstantLinePadding","constantLines","padding","options","paddingTopBottom","getConstantLineLabelMarginForVerticalAlignment","labelHeight","some","label","verticalAlignment","getLeftMargin","x","getRightMargin","generateRangesOnPoints","points","edgePoints","getRange","maxRange","ranges","curValue","curRange","indexOf","start","end","push","generateAutoBreaks","_ref","series","_ref2","logarithmBase","type","maxAutoBreakCount","minVisible","maxVisible","visibleRange","result","s","getPointsInViewPort","concat","sortedAllPoints","filter","p","minDiff","epsilon","apply","map","r","_maxAutoBreakCount","to","linear","_getStep","spacing","_options","minSpacing","func","_isHorizontal","maxLabelLength","_getMaxLabelHeight","getTicksCountInRange","_majorTicks","_validateOverlappingMode","mode","displayMode","validateOverlappingMode","_validateDisplayMode","getMarkerTrackers","_markerTrackers","_getSharpParam","opposite","_createAxisElement","_renderer","path","_updateAxisElementPosition","axisCoord","_axisPosition","canvas","_getCanvasStartEnd","_axisElement","attr","_getTranslatedCoord","value","offset","_translator","translate","_initAxisPositions","customPositionIsAvailable","_customBoundaryPosition","getCustomBoundaryPosition","customPositionIsBoundary","getPredefinedPosition","getResolvedBoundaryPosition","getCustomPosition","_getTickMarkPoints","coords","tickOptions","isHorizontal","tickOrientation","labelPosition","tickStartCoord","shift","getTickStartPositionShift","y","hasNonBoundaryPosition","floor","_getTitleCoords","horizontal","align","title","fromStartToEnd","canvasStart","canvasEnd","coord","_drawTitleText","group","titleOptions","attrs","opacity","class","cssClass","text","rotate","css","font","append","_checkTitleOverflow","_updateTitleCoords","_title","element","_drawTitle","_axisTitleGroup","_measureTitle","originalSize","getBBox","_drawDateMarker","date","range","markerOptions","marker","invert","getBusinessRange","textIndent","textLeftIndent","pathElement","withoutStick","separatorHeight","stroke","color","sharp","_axisElementsGroup","String","formatLabel","labelOptions","cropped","line","getContentContainer","getEnd","labelBBox","setTitle","hideLabel","dispose","hide","hidden","_drawDateMarkers","that","translator","viewport","_getViewportRange","minBound","dateMarkers","dateMarker","draw","markerDate","markersAreaTop","_getLabelFormatOptions","isEmpty","visible","argumentType","topIndent","getDateUnitInterval","_tickInterval","markerDates","markers","unshift","_adjustDateMarkers","_dateMarkers","_checkMarkersPosition","prevDateMarker","forEach","dy","textTopIndent","translateX","translateY","_initializeMarkersTrackers","renderer","businessRange","nextMarker","markerTracker","fill","data","startValue","endValue","formatString","markerLabelOptions","_markerLabelOptions","_adjustConstantLineLabels","axisPosition","getCanvas","canvasLeft","canvasRight","canvasTop","canvasBottom","verticalCenter","horizontalCenter","maxLabel","item","linesOptions","paddingLeftRight","labelVerticalAlignment","labelHorizontalAlignment","horizontalAlignment","labelIsInside","_drawConstantLinesForEstimating","g","_drawConstantLineLabelText","root","_estimateLabelHeight","drawingType","overlappingBehavior","staggeringSpacing","sinCos","cos","indentFromAxis","estimateMargins","updateCanvas","ticksData","_createTicksAndLabelFormat","ticks","constantLineOptions","_outsideConstantLines","l","rootElement","labelIsVisible","labelValue","labelElement","_textFontStyles","_textOptions","titleElement","constantLinesLabelsElement","labelBox","template","titleBox","constantLinesBox","titleHeight","margin","constantLinesHeight","margins","remove","_checkAlignmentConstantLineLabels","toLowerCase","_getConstantLineLabelsCoords","lineLabelOptions","_orthogonalPositions","_getAdjustedStripLabelCoords","strip","stripOptions","labelWidth","labelCoords","_adjustTitle","boxTitle","loCoord","hiCoord","params","canvasLength","_getScreenDelta","setMaxSize","wordWrap","textOverflow","_wrapped","moreThanOriginalSize","restoreText","coordsIn","_boundaryTicksVisibility","adjust","seriesData","_seriesData","_series","isVisible","seriesRange","getViewport","showZero","correctValueZeroLevel","userBreaks","_getScaleBreaks","isArgumentAxis","updateBusinessRange","hasWrap","getAxisPosition","_getStick","valueMarginsEnabled","_getStripLabelCoords","stripLabelOptions","orthogonalPositions","_getTranslatedValue","pos1","pos2","areCoordsOutsideAxis","visibleArea","getVisibleArea","_getSkippedCategory","skippedCategory","discrete","_tickOffset","_filterBreaks","breakStyle","breakSize","currentBreak","lastResult","newBreak","gapSize","cumulativeWidth","_lastResult$cumulativ","_lastResult$cumulativ2","convertMillisecondsToDateUnits","axisOptions","parser","dataType","workdaysOnly","workWeek","singleWorkdays","holidays","autoBreaksEnabled","_drawBreak","translatedEnd","positionFrom","positionTo","breakStart","isInverted","borderColor","isWaved","spaceAttr","getPoints","rotateLine","drawer","getLineDrawer","_createBreakClipRect","_canvas","clipWidth","clipRect","_breaksElements","id","_createBreaksGroup","clipFrom","clipTo","_axisCssPrefix","_scaleBreaksGroup","_disposeBreaksGroup","drawScaleBreaks","customCanvas","additionGroup","additionBreakFrom","additionBreakTo","breakOptions","containerColor","_axisShift","mainGroup","br","breakCoord","_getSpiderCategoryOption","axesSpacing","getMultipleAxesSpacing","constantLinesGroups","_axisConstantLineGroups","shiftGroup","side","_axisGroup","above","under","orthogonalAxis","getOrthogonalAxis","resolvedPosition","getResolvedPositionOption","getOptions","orthogonalTranslator","getTranslator","orthogonalAxisType","validPosition","validateUnit","currentPosition","_categories","positionIsBoundary","isFinite","customPosition","getCanvasVisibleArea","_options$customPositi","customPositionEqualsToPredefined","_this$_orthogonalPosi","resolveOverlappingForCustomPositioning","oppositeAxes","overlappingObj","axes","pane","tick","_detectElementsOverlapping","_shiftThroughOrthogonalAxisOverlappedTick","j","oppositeTick","oppositeLabel","_shiftThroughAxisOverlappedTick","mark","orthogonalAxisPosition","orthogonalAxisLabelOptions","orthogonalAxisLabelPosition","orthogonalAxisLabelIndent","translateCoordName","defaultOrthogonalAxisLabelPosition","labelCoord","labelSize","outsidePart","insidePart","_tick$mark","tickMarkBBox","labelIndent","defaultLabelPosition","markerSize","dir","element1","element2","bBox1","x1","y1","bBox2","x2","y2","rotatePoints","elementType","topPoint","centerPoint","bottomPoint","lineCoords"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/viz/axes/xy_axes.js)\r\n * Version: 21.2.3\r\n * Build date: Thu Oct 28 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    Range\r\n} from \"../translators/range\";\r\nimport formatHelper from \"../../format_helper\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    generateDateBreaks\r\n} from \"./datetime_breaks\";\r\nimport {\r\n    noop\r\n} from \"../../core/utils/common\";\r\nimport {\r\n    getLog,\r\n    patchFontOptions,\r\n    getCosAndSin\r\n} from \"../core/utils\";\r\nimport {\r\n    isDefined\r\n} from \"../../core/utils/type\";\r\nimport constants from \"./axes_constants\";\r\nvar getNextDateUnit = dateUtils.getNextDateUnit;\r\nvar correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning;\r\nvar _math = Math;\r\nvar _max = _math.max;\r\nvar TOP = constants.top;\r\nvar BOTTOM = constants.bottom;\r\nvar LEFT = constants.left;\r\nvar RIGHT = constants.right;\r\nvar CENTER = constants.center;\r\nvar SCALE_BREAK_OFFSET = 3;\r\nvar RANGE_RATIO = .3;\r\nvar WAVED_LINE_CENTER = 2;\r\nvar WAVED_LINE_TOP = 0;\r\nvar WAVED_LINE_BOTTOM = 4;\r\nvar WAVED_LINE_LENGTH = 24;\r\nvar TICKS_CORRECTIONS = {\r\n    left: -1,\r\n    top: -1,\r\n    right: 0,\r\n    bottom: 0,\r\n    center: -.5\r\n};\r\n\r\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\r\n    var dateUnitInterval;\r\n    var i;\r\n    if (\"week\" === tickInterval) {\r\n        tickInterval = \"day\"\r\n    }\r\n    if (\"quarter\" === tickInterval) {\r\n        tickInterval = \"month\"\r\n    }\r\n    if (datesDifferences[tickInterval]) {\r\n        for (i = 0; i < dateUtils.dateUnitIntervals.length; i++) {\r\n            dateUnitInterval = dateUtils.dateUnitIntervals[i];\r\n            if (datesDifferences[dateUnitInterval]) {\r\n                datesDifferences[dateUnitInterval] = false;\r\n                datesDifferences.count--\r\n            }\r\n            if (dateUnitInterval === tickInterval) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortingBreaks(breaks) {\r\n    return breaks.sort((function(a, b) {\r\n        return a.from - b.from\r\n    }))\r\n}\r\n\r\nfunction getMarkerDates(min, max, markerInterval) {\r\n    var origMin = min;\r\n    var dates;\r\n    min = correctDateWithUnitBeginning(min, markerInterval);\r\n    max = correctDateWithUnitBeginning(max, markerInterval);\r\n    dates = dateUtils.getSequenceByInterval(min, max, markerInterval);\r\n    if (dates.length && origMin > dates[0]) {\r\n        dates = dates.slice(1)\r\n    }\r\n    return dates\r\n}\r\n\r\nfunction getStripHorizontalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"right\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getStripVerticalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"bottom\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getMarkerInterval(tickInterval) {\r\n    var markerInterval = getNextDateUnit(tickInterval);\r\n    if (\"quarter\" === markerInterval) {\r\n        markerInterval = getNextDateUnit(markerInterval)\r\n    }\r\n    return markerInterval\r\n}\r\n\r\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\r\n    var format = markerInterval;\r\n    var datesDifferences = prevDate && dateUtils.getDatesDifferences(prevDate, curDate);\r\n    if (prevDate && \"year\" !== tickInterval) {\r\n        prepareDatesDifferences(datesDifferences, tickInterval);\r\n        format = formatHelper.getDateFormatByDifferences(datesDifferences)\r\n    }\r\n    return format\r\n}\r\n\r\nfunction getMaxSide(act, boxes) {\r\n    return boxes.reduce((function(prevValue, box) {\r\n        return _max(prevValue, act(box))\r\n    }), 0)\r\n}\r\n\r\nfunction getDistanceByAngle(bBox, rotationAngle) {\r\n    rotationAngle = _math.abs(rotationAngle);\r\n    rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\r\n    var a = rotationAngle * (_math.PI / 180);\r\n    if (a >= _math.atan(bBox.height / bBox.width)) {\r\n        return bBox.height / _math.abs(_math.sin(a))\r\n    } else {\r\n        return bBox.width\r\n    }\r\n}\r\n\r\nfunction getMaxConstantLinePadding(constantLines) {\r\n    return constantLines.reduce((function(padding, options) {\r\n        return _max(padding, options.paddingTopBottom)\r\n    }), 0)\r\n}\r\n\r\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\r\n    return constantLines.some((function(options) {\r\n        return options.label.verticalAlignment === alignment\r\n    })) && labelHeight || 0\r\n}\r\n\r\nfunction getLeftMargin(bBox) {\r\n    return _math.abs(bBox.x) || 0\r\n}\r\n\r\nfunction getRightMargin(bBox) {\r\n    return _math.abs(bBox.width - _math.abs(bBox.x)) || 0\r\n}\r\n\r\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\r\n    var i;\r\n    var length;\r\n    var maxRange = null;\r\n    var ranges = [];\r\n    var curValue;\r\n    var prevValue;\r\n    var curRange;\r\n    for (i = 1, length = points.length; i < length; i++) {\r\n        curValue = points[i];\r\n        prevValue = points[i - 1];\r\n        curRange = getRange(curValue, prevValue);\r\n        if (edgePoints.indexOf(curValue) >= 0) {\r\n            if (!maxRange || curRange > maxRange.length) {\r\n                maxRange = {\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                }\r\n            }\r\n        } else {\r\n            if (maxRange && curRange < maxRange.length) {\r\n                ranges.push(maxRange)\r\n            } else {\r\n                ranges.push({\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                })\r\n            }\r\n            maxRange = null\r\n        }\r\n    }\r\n    if (maxRange) {\r\n        ranges.push(maxRange)\r\n    }\r\n    return ranges\r\n}\r\n\r\nfunction generateAutoBreaks(_ref, series, _ref2) {\r\n    var {\r\n        logarithmBase: logarithmBase,\r\n        type: type,\r\n        maxAutoBreakCount: maxAutoBreakCount\r\n    } = _ref;\r\n    var {\r\n        minVisible: minVisible,\r\n        maxVisible: maxVisible\r\n    } = _ref2;\r\n    var breaks = [];\r\n    var getRange = \"logarithmic\" === type ? (min, max) => getLog(max / min, logarithmBase) : (min, max) => max - min;\r\n    var visibleRange = getRange(minVisible, maxVisible);\r\n    var points = series.reduce((result, s) => {\r\n        var points = s.getPointsInViewPort();\r\n        result[0] = result[0].concat(points[0]);\r\n        result[1] = result[1].concat(points[1]);\r\n        return result\r\n    }, [\r\n        [],\r\n        []\r\n    ]);\r\n    var sortedAllPoints = points[0].concat(points[1]).sort((a, b) => b - a);\r\n    var edgePoints = points[1].filter(p => points[0].indexOf(p) < 0);\r\n    var minDiff = RANGE_RATIO * visibleRange;\r\n    var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort((a, b) => b.length - a.length);\r\n    var epsilon = _math.min.apply(null, ranges.map(r => r.length)) / 1e3;\r\n    var _maxAutoBreakCount = isDefined(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\r\n    for (var i = 0; i < _maxAutoBreakCount; i++) {\r\n        if (ranges[i].length >= minDiff) {\r\n            if (visibleRange <= ranges[i].length) {\r\n                break\r\n            }\r\n            visibleRange -= ranges[i].length;\r\n            if (visibleRange > epsilon || visibleRange < -epsilon) {\r\n                breaks.push({\r\n                    from: ranges[i].start,\r\n                    to: ranges[i].end\r\n                });\r\n                minDiff = RANGE_RATIO * visibleRange\r\n            }\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n    sortingBreaks(breaks);\r\n    return breaks\r\n}\r\nexport default {\r\n    linear: {\r\n        _getStep: function(boxes, rotationAngle) {\r\n            var spacing = this._options.label.minSpacing;\r\n            var func = this._isHorizontal ? function(box) {\r\n                return box.width + spacing\r\n            } : function(box) {\r\n                return box.height\r\n            };\r\n            var maxLabelLength = getMaxSide(func, boxes);\r\n            if (rotationAngle) {\r\n                maxLabelLength = getDistanceByAngle({\r\n                    width: maxLabelLength,\r\n                    height: this._getMaxLabelHeight(boxes, 0)\r\n                }, rotationAngle)\r\n            }\r\n            return constants.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength)\r\n        },\r\n        _getMaxLabelHeight: function(boxes, spacing) {\r\n            return getMaxSide((function(box) {\r\n                return box.height\r\n            }), boxes) + spacing\r\n        },\r\n        _validateOverlappingMode: function(mode, displayMode) {\r\n            if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\r\n                return constants.validateOverlappingMode(mode)\r\n            }\r\n            return mode\r\n        },\r\n        _validateDisplayMode: function(mode) {\r\n            return this._isHorizontal ? mode : \"standard\"\r\n        },\r\n        getMarkerTrackers: function() {\r\n            return this._markerTrackers\r\n        },\r\n        _getSharpParam: function(opposite) {\r\n            return this._isHorizontal ^ opposite ? \"h\" : \"v\"\r\n        },\r\n        _createAxisElement: function() {\r\n            return this._renderer.path([], \"line\")\r\n        },\r\n        _updateAxisElementPosition: function() {\r\n            var axisCoord = this._axisPosition;\r\n            var canvas = this._getCanvasStartEnd();\r\n            this._axisElement.attr({\r\n                points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\r\n            })\r\n        },\r\n        _getTranslatedCoord: function(value, offset) {\r\n            return this._translator.translate(value, offset)\r\n        },\r\n        _initAxisPositions() {\r\n            if (this.customPositionIsAvailable()) {\r\n                this._customBoundaryPosition = this.getCustomBoundaryPosition()\r\n            }\r\n            if (!this.customPositionIsAvailable() || this.customPositionIsBoundary()) {\r\n                this._axisPosition = this.getPredefinedPosition(this.getResolvedBoundaryPosition())\r\n            } else {\r\n                this._axisPosition = this.getCustomPosition()\r\n            }\r\n        },\r\n        _getTickMarkPoints(coords, length, tickOptions) {\r\n            var isHorizontal = this._isHorizontal;\r\n            var tickOrientation = this._options.tickOrientation;\r\n            var labelPosition = this._options.label.position;\r\n            var tickStartCoord;\r\n            if (isDefined(tickOrientation)) {\r\n                tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length\r\n            } else {\r\n                var shift = tickOptions.shift || 0;\r\n                if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\r\n                    shift = -shift\r\n                }\r\n                tickStartCoord = shift + this.getTickStartPositionShift(length)\r\n            }\r\n            return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)]\r\n        },\r\n        getTickStartPositionShift(length) {\r\n            var width = this._options.width;\r\n            var position = this.getResolvedBoundaryPosition();\r\n            return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1)\r\n        },\r\n        _getTitleCoords: function() {\r\n            var horizontal = this._isHorizontal;\r\n            var x = this._axisPosition;\r\n            var y = this._axisPosition;\r\n            var align = this._options.title.alignment;\r\n            var canvas = this._getCanvasStartEnd();\r\n            var fromStartToEnd = horizontal || this._options.position === LEFT;\r\n            var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\r\n            var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\r\n            var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\r\n            if (horizontal) {\r\n                x = coord\r\n            } else {\r\n                y = coord\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _drawTitleText: function(group, coords) {\r\n            var options = this._options;\r\n            var titleOptions = options.title;\r\n            var attrs = {\r\n                opacity: titleOptions.opacity,\r\n                align: titleOptions.alignment,\r\n                class: titleOptions.cssClass\r\n            };\r\n            if (!titleOptions.text || !group) {\r\n                return\r\n            }\r\n            coords = coords || this._getTitleCoords();\r\n            if (!this._isHorizontal) {\r\n                attrs.rotate = options.position === LEFT ? 270 : 90\r\n            }\r\n            var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(patchFontOptions(titleOptions.font)).attr(attrs).append(group);\r\n            this._checkTitleOverflow(text);\r\n            return text\r\n        },\r\n        _updateTitleCoords: function() {\r\n            this._title && this._title.element.attr(this._getTitleCoords())\r\n        },\r\n        _drawTitle: function() {\r\n            var title = this._drawTitleText(this._axisTitleGroup);\r\n            if (title) {\r\n                this._title = {\r\n                    element: title\r\n                }\r\n            }\r\n        },\r\n        _measureTitle: function() {\r\n            if (this._title) {\r\n                if (this._title.bBox && !this._title.originalSize) {\r\n                    this._title.originalSize = this._title.bBox\r\n                }\r\n                this._title.bBox = this._title.element.getBBox()\r\n            }\r\n        },\r\n        _drawDateMarker: function(date, options, range) {\r\n            var markerOptions = this._options.marker;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var pathElement;\r\n            if (null === options.x) {\r\n                return\r\n            }\r\n            if (!options.withoutStick) {\r\n                pathElement = this._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\r\n                    \"stroke-width\": markerOptions.width,\r\n                    stroke: markerOptions.color,\r\n                    \"stroke-opacity\": markerOptions.opacity,\r\n                    sharp: \"h\"\r\n                }).append(this._axisElementsGroup)\r\n            }\r\n            var text = String(this.formatLabel(date, options.labelOptions, range));\r\n            return {\r\n                date: date,\r\n                x: options.x,\r\n                y: options.y,\r\n                cropped: options.withoutStick,\r\n                label: this._renderer.text(text, options.x, options.y).css(patchFontOptions(markerOptions.label.font)).append(this._axisElementsGroup),\r\n                line: pathElement,\r\n                getContentContainer() {\r\n                    return this.label\r\n                },\r\n                getEnd: function() {\r\n                    return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width)\r\n                },\r\n                setTitle: function() {\r\n                    this.title = text\r\n                },\r\n                hideLabel: function() {\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.title = text\r\n                },\r\n                hide: function() {\r\n                    if (pathElement) {\r\n                        pathElement.dispose();\r\n                        pathElement = null\r\n                    }\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.hidden = true\r\n                }\r\n            }\r\n        },\r\n        _drawDateMarkers: function() {\r\n            var that = this;\r\n            var options = that._options;\r\n            var translator = that._translator;\r\n            var viewport = that._getViewportRange();\r\n            var minBound = viewport.minVisible;\r\n            var dateMarkers = [];\r\n            var dateMarker;\r\n\r\n            function draw(markerDate, format, withoutStick) {\r\n                return that._drawDateMarker(markerDate, {\r\n                    x: translator.translate(markerDate),\r\n                    y: markersAreaTop,\r\n                    labelOptions: that._getLabelFormatOptions(format),\r\n                    withoutStick: withoutStick\r\n                }, viewport)\r\n            }\r\n            if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\r\n                return []\r\n            }\r\n            var markersAreaTop = that._axisPosition + options.marker.topIndent;\r\n            var tickInterval = dateUtils.getDateUnitInterval(this._tickInterval);\r\n            var markerInterval = getMarkerInterval(tickInterval);\r\n            var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\r\n            if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\r\n                dateMarkers = markerDates.reduce((function(markers, curDate, i, dates) {\r\n                    var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\r\n                    marker && markers.push(marker);\r\n                    return markers\r\n                }), []);\r\n                if (minBound < markerDates[0]) {\r\n                    dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\r\n                    dateMarker && dateMarkers.unshift(dateMarker)\r\n                }\r\n            }\r\n            return dateMarkers\r\n        },\r\n        _adjustDateMarkers: function(offset) {\r\n            offset = offset || 0;\r\n            var that = this;\r\n            var markerOptions = this._options.marker;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var dateMarkers = this._dateMarkers;\r\n            if (!dateMarkers.length) {\r\n                return offset\r\n            }\r\n            if (dateMarkers[0].cropped) {\r\n                if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\r\n                    dateMarkers[0].hideLabel()\r\n                }\r\n            }\r\n            var prevDateMarker;\r\n            dateMarkers.forEach((function(marker, i, markers) {\r\n                if (marker.cropped) {\r\n                    return\r\n                }\r\n                if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\r\n                    marker.hideLabel()\r\n                } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\r\n                    prevDateMarker = marker\r\n                } else {\r\n                    marker.hide()\r\n                }\r\n            }));\r\n            this._dateMarkers.forEach((function(marker) {\r\n                if (marker.label) {\r\n                    var labelBBox = marker.labelBBox;\r\n                    var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\r\n                    marker.label.attr({\r\n                        translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\r\n                        translateY: dy + offset\r\n                    })\r\n                }\r\n                if (marker.line) {\r\n                    marker.line.attr({\r\n                        translateY: offset\r\n                    })\r\n                }\r\n            }));\r\n            that._initializeMarkersTrackers(offset);\r\n            return offset + markerOptions.topIndent + markerOptions.separatorHeight\r\n        },\r\n        _checkMarkersPosition: function(invert, dateMarker, prevDateMarker) {\r\n            if (void 0 === prevDateMarker) {\r\n                return true\r\n            }\r\n            return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd()\r\n        },\r\n        _initializeMarkersTrackers: function(offset) {\r\n            var separatorHeight = this._options.marker.separatorHeight;\r\n            var renderer = this._renderer;\r\n            var businessRange = this._translator.getBusinessRange();\r\n            var canvas = this._getCanvasStartEnd();\r\n            var group = this._axisElementsGroup;\r\n            this._markerTrackers = this._dateMarkers.filter((function(marker) {\r\n                return !marker.hidden\r\n            })).map((function(marker, i, markers) {\r\n                var nextMarker = markers[i + 1] || {\r\n                    x: canvas.end,\r\n                    date: businessRange.max\r\n                };\r\n                var x = marker.x;\r\n                var y = marker.y + offset;\r\n                var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\r\n                    \"stroke-width\": 1,\r\n                    stroke: \"grey\",\r\n                    fill: \"grey\",\r\n                    opacity: 1e-4\r\n                }).append(group);\r\n                markerTracker.data(\"range\", {\r\n                    startValue: marker.date,\r\n                    endValue: nextMarker.date\r\n                });\r\n                if (marker.title) {\r\n                    markerTracker.setTitle(marker.title)\r\n                }\r\n                return markerTracker\r\n            }))\r\n        },\r\n        _getLabelFormatOptions: function(formatString) {\r\n            var markerLabelOptions = this._markerLabelOptions;\r\n            if (!markerLabelOptions) {\r\n                this._markerLabelOptions = markerLabelOptions = extend(true, {}, this._options.marker.label)\r\n            }\r\n            if (!isDefined(this._options.marker.label.format)) {\r\n                markerLabelOptions.format = formatString\r\n            }\r\n            return markerLabelOptions\r\n        },\r\n        _adjustConstantLineLabels: function(constantLines) {\r\n            var that = this;\r\n            var axisPosition = that._options.position;\r\n            var canvas = that.getCanvas();\r\n            var canvasLeft = canvas.left;\r\n            var canvasRight = canvas.width - canvas.right;\r\n            var canvasTop = canvas.top;\r\n            var canvasBottom = canvas.height - canvas.bottom;\r\n            var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\r\n            var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\r\n            var maxLabel = 0;\r\n            constantLines.forEach((function(item) {\r\n                var isHorizontal = that._isHorizontal;\r\n                var linesOptions = item.options;\r\n                var paddingTopBottom = linesOptions.paddingTopBottom;\r\n                var paddingLeftRight = linesOptions.paddingLeftRight;\r\n                var labelOptions = linesOptions.label;\r\n                var labelVerticalAlignment = labelOptions.verticalAlignment;\r\n                var labelHorizontalAlignment = labelOptions.horizontalAlignment;\r\n                var labelIsInside = \"inside\" === labelOptions.position;\r\n                var label = item.label;\r\n                var box = item.labelBBox;\r\n                var translateX;\r\n                var translateY;\r\n                if (null === label || box.isEmpty) {\r\n                    return\r\n                }\r\n                if (isHorizontal) {\r\n                    if (labelIsInside) {\r\n                        if (labelHorizontalAlignment === LEFT) {\r\n                            translateX = item.coord - paddingLeftRight - box.x - box.width\r\n                        } else {\r\n                            translateX = item.coord + paddingLeftRight - box.x\r\n                        }\r\n                        switch (labelVerticalAlignment) {\r\n                            case CENTER:\r\n                                translateY = verticalCenter - box.y - box.height / 2;\r\n                                break;\r\n                            case BOTTOM:\r\n                                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\r\n                                break;\r\n                            default:\r\n                                translateY = canvasTop + paddingTopBottom - box.y\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelVerticalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.height + paddingTopBottom)\r\n                        }\r\n                        translateX = item.coord - box.x - box.width / 2;\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = canvasBottom + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = canvasTop - paddingTopBottom - box.y - box.height\r\n                        }\r\n                    }\r\n                } else if (labelIsInside) {\r\n                    if (labelVerticalAlignment === BOTTOM) {\r\n                        translateY = item.coord + paddingTopBottom - box.y\r\n                    } else {\r\n                        translateY = item.coord - paddingTopBottom - box.y - box.height\r\n                    }\r\n                    switch (labelHorizontalAlignment) {\r\n                        case CENTER:\r\n                            translateX = horizontalCenter - box.x - box.width / 2;\r\n                            break;\r\n                        case RIGHT:\r\n                            translateX = canvasRight - paddingLeftRight - box.x - box.width;\r\n                            break;\r\n                        default:\r\n                            translateX = canvasLeft + paddingLeftRight - box.x\r\n                    }\r\n                } else {\r\n                    if (axisPosition === labelHorizontalAlignment) {\r\n                        maxLabel = _max(maxLabel, box.width + paddingLeftRight)\r\n                    }\r\n                    translateY = item.coord - box.y - box.height / 2;\r\n                    if (labelHorizontalAlignment === RIGHT) {\r\n                        translateX = canvasRight + paddingLeftRight - box.x\r\n                    } else {\r\n                        translateX = canvasLeft - paddingLeftRight - box.x - box.width\r\n                    }\r\n                }\r\n                label.attr({\r\n                    translateX: translateX,\r\n                    translateY: translateY\r\n                })\r\n            }));\r\n            return maxLabel\r\n        },\r\n        _drawConstantLinesForEstimating: function(constantLines) {\r\n            var that = this;\r\n            var renderer = this._renderer;\r\n            var group = renderer.g();\r\n            constantLines.forEach((function(options) {\r\n                that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\r\n                    align: \"center\"\r\n                })\r\n            }));\r\n            return group.append(renderer.root)\r\n        },\r\n        _estimateLabelHeight: function(bBox, labelOptions) {\r\n            var height = bBox.height;\r\n            var drawingType = labelOptions.drawingType;\r\n            if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                height = 2 * height + labelOptions.staggeringSpacing\r\n            }\r\n            if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                var sinCos = getCosAndSin(labelOptions.rotationAngle);\r\n                height = height * sinCos.cos + bBox.width * sinCos.sin\r\n            }\r\n            return height && (height + labelOptions.indentFromAxis || 0) || 0\r\n        },\r\n        estimateMargins: function(canvas) {\r\n            this.updateCanvas(canvas);\r\n            var range = this._getViewportRange();\r\n            var ticksData = this._createTicksAndLabelFormat(range);\r\n            var ticks = ticksData.ticks;\r\n            var tickInterval = ticksData.tickInterval;\r\n            var options = this._options;\r\n            var constantLineOptions = this._outsideConstantLines.filter(l => l.labelOptions.visible).map(l => l.options);\r\n            var rootElement = this._renderer.root;\r\n            var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\r\n            var labelValue = labelIsVisible && this.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\r\n            var labelElement = labelIsVisible && this._renderer.text(labelValue, 0, 0).css(this._textFontStyles).attr(this._textOptions).append(rootElement);\r\n            var titleElement = this._drawTitleText(rootElement, {\r\n                x: 0,\r\n                y: 0\r\n            });\r\n            var constantLinesLabelsElement = this._drawConstantLinesForEstimating(constantLineOptions);\r\n            var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var titleBox = titleElement && titleElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var constantLinesBox = constantLinesLabelsElement.getBBox();\r\n            var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\r\n            var labelHeight = this._estimateLabelHeight(labelBox, options.label);\r\n            var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\r\n            var height = labelHeight + titleHeight;\r\n            var margins = {\r\n                left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\r\n                right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\r\n                top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\r\n                bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\r\n            };\r\n            labelElement && labelElement.remove();\r\n            titleElement && titleElement.remove();\r\n            constantLinesLabelsElement && constantLinesLabelsElement.remove();\r\n            return margins\r\n        },\r\n        _checkAlignmentConstantLineLabels: function(labelOptions) {\r\n            var position = labelOptions.position;\r\n            var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\r\n            var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\r\n            if (this._isHorizontal) {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = CENTER\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                }\r\n            } else if (\"outside\" === position) {\r\n                verticalAlignment = CENTER;\r\n                horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n            } else {\r\n                verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT\r\n            }\r\n            labelOptions.verticalAlignment = verticalAlignment;\r\n            labelOptions.horizontalAlignment = horizontalAlignment\r\n        },\r\n        _getConstantLineLabelsCoords: function(value, lineLabelOptions) {\r\n            var x = value;\r\n            var y = value;\r\n            if (this._isHorizontal) {\r\n                y = this._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"]\r\n            } else {\r\n                x = this._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"]\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getAdjustedStripLabelCoords: function(strip) {\r\n            var stripOptions = strip.options;\r\n            var paddingTopBottom = stripOptions.paddingTopBottom;\r\n            var paddingLeftRight = stripOptions.paddingLeftRight;\r\n            var horizontalAlignment = stripOptions.label.horizontalAlignment;\r\n            var verticalAlignment = stripOptions.label.verticalAlignment;\r\n            var box = strip.labelBBox;\r\n            var labelHeight = box.height;\r\n            var labelWidth = box.width;\r\n            var labelCoords = strip.labelCoords;\r\n            var y = labelCoords.y - box.y;\r\n            var x = labelCoords.x - box.x;\r\n            if (verticalAlignment === TOP) {\r\n                y += paddingTopBottom\r\n            } else if (verticalAlignment === CENTER) {\r\n                y -= labelHeight / 2\r\n            } else if (verticalAlignment === BOTTOM) {\r\n                y -= paddingTopBottom + labelHeight\r\n            }\r\n            if (horizontalAlignment === LEFT) {\r\n                x += paddingLeftRight\r\n            } else if (horizontalAlignment === CENTER) {\r\n                x -= labelWidth / 2\r\n            } else if (horizontalAlignment === RIGHT) {\r\n                x -= paddingLeftRight + labelWidth\r\n            }\r\n            return {\r\n                translateX: x,\r\n                translateY: y\r\n            }\r\n        },\r\n        _adjustTitle: function(offset) {\r\n            offset = offset || 0;\r\n            if (!this._title) {\r\n                return\r\n            }\r\n            var options = this._options;\r\n            var position = options.position;\r\n            var margin = options.title.margin;\r\n            var title = this._title;\r\n            var boxTitle = title.bBox;\r\n            var x = boxTitle.x;\r\n            var y = boxTitle.y;\r\n            var width = boxTitle.width;\r\n            var height = boxTitle.height;\r\n            var axisPosition = this._axisPosition;\r\n            var loCoord = axisPosition - margin - offset;\r\n            var hiCoord = axisPosition + margin + offset;\r\n            var params = {};\r\n            if (this._isHorizontal) {\r\n                if (position === TOP) {\r\n                    params.translateY = loCoord - (y + height)\r\n                } else {\r\n                    params.translateY = hiCoord - y\r\n                }\r\n            } else if (position === LEFT) {\r\n                params.translateX = loCoord - (x + width)\r\n            } else {\r\n                params.translateX = hiCoord - x\r\n            }\r\n            title.element.attr(params)\r\n        },\r\n        _checkTitleOverflow: function(titleElement) {\r\n            if (!this._title && !titleElement) {\r\n                return\r\n            }\r\n            var canvasLength = this._getScreenDelta();\r\n            var title = titleElement ? {\r\n                bBox: titleElement.getBBox(),\r\n                element: titleElement\r\n            } : this._title;\r\n            var titleOptions = this._options.title;\r\n            var boxTitle = title.bBox;\r\n            if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\r\n                title.element.setMaxSize(canvasLength, void 0, {\r\n                    wordWrap: titleOptions.wordWrap || \"none\",\r\n                    textOverflow: titleOptions.textOverflow || \"ellipsis\"\r\n                });\r\n                this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap\r\n            } else {\r\n                var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\r\n                !this._wrapped && moreThanOriginalSize && title.element.restoreText()\r\n            }\r\n        },\r\n        coordsIn: function(x, y) {\r\n            var canvas = this.getCanvas();\r\n            var isHorizontal = this._options.isHorizontal;\r\n            var position = this._options.position;\r\n            var coord = isHorizontal ? y : x;\r\n            if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\r\n                return false\r\n            }\r\n            if (isHorizontal && position === constants.top || !isHorizontal && position === constants.left) {\r\n                return coord < canvas[position]\r\n            }\r\n            return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position]\r\n        },\r\n        _boundaryTicksVisibility: {\r\n            min: true,\r\n            max: true\r\n        },\r\n        adjust() {\r\n            var seriesData = this._seriesData;\r\n            var viewport = this._series.filter(s => s.isVisible()).reduce((range, s) => {\r\n                var seriesRange = s.getViewport();\r\n                range.min = isDefined(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\r\n                range.max = isDefined(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\r\n                if (s.showZero) {\r\n                    range = new Range(range);\r\n                    range.correctValueZeroLevel()\r\n                }\r\n                return range\r\n            }, {});\r\n            if (isDefined(viewport.min) && isDefined(viewport.max)) {\r\n                seriesData.minVisible = viewport.min;\r\n                seriesData.maxVisible = viewport.max\r\n            }\r\n            seriesData.userBreaks = this._getScaleBreaks(this._options, {\r\n                minVisible: seriesData.minVisible,\r\n                maxVisible: seriesData.maxVisible\r\n            }, this._series, this.isArgumentAxis);\r\n            this._translator.updateBusinessRange(this._getViewportRange())\r\n        },\r\n        hasWrap() {\r\n            return this._wrapped\r\n        },\r\n        getAxisPosition() {\r\n            return this._axisPosition\r\n        },\r\n        _getStick: function() {\r\n            return !this._options.valueMarginsEnabled\r\n        },\r\n        _getStripLabelCoords: function(from, to, stripLabelOptions) {\r\n            var orthogonalPositions = this._orthogonalPositions;\r\n            var isHorizontal = this._isHorizontal;\r\n            var horizontalAlignment = stripLabelOptions.horizontalAlignment;\r\n            var verticalAlignment = stripLabelOptions.verticalAlignment;\r\n            var x;\r\n            var y;\r\n            if (isHorizontal) {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x = from + (to - from) / 2\r\n                } else if (horizontalAlignment === LEFT) {\r\n                    x = from\r\n                } else if (horizontalAlignment === RIGHT) {\r\n                    x = to\r\n                }\r\n                y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)]\r\n            } else {\r\n                x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\r\n                if (verticalAlignment === TOP) {\r\n                    y = from\r\n                } else if (verticalAlignment === CENTER) {\r\n                    y = to + (from - to) / 2\r\n                } else if (verticalAlignment === BOTTOM) {\r\n                    y = to\r\n                }\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getTranslatedValue: function(value, offset) {\r\n            var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\r\n            var pos2 = this._axisPosition;\r\n            var isHorizontal = this._isHorizontal;\r\n            return {\r\n                x: isHorizontal ? pos1 : pos2,\r\n                y: isHorizontal ? pos2 : pos1\r\n            }\r\n        },\r\n        areCoordsOutsideAxis: function(coords) {\r\n            var coord = this._isHorizontal ? coords.x : coords.y;\r\n            var visibleArea = this.getVisibleArea();\r\n            if (coord < visibleArea[0] || coord > visibleArea[1]) {\r\n                return true\r\n            }\r\n            return false\r\n        },\r\n        _getSkippedCategory: function(ticks) {\r\n            var skippedCategory;\r\n            if (this._options.type === constants.discrete && this._tickOffset && 0 !== ticks.length) {\r\n                skippedCategory = ticks[ticks.length - 1]\r\n            }\r\n            return skippedCategory\r\n        },\r\n        _filterBreaks: function(breaks, viewport, breakStyle) {\r\n            var minVisible = viewport.minVisible;\r\n            var maxVisible = viewport.maxVisible;\r\n            var breakSize = breakStyle ? breakStyle.width : 0;\r\n            return breaks.reduce((function(result, currentBreak) {\r\n                var from = currentBreak.from;\r\n                var to = currentBreak.to;\r\n                var lastResult = result[result.length - 1];\r\n                var newBreak;\r\n                if (!isDefined(from) || !isDefined(to)) {\r\n                    return result\r\n                }\r\n                if (from > to) {\r\n                    to = [from, from = to][0]\r\n                }\r\n                if (result.length && from < lastResult.to) {\r\n                    if (to > lastResult.to) {\r\n                        lastResult.to = to > maxVisible ? maxVisible : to;\r\n                        if (lastResult.gapSize) {\r\n                            lastResult.gapSize = void 0;\r\n                            lastResult.cumulativeWidth += breakSize\r\n                        }\r\n                    }\r\n                } else if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\r\n                    from = from >= minVisible ? from : minVisible;\r\n                    to = to <= maxVisible ? to : maxVisible;\r\n                    if (to - from < maxVisible - minVisible) {\r\n                        var _lastResult$cumulativ;\r\n                        newBreak = {\r\n                            from: from,\r\n                            to: to,\r\n                            cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\r\n                        };\r\n                        if (currentBreak.gapSize) {\r\n                            var _lastResult$cumulativ2;\r\n                            newBreak.gapSize = dateUtils.convertMillisecondsToDateUnits(to - from);\r\n                            newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0\r\n                        }\r\n                        result.push(newBreak)\r\n                    }\r\n                }\r\n                return result\r\n            }), [])\r\n        },\r\n        _getScaleBreaks: function(axisOptions, viewport, series, isArgumentAxis) {\r\n            var that = this;\r\n            var breaks = (axisOptions.breaks || []).map((function(b) {\r\n                return {\r\n                    from: that.parser(b.startValue),\r\n                    to: that.parser(b.endValue)\r\n                }\r\n            }));\r\n            if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\r\n                breaks = breaks.concat(generateDateBreaks(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays))\r\n            }\r\n            if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\r\n                breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport))\r\n            }\r\n            return sortingBreaks(breaks)\r\n        },\r\n        _drawBreak: function(translatedEnd, positionFrom, positionTo, width, options, group) {\r\n            var breakStart = translatedEnd - (!this._translator.isInverted() ? width + 1 : 0);\r\n            var attr = {\r\n                \"stroke-width\": 1,\r\n                stroke: options.borderColor,\r\n                sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\r\n            };\r\n            var spaceAttr = {\r\n                stroke: options.color,\r\n                \"stroke-width\": width\r\n            };\r\n            var getPoints = this._isHorizontal ? rotateLine : function(p) {\r\n                return p\r\n            };\r\n            var drawer = getLineDrawer(this._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\r\n            drawer(width / 2, spaceAttr);\r\n            drawer(0, attr);\r\n            drawer(width, attr)\r\n        },\r\n        _createBreakClipRect: function(from, to) {\r\n            var canvas = this._canvas;\r\n            var clipWidth = to - from;\r\n            var clipRect;\r\n            if (this._isHorizontal) {\r\n                clipRect = this._renderer.clipRect(canvas.left, from, canvas.width, clipWidth)\r\n            } else {\r\n                clipRect = this._renderer.clipRect(from, canvas.top, clipWidth, canvas.height)\r\n            }\r\n            this._breaksElements = this._breaksElements || [];\r\n            this._breaksElements.push(clipRect);\r\n            return clipRect.id\r\n        },\r\n        _createBreaksGroup: function(clipFrom, clipTo) {\r\n            var group = this._renderer.g().attr({\r\n                class: this._axisCssPrefix + \"breaks\",\r\n                \"clip-path\": this._createBreakClipRect(clipFrom, clipTo)\r\n            }).append(this._scaleBreaksGroup);\r\n            this._breaksElements = this._breaksElements || [];\r\n            this._breaksElements.push(group);\r\n            return group\r\n        },\r\n        _disposeBreaksGroup: function() {\r\n            (this._breaksElements || []).forEach((function(clipRect) {\r\n                clipRect.dispose()\r\n            }));\r\n            this._breaksElements = null\r\n        },\r\n        drawScaleBreaks: function(customCanvas) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var breakStyle = options.breakStyle;\r\n            var position = options.position;\r\n            var positionFrom;\r\n            var positionTo;\r\n            var breaks = that._translator.getBusinessRange().breaks || [];\r\n            var additionGroup;\r\n            var additionBreakFrom;\r\n            var additionBreakTo;\r\n            that._disposeBreaksGroup();\r\n            if (!(breaks && breaks.length)) {\r\n                return\r\n            }\r\n            var breakOptions = {\r\n                color: that._options.containerColor,\r\n                borderColor: breakStyle.color,\r\n                isHorizontal: that._isHorizontal,\r\n                isWaved: \"straight\" !== breakStyle.line.toLowerCase()\r\n            };\r\n            if (customCanvas) {\r\n                positionFrom = customCanvas.start;\r\n                positionTo = customCanvas.end\r\n            } else {\r\n                positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\r\n                positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0)\r\n            }\r\n            var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\r\n            if (that._axisShift && options.visible) {\r\n                additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\r\n                additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\r\n                additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo)\r\n            }\r\n            breaks.forEach((function(br) {\r\n                if (!br.gapSize) {\r\n                    var breakCoord = that._getTranslatedCoord(br.to);\r\n                    that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\r\n                    if (that._axisShift && options.visible) {\r\n                        that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup)\r\n                    }\r\n                }\r\n            }))\r\n        },\r\n        _getSpiderCategoryOption: noop,\r\n        shift: function(margins) {\r\n            var options = this._options;\r\n            var isHorizontal = options.isHorizontal;\r\n            var axesSpacing = this.getMultipleAxesSpacing();\r\n            var constantLinesGroups = this._axisConstantLineGroups;\r\n\r\n            function shiftGroup(side, group) {\r\n                var attr = {\r\n                    translateX: 0,\r\n                    translateY: 0\r\n                };\r\n                var shift = margins[side] ? margins[side] + axesSpacing : 0;\r\n                attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\r\n                (group[side] || group).attr(attr);\r\n                return shift\r\n            }\r\n            this._axisShift = shiftGroup(options.position, this._axisGroup);\r\n            shiftGroup(options.position, this._axisElementsGroup);\r\n            (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(side => {\r\n                shiftGroup(side, constantLinesGroups.above);\r\n                shiftGroup(side, constantLinesGroups.under)\r\n            })\r\n        },\r\n        getCustomPosition(position) {\r\n            var orthogonalAxis = this.getOrthogonalAxis();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\r\n            var offset = this.getOptions().offset;\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var orthogonalAxisType = orthogonalAxis.getOptions().type;\r\n            var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\r\n            var currentPosition;\r\n            if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\r\n                validPosition = void 0\r\n            }\r\n            if (this.positionIsBoundary(resolvedPosition)) {\r\n                currentPosition = this.getPredefinedPosition(resolvedPosition)\r\n            } else if (!isDefined(validPosition)) {\r\n                currentPosition = this.getPredefinedPosition(this.getOptions().position)\r\n            } else {\r\n                currentPosition = orthogonalTranslator.to(validPosition, -1)\r\n            }\r\n            if (isFinite(currentPosition) && isFinite(offset)) {\r\n                currentPosition += offset\r\n            }\r\n            return currentPosition\r\n        },\r\n        getCustomBoundaryPosition(position) {\r\n            var {\r\n                customPosition: customPosition,\r\n                offset: offset\r\n            } = this.getOptions();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\r\n            var orthogonalAxis = this.getOrthogonalAxis();\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\r\n            if (!isDefined(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\r\n                return\r\n            }\r\n            var currentPosition = this.getCustomPosition(resolvedPosition);\r\n            if (!isDefined(currentPosition)) {\r\n                return this.getResolvedBoundaryPosition()\r\n            } else if (isDefined(customPosition)) {\r\n                if (currentPosition <= visibleArea.min) {\r\n                    return this._isHorizontal ? TOP : LEFT\r\n                } else if (currentPosition >= visibleArea.max) {\r\n                    return this._isHorizontal ? BOTTOM : RIGHT\r\n                }\r\n            } else if (isDefined(offset)) {\r\n                if (currentPosition <= this._orthogonalPositions.start) {\r\n                    return this._isHorizontal ? TOP : LEFT\r\n                } else if (currentPosition >= this._orthogonalPositions.end) {\r\n                    return this._isHorizontal ? BOTTOM : RIGHT\r\n                }\r\n            }\r\n            return currentPosition\r\n        },\r\n        getResolvedPositionOption() {\r\n            var _options$customPositi;\r\n            var options = this.getOptions();\r\n            return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position\r\n        },\r\n        customPositionIsAvailable() {\r\n            var options = this.getOptions();\r\n            return isDefined(this.getOrthogonalAxis()) && (isDefined(options.customPosition) || isFinite(options.offset))\r\n        },\r\n        hasNonBoundaryPosition() {\r\n            return this.customPositionIsAvailable() && !this.customPositionIsBoundary()\r\n        },\r\n        getResolvedBoundaryPosition() {\r\n            return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position\r\n        },\r\n        customPositionEqualsToPredefined() {\r\n            return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position\r\n        },\r\n        customPositionIsBoundary() {\r\n            return this.positionIsBoundary(this._customBoundaryPosition)\r\n        },\r\n        positionIsBoundary: position => [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0,\r\n        getPredefinedPosition(position) {\r\n            var _this$_orthogonalPosi;\r\n            return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"]\r\n        },\r\n        resolveOverlappingForCustomPositioning(oppositeAxes) {\r\n            var that = this;\r\n            if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(a => a.hasNonBoundaryPosition())) {\r\n                return\r\n            }\r\n            var overlappingObj = {\r\n                axes: [],\r\n                ticks: []\r\n            };\r\n            oppositeAxes.filter(orthogonalAxis => orthogonalAxis.pane === that.pane).forEach(orthogonalAxis => {\r\n                for (var i = 0; i < that._majorTicks.length; i++) {\r\n                    var tick = that._majorTicks[i];\r\n                    var label = tick.label;\r\n                    if (label) {\r\n                        if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\r\n                            overlappingObj.axes.push(orthogonalAxis);\r\n                            that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis)\r\n                        }\r\n                        for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\r\n                            var oppositeTick = orthogonalAxis._majorTicks[j];\r\n                            var oppositeLabel = oppositeTick.label;\r\n                            if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\r\n                                overlappingObj.ticks.push(tick);\r\n                                that._shiftThroughAxisOverlappedTick(tick);\r\n                                i = that._majorTicks.length;\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                    if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\r\n                        if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\r\n                            tick.mark.attr({\r\n                                translateY: 0\r\n                            })\r\n                        } else if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\r\n                            tick.mark.attr({\r\n                                translateX: 0\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n            })\r\n        },\r\n        _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {\r\n            var labelBBox = label.getBBox();\r\n            var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\r\n            var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\r\n            var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\r\n            var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\r\n            var translateCoordName = this._isHorizontal ? \"translateX\" : \"translateY\";\r\n            var defaultOrthogonalAxisLabelPosition = this._isHorizontal ? LEFT : TOP;\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (this._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\r\n            var labelSize = this._isHorizontal ? labelBBox.width : labelBBox.height;\r\n            var outsidePart = orthogonalAxisPosition - labelCoord;\r\n            var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate;\r\n            if (outsidePart > 0 && insidePart > 0) {\r\n                if (insidePart - outsidePart > 1) {\r\n                    attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent\r\n                } else if (outsidePart - insidePart > 1) {\r\n                    attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent\r\n                } else {\r\n                    attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent)\r\n                }\r\n                label.attr(attr)\r\n            }\r\n        },\r\n        _shiftThroughAxisOverlappedTick(tick) {\r\n            var _tick$mark;\r\n            var label = tick.label;\r\n            if (!label) {\r\n                return\r\n            }\r\n            var labelBBox = label.getBBox();\r\n            var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\r\n            var axisPosition = this.getAxisPosition();\r\n            var labelOptions = this.getOptions().label;\r\n            var labelIndent = labelOptions.indentFromAxis;\r\n            var labelPosition = labelOptions.position;\r\n            var defaultLabelPosition = this._isHorizontal ? TOP : LEFT;\r\n            var translateCoordName = this._isHorizontal ? \"translateY\" : \"translateX\";\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (this._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\r\n            var labelSize = this._isHorizontal ? labelBBox.height : labelBBox.width;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\r\n            label.attr(attr);\r\n            if (tick.mark) {\r\n                var markerSize = this._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\r\n                var dir = labelPosition === defaultLabelPosition ? 1 : -1;\r\n                attr[translateCoordName] = dir * (markerSize - 1);\r\n                tick.mark.attr(attr)\r\n            }\r\n        },\r\n        _detectElementsOverlapping(element1, element2) {\r\n            if (!element1 || !element2) {\r\n                return false\r\n            }\r\n            var bBox1 = element1.getBBox();\r\n            var x1 = bBox1.x + element1.attr(\"translateX\");\r\n            var y1 = bBox1.y + element1.attr(\"translateY\");\r\n            var bBox2 = element2.getBBox();\r\n            var x2 = bBox2.x + element2.attr(\"translateX\");\r\n            var y2 = bBox2.y + element2.attr(\"translateY\");\r\n            return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height)\r\n        }\r\n    }\r\n};\r\n\r\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\r\n    var elementType = isWaved ? \"bezier\" : \"line\";\r\n    var group = renderer.g().append(root);\r\n    return function(offset, attr) {\r\n        renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group)\r\n    }\r\n}\r\n\r\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\r\n    if (!isWaved) {\r\n        return [positionFrom, breakStart + offset, positionTo, breakStart + offset]\r\n    }\r\n    breakStart += offset;\r\n    var currentPosition;\r\n    var topPoint = breakStart + WAVED_LINE_TOP;\r\n    var centerPoint = breakStart + WAVED_LINE_CENTER;\r\n    var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\r\n    var points = [\r\n        [positionFrom, centerPoint]\r\n    ];\r\n    for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\r\n        points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint])\r\n    }\r\n    return [].concat.apply([], points)\r\n}\r\n\r\nfunction rotateLine(lineCoords) {\r\n    var points = [];\r\n    var i;\r\n    for (i = 0; i < lineCoords.length; i += 2) {\r\n        points.push(lineCoords[i + 1]);\r\n        points.push(lineCoords[i])\r\n    }\r\n    return points\r\n}\r\n"]},"metadata":{},"sourceType":"module"}